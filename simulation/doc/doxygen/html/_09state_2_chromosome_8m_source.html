<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Whole Cell Simulation: src/+edu/+stanford/+covert/+cell/+sim/+state/Chromosome.m Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Whole Cell Simulation
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('_09state_2_chromosome_8m.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">src/+edu/+stanford/+covert/+cell/+sim/+state/Chromosome.m</div>  </div>
</div><!--header-->
<div class="contents">
<a href="_09state_2_chromosome_8m.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 %<a class="code" href="class_chromosome.html">Chromosome</a>
<a name="l00002"></a>00002 % Integration point <span class="keywordflow">for</span> processes which interact with specific
<a name="l00003"></a>00003 % positions/strands of the cell<span class="stringliteral">&#39;s chromosome(s).</span>
<a name="l00004"></a>00004 <span class="stringliteral">% - Represents the portion of chromosome(s) accessible to enzymes. That is</span>
<a name="l00005"></a>00005 <span class="stringliteral">%   positions/strands which are NOT</span>
<a name="l00006"></a>00006 <span class="stringliteral">%   - damaged in any way (no gap sites, abasic sites, damaged</span>
<a name="l00007"></a>00007 <span class="stringliteral">%     sugar-phosphates, damaged bases, cross links, strand breaks,</span>
<a name="l00008"></a>00008 <span class="stringliteral">%     or Holliday junctions)</span>
<a name="l00009"></a>00009 <span class="stringliteral">%   - stably bound by enzymes</span>
<a name="l00010"></a>00010 <span class="stringliteral">%   - single stranded</span>
<a name="l00011"></a>00011 <span class="stringliteral">%</span>
<a name="l00012"></a>00012 <span class="stringliteral">% Terminology:</span>
<a name="l00013"></a>00013 <span class="stringliteral">% ==================</span>
<a name="l00014"></a>00014 <span class="stringliteral">%         Site  single base/bond of chromosomes, indicated by strand index and</span>
<a name="l00015"></a>00015 <span class="stringliteral">%               number of bases/bonds along 5&#39;</span>-&gt;3<span class="stringliteral">&#39; strand from ORI [position X</span>
<a name="l00016"></a>00016 <span class="stringliteral">%               strand]</span>
<a name="l00017"></a>00017 <span class="stringliteral">%       Region  contiguous set of bases/bonds of chromosomes, indicated by start</span>
<a name="l00018"></a>00018 <span class="stringliteral">%               and end positions (bases/bonds along 5&#39;</span>-&gt;3<span class="stringliteral">&#39; strand from ORI and</span>
<a name="l00019"></a>00019 <span class="stringliteral">%               strand (positive/negative)</span>
<a name="l00020"></a>00020 <span class="stringliteral">%   Accessible  polymerized, not bound by protein, and not damaged</span>
<a name="l00021"></a>00021 <span class="stringliteral">% Inaccessible  not polymerized, bound by protein, or damaged</span>
<a name="l00022"></a>00022 <span class="stringliteral">%</span>
<a name="l00023"></a>00023 <span class="stringliteral">% Author: Jonathan Karr, jkarr@stanford.edu</span>
<a name="l00024"></a>00024 <span class="stringliteral">% Affiliation: Covert Lab, Department of Bioengineering, Stanford University</span>
<a name="l00025"></a>00025 <span class="stringliteral">% Last Updated: 9/12/2010</span>
<a name="l00026"></a>00026 <span class="stringliteral"></span>
<a name="l00027"></a>00027 <span class="stringliteral">%TODO</span>
<a name="l00028"></a>00028 <span class="stringliteral">%- more precise ignoreDamageFilter</span>
<a name="l00029"></a>00029 <span class="stringliteral">%- include gapsites in isRegionPolymerized</span>
<a name="l00030"></a>00030 <span class="stringliteral">classdef Chromosome &lt; edu.stanford.covert.cell.sim.CellState</span>
<a name="l00031"></a>00031 <span class="stringliteral">    %constants</span>
<a name="l00032"></a>00032 <span class="stringliteral">    properties (Constant)</span>
<a name="l00033"></a>00033 <span class="stringliteral">        optionNames             = {   %names of properties that are options</span>
<a name="l00034"></a>00034 <span class="stringliteral">            &#39;</span>verbosity<span class="stringliteral">&#39;;</span>
<a name="l00035"></a>00035 <span class="stringliteral">            &#39;</span>seed<span class="stringliteral">&#39;;</span>
<a name="l00036"></a>00036 <span class="stringliteral">            };</span>
<a name="l00037"></a>00037 <span class="stringliteral">        fixedConstantNames      = {   %names of process properties that are considered fixed constants</span>
<a name="l00038"></a>00038 <span class="stringliteral">            &#39;</span>doubleStrandBreakSeparation<span class="stringliteral">&#39;;</span>
<a name="l00039"></a>00039 <span class="stringliteral">            &#39;</span>strandBreakClassification_doubleStrandBreakSeparation<span class="stringliteral">&#39;;</span>
<a name="l00040"></a>00040 <span class="stringliteral">            &#39;</span>strandBreakClassification_segmentLength<span class="stringliteral">&#39;;</span>
<a name="l00041"></a>00041 <span class="stringliteral">            &#39;</span>sequence<span class="stringliteral">&#39;;</span>
<a name="l00042"></a>00042 <span class="stringliteral">            &#39;</span>sequenceLen<span class="stringliteral">&#39;;</span>
<a name="l00043"></a>00043 <span class="stringliteral">            &#39;</span>oriCPosition<span class="stringliteral">&#39;;</span>
<a name="l00044"></a>00044 <span class="stringliteral">            &#39;</span>terCPosition<span class="stringliteral">&#39;;</span>
<a name="l00045"></a>00045 <span class="stringliteral">            &#39;</span>transcriptionUnitStartCoordinates<span class="stringliteral">&#39;;</span>
<a name="l00046"></a>00046 <span class="stringliteral">            &#39;</span>transcriptionUnitLengths<span class="stringliteral">&#39;;</span>
<a name="l00047"></a>00047 <span class="stringliteral">            &#39;</span>transcriptionUnitStrands<span class="stringliteral">&#39;;</span>
<a name="l00048"></a>00048 <span class="stringliteral">            &#39;</span>monomerDNAFootprints<span class="stringliteral">&#39;;</span>
<a name="l00049"></a>00049 <span class="stringliteral">            &#39;</span>complexDNAFootprints<span class="stringliteral">&#39;;</span>
<a name="l00050"></a>00050 <span class="stringliteral">            &#39;</span>monomerDNAFootprintBindingStrandedness<span class="stringliteral">&#39;;</span>
<a name="l00051"></a>00051 <span class="stringliteral">            &#39;</span>complexDNAFootprintBindingStrandedness<span class="stringliteral">&#39;;</span>
<a name="l00052"></a>00052 <span class="stringliteral">            &#39;</span>monomerDNAFootprintRegionStrandedness<span class="stringliteral">&#39;;</span>
<a name="l00053"></a>00053 <span class="stringliteral">            &#39;</span>complexDNAFootprintRegionStrandedness<span class="stringliteral">&#39;;</span>
<a name="l00054"></a>00054 <span class="stringliteral">            &#39;</span>reactionBoundMonomer<span class="stringliteral">&#39;;</span>
<a name="l00055"></a>00055 <span class="stringliteral">            &#39;</span>reactionBoundComplex<span class="stringliteral">&#39;;</span>
<a name="l00056"></a>00056 <span class="stringliteral">            &#39;</span>reactionMonomerCatalysisMatrix<span class="stringliteral">&#39;;</span>
<a name="l00057"></a>00057 <span class="stringliteral">            &#39;</span>reactionComplexCatalysisMatrix<span class="stringliteral">&#39;;</span>
<a name="l00058"></a>00058 <span class="stringliteral">            &#39;</span>reactionThresholds<span class="stringliteral">&#39;;</span>
<a name="l00059"></a>00059 <span class="stringliteral">            &#39;</span>relaxedBasesPerTurn<span class="stringliteral">&#39;;</span>
<a name="l00060"></a>00060 <span class="stringliteral">            &#39;</span>equilibriumSuperhelicalDensity<span class="stringliteral">&#39;;</span>
<a name="l00061"></a>00061 <span class="stringliteral">            &#39;</span>supercoiledSuperhelicalDensityTolerance<span class="stringliteral">&#39;;</span>
<a name="l00062"></a>00062 <span class="stringliteral">            };</span>
<a name="l00063"></a>00063 <span class="stringliteral">        fittedConstantNames = {};  %names of process properties that are considered fitted constants, and should be stored with the simulation as such</span>
<a name="l00064"></a>00064 <span class="stringliteral">        stateNames = {             %names of properties which are part of the simulation&#39;</span>s state
<a name="l00065"></a>00065             <span class="stringliteral">&#39;polymerizedRegions&#39;</span>;
<a name="l00066"></a>00066             <span class="stringliteral">&#39;linkingNumbers&#39;</span>;
<a name="l00067"></a>00067             <span class="stringliteral">&#39;monomerBoundSites&#39;</span>;
<a name="l00068"></a>00068             <span class="stringliteral">&#39;complexBoundSites&#39;</span>;
<a name="l00069"></a>00069             <span class="stringliteral">&#39;gapSites&#39;</span>;
<a name="l00070"></a>00070             <span class="stringliteral">&#39;abasicSites&#39;</span>;
<a name="l00071"></a>00071             <span class="stringliteral">&#39;damagedSugarPhosphates&#39;</span>;
<a name="l00072"></a>00072             <span class="stringliteral">&#39;damagedBases&#39;</span>;
<a name="l00073"></a>00073             <span class="stringliteral">&#39;intrastrandCrossLinks&#39;</span>;
<a name="l00074"></a>00074             <span class="stringliteral">&#39;strandBreaks&#39;</span>;
<a name="l00075"></a>00075             <span class="stringliteral">&#39;hollidayJunctions&#39;</span>;
<a name="l00076"></a>00076             <span class="stringliteral">&#39;segregated&#39;</span>;
<a name="l00077"></a>00077             };
<a name="l00078"></a>00078         dependentStateNames     = {   %names of <a class="code" href="json_parse_8m.html#a6e4256f69b751d3d7ec4ea52ff5a8dee">properties</a> which can be calculated from the simulation<span class="stringliteral">&#39;s state</span>
<a name="l00079"></a>00079 <span class="stringliteral">            %&#39;</span>unpolymerizedRegions<span class="stringliteral">&#39;</span>
<a name="l00080"></a>00080 <span class="stringliteral">            &#39;</span>singleStrandedRegions<span class="stringliteral">&#39;</span>
<a name="l00081"></a>00081 <span class="stringliteral">            &#39;</span>doubleStrandedRegions<span class="stringliteral">&#39;</span>
<a name="l00082"></a>00082 <span class="stringliteral">            &#39;</span>geneCopyNumbers<span class="stringliteral">&#39;</span>
<a name="l00083"></a>00083 <span class="stringliteral">            %&#39;</span>polymerizedGenes<span class="stringliteral">&#39;</span>
<a name="l00084"></a>00084 <span class="stringliteral">            &#39;</span>transcriptionUnitCopyNumbers<span class="stringliteral">&#39;</span>
<a name="l00085"></a>00085 <span class="stringliteral">            %&#39;</span>polymerizedTranscriptionUnits<span class="stringliteral">&#39;</span>
<a name="l00086"></a>00086 <span class="stringliteral">            %&#39;</span>geneCopyNumbers_Accessible<span class="stringliteral">&#39;</span>
<a name="l00087"></a>00087 <span class="stringliteral">            %&#39;</span>transcriptionUnitCopyNumbers_Accessible<span class="stringliteral">&#39;</span>
<a name="l00088"></a>00088 <span class="stringliteral">            %&#39;</span>accessibleGenes<span class="stringliteral">&#39;</span>
<a name="l00089"></a>00089 <span class="stringliteral">            %&#39;</span>accessibleTranscriptionUnits<span class="stringliteral">&#39;</span>
<a name="l00090"></a>00090 <span class="stringliteral">            &#39;</span>ploidy<span class="stringliteral">&#39;</span>
<a name="l00091"></a>00091 <span class="stringliteral">            %&#39;</span>linkingNumbers_minFreeEnergy<span class="stringliteral">&#39;</span>
<a name="l00092"></a>00092 <span class="stringliteral">            %&#39;</span>supercoils<span class="stringliteral">&#39;</span>
<a name="l00093"></a>00093 <span class="stringliteral">            &#39;</span>superhelicalDensity<span class="stringliteral">&#39;</span>
<a name="l00094"></a>00094 <span class="stringliteral">            %&#39;</span>supercoiled<span class="stringliteral">&#39;</span>
<a name="l00095"></a>00095 <span class="stringliteral">            %&#39;</span>damagedSites<span class="stringliteral">&#39;</span>
<a name="l00096"></a>00096 <span class="stringliteral">            %&#39;</span>damagedSites_shifted_incm6AD<span class="stringliteral">&#39;</span>
<a name="l00097"></a>00097 <span class="stringliteral">            %&#39;</span>damagedSites_nonRedundant<span class="stringliteral">&#39;</span>
<a name="l00098"></a>00098 <span class="stringliteral">            %&#39;</span>damagedSites_excm6AD<span class="stringliteral">&#39;</span>
<a name="l00099"></a>00099 <span class="stringliteral">            %&#39;</span>gapSites3<span class="stringliteral">&#39;</span>
<a name="l00100"></a>00100 <span class="stringliteral">            %&#39;</span>gapSites5<span class="stringliteral">&#39;</span>
<a name="l00101"></a>00101 <span class="stringliteral">            %&#39;</span>abasicSites3<span class="stringliteral">&#39;</span>
<a name="l00102"></a>00102 <span class="stringliteral">            %&#39;</span>abasicSites5<span class="stringliteral">&#39;</span>
<a name="l00103"></a>00103 <span class="stringliteral">            %&#39;</span>damagedSugarPhosphates3<span class="stringliteral">&#39;</span>
<a name="l00104"></a>00104 <span class="stringliteral">            %&#39;</span>damagedSugarPhosphates5<span class="stringliteral">&#39;</span>
<a name="l00105"></a>00105 <span class="stringliteral">            %&#39;</span>damagedBases3<span class="stringliteral">&#39;</span>
<a name="l00106"></a>00106 <span class="stringliteral">            %&#39;</span>damagedBases5<span class="stringliteral">&#39;</span>
<a name="l00107"></a>00107 <span class="stringliteral">            %&#39;</span>strandBreaks3<span class="stringliteral">&#39;</span>
<a name="l00108"></a>00108 <span class="stringliteral">            %&#39;</span>strandBreaks5<span class="stringliteral">&#39;</span>
<a name="l00109"></a>00109 <span class="stringliteral">            %&#39;</span>intrastrandCrossLinks3<span class="stringliteral">&#39;</span>
<a name="l00110"></a>00110 <span class="stringliteral">            %&#39;</span>intrastrandCrossLinks5<span class="stringliteral">&#39;</span>
<a name="l00111"></a>00111 <span class="stringliteral">            %&#39;</span>hollidayJunctions3<span class="stringliteral">&#39;</span>
<a name="l00112"></a>00112 <span class="stringliteral">            %&#39;</span>hollidayJunctions5<span class="stringliteral">&#39;</span>
<a name="l00113"></a>00113 <span class="stringliteral">            %&#39;</span>singleStrandBreaks<span class="stringliteral">&#39;</span>
<a name="l00114"></a>00114 <span class="stringliteral">            %&#39;</span>doubleStrandBreaks<span class="stringliteral">&#39;</span>
<a name="l00115"></a>00115 <span class="stringliteral">            %&#39;</span>strandBreakClassification<span class="stringliteral">&#39;</span>
<a name="l00116"></a>00116 <span class="stringliteral">            %&#39;</span>restrictableMunIRMSites<span class="stringliteral">&#39;</span>
<a name="l00117"></a>00117 <span class="stringliteral">            %&#39;</span>hemiunmethylatedMunIRMSites<span class="stringliteral">&#39;</span>
<a name="l00118"></a>00118 <span class="stringliteral">            };</span>
<a name="l00119"></a>00119 <span class="stringliteral">        </span>
<a name="l00120"></a>00120 <span class="stringliteral">        nCompartments = 4;              %number of strands</span>
<a name="l00121"></a>00121 <span class="stringliteral">        nChromosomes = 2;               %number of chromosomes</span>
<a name="l00122"></a>00122 <span class="stringliteral">        </span>
<a name="l00123"></a>00123 <span class="stringliteral">        strandIndexs_positive    = [1; 3]; %5&#39;</span>-&gt;3<span class="stringliteral">&#39; strands</span>
<a name="l00124"></a>00124 <span class="stringliteral">        strandIndexs_negative    = [2; 4]; %3&#39;</span>-&gt;5<span class="stringliteral">&#39; strands</span>
<a name="l00125"></a>00125 <span class="stringliteral">        </span>
<a name="l00126"></a>00126 <span class="stringliteral">        strandIndexs_ch1         = [1; 2]; %chromosome 1 strands; sort to &quot;mother&quot; cell during division</span>
<a name="l00127"></a>00127 <span class="stringliteral">        strandIndexs_ch2         = [3; 4]; %chromosome 2 strands; sort to &quot;daughter&quot; cell during division</span>
<a name="l00128"></a>00128 <span class="stringliteral">        </span>
<a name="l00129"></a>00129 <span class="stringliteral">        strandIndexs_template    = [1; 4]; %strands which are serving as templates for replication</span>
<a name="l00130"></a>00130 <span class="stringliteral">        strandIndexs_nonTemplate = [2; 3]; %strands which are not serving as templates for replication</span>
<a name="l00131"></a>00131 <span class="stringliteral">        </span>
<a name="l00132"></a>00132 <span class="stringliteral">        strandIndexs_old         = [1; 4]; %strands which (at end the end of the cell cycle) were present at the beginning of the cell cycle</span>
<a name="l00133"></a>00133 <span class="stringliteral">        strandIndexs_new         = [2; 3]; %strands which (at end the end of the cell cycle) were synthesized during the cell cycle</span>
<a name="l00134"></a>00134 <span class="stringliteral">        </span>
<a name="l00135"></a>00135 <span class="stringliteral">        dnaStrandedness_ssDNA = 1; %values of ssDNA footprints within *DNAFootprintStrandedness</span>
<a name="l00136"></a>00136 <span class="stringliteral">        dnaStrandedness_dsDNA = 2; %values of dsDNA footprints within *DNAFootprintStrandedness</span>
<a name="l00137"></a>00137 <span class="stringliteral">        dnaStrandedness_xsDNA = 3; %values of ssDNA/dsDNA footprints within *DNAFootprintStrandedness</span>
<a name="l00138"></a>00138 <span class="stringliteral">        </span>
<a name="l00139"></a>00139 <span class="stringliteral">        strandBreakClassification_index_NB    = 1; %index within strandBreakClassification of NB</span>
<a name="l00140"></a>00140 <span class="stringliteral">        strandBreakClassification_index_SSB   = 2; %index within strandBreakClassification of SSB</span>
<a name="l00141"></a>00141 <span class="stringliteral">        strandBreakClassification_index_SSB_  = 3; %index within strandBreakClassification of SSB+</span>
<a name="l00142"></a>00142 <span class="stringliteral">        strandBreakClassification_index_2SSB  = 4; %index within strandBreakClassification of 2SSB</span>
<a name="l00143"></a>00143 <span class="stringliteral">        strandBreakClassification_index_DSB   = 5; %index within strandBreakClassification of DSB</span>
<a name="l00144"></a>00144 <span class="stringliteral">        strandBreakClassification_index_DSB_  = 6; %index within strandBreakClassification of DSB+</span>
<a name="l00145"></a>00145 <span class="stringliteral">        strandBreakClassification_index_DSB__ = 7; %index within strandBreakClassification of DSB++</span>
<a name="l00146"></a>00146 <span class="stringliteral">    end</span>
<a name="l00147"></a>00147 <span class="stringliteral">    </span>
<a name="l00148"></a>00148 <span class="stringliteral">    %computed ids, names, indices</span>
<a name="l00149"></a>00149 <span class="stringliteral">    properties</span>
<a name="l00150"></a>00150 <span class="stringliteral">        transcriptionUnitWholeCellModelIDs     %whole cell model IDs of transcription units</span>
<a name="l00151"></a>00151 <span class="stringliteral">        transcriptionUnitNames                 %names of transcription units</span>
<a name="l00152"></a>00152 <span class="stringliteral">        </span>
<a name="l00153"></a>00153 <span class="stringliteral">        monomerIndexs_ligase                   %index within ProteinMonomer.matureIndexs of DNA ligase</span>
<a name="l00154"></a>00154 <span class="stringliteral">        complexIndexs_dnaPolymerase            %index within ProteinComplex.matureIndexs of DNA polymerase</span>
<a name="l00155"></a>00155 <span class="stringliteral">        complexIndexs_DisA                     %index within ProteinComplex.matureIndexs of DisA</span>
<a name="l00156"></a>00156 <span class="stringliteral">        complexIndexs_rnaPolymerase            %index within ProteinComplex.matureIndexs of RNA polymerase</span>
<a name="l00157"></a>00157 <span class="stringliteral">        monomerIndexs_replisome                %index within ProteinMonomer.matureIndexs of replication machinery</span>
<a name="l00158"></a>00158 <span class="stringliteral">        complexIndexs_replisome                %index within ProteinComplex.matureIndexs of replication machinery</span>
<a name="l00159"></a>00159 <span class="stringliteral">        </span>
<a name="l00160"></a>00160 <span class="stringliteral">        reactionWholeCellModelIDs              %IDs of bound protein release reactions</span>
<a name="l00161"></a>00161 <span class="stringliteral">        reactionNames                          %names of bound protein release reactions</span>
<a name="l00162"></a>00162 <span class="stringliteral">    end</span>
<a name="l00163"></a>00163 <span class="stringliteral">    </span>
<a name="l00164"></a>00164 <span class="stringliteral">    %constants</span>
<a name="l00165"></a>00165 <span class="stringliteral">    properties</span>
<a name="l00166"></a>00166 <span class="stringliteral">        doubleStrandBreakSeparation                           = 1;   %max separtion in bases between SSB&#39;</span>s to be consider a DBSB
<a name="l00167"></a>00167         strandBreakClassification_doubleStrandBreakSeparation = 10;  %maximum separation of single strand breaks which is considered <span class="keywordtype">double</span> strand <span class="keywordflow">break</span> [PUB_0486]
<a name="l00168"></a>00168         strandBreakClassification_segmentLength               = 216; %length of segments <span class="keywordflow">for</span> which SSB/SSB+/2SSB/DSB/DSB+/DSB++ classification applies [PUB_0486]        
<a name="l00169"></a>00169         
<a name="l00170"></a>00170         sequence                                %chromosome sequence
<a name="l00171"></a>00171         sequenceLen                             %chromosome sequence length (number of bases)
<a name="l00172"></a>00172         sequenceGCContent                       %chromosome G/C content
<a name="l00173"></a>00173         oriCPosition                            %oriC position
<a name="l00174"></a>00174         terCPosition                            %terC position
<a name="l00175"></a>00175         
<a name="l00176"></a>00176         transcriptionUnitStartCoordinates       %genomic coordinates of transcription units
<a name="l00177"></a>00177         transcriptionUnitLengths                %genomic coordinates of transcription units
<a name="l00178"></a>00178         transcriptionUnitStrands                %genomic direction of transcription units
<a name="l00179"></a>00179         
<a name="l00180"></a>00180         monomerDNAFootprints                    %number of bases of DNA each monomer occupies when bound to DNA
<a name="l00181"></a>00181         complexDNAFootprints                    %number of bases of DNA each complex occupies when bound to DNA
<a name="l00182"></a>00182         monomerDNAFootprintBindingStrandedness  %enumeration of binding strandedness of DNA footprints (<a class="code" href="classss_d_n_a.html">ssDNA</a>, <a class="code" href="classds_d_n_a.html">dsDNA</a>, <a class="code" href="classss_d_n_a.html">ssDNA</a>/<a class="code" href="classds_d_n_a.html">dsDNA</a>) using this.dnaStrandedness_*sDNA
<a name="l00183"></a>00183         complexDNAFootprintBindingStrandedness  %enumeration of binding strandedness of DNA footprints (<a class="code" href="classss_d_n_a.html">ssDNA</a>, <a class="code" href="classds_d_n_a.html">dsDNA</a>, <a class="code" href="classss_d_n_a.html">ssDNA</a>/<a class="code" href="classds_d_n_a.html">dsDNA</a>) using this.dnaStrandedness_*sDNA
<a name="l00184"></a>00184         monomerDNAFootprintRegionStrandedness   %enumeration of region strandedness of DNA footprints (<a class="code" href="classss_d_n_a.html">ssDNA</a>, <a class="code" href="classds_d_n_a.html">dsDNA</a>, <a class="code" href="classss_d_n_a.html">ssDNA</a>/<a class="code" href="classds_d_n_a.html">dsDNA</a>) using this.dnaStrandedness_*sDNA
<a name="l00185"></a>00185         complexDNAFootprintRegionStrandedness   %enumeration of region strandedness of DNA footprints (<a class="code" href="classss_d_n_a.html">ssDNA</a>, <a class="code" href="classds_d_n_a.html">dsDNA</a>, <a class="code" href="classss_d_n_a.html">ssDNA</a>/<a class="code" href="classds_d_n_a.html">dsDNA</a>) using this.dnaStrandedness_*sDNA
<a name="l00186"></a>00186         
<a name="l00187"></a>00187         reactionBoundMonomer                    %protein monomer released by each reaction [reactions X 1]
<a name="l00188"></a>00188         reactionBoundComplex                    %protein complex released by each reaction [reactions X 1]
<a name="l00189"></a>00189         reactionMonomerCatalysisMatrix          %monomers required to catalyze the release of a bound protein [reactions X monomers]
<a name="l00190"></a>00190         reactionComplexCatalysisMatrix          %complexs required to catalyze the release of a bound protein [reactions X complexs]
<a name="l00191"></a>00191         reactionThresholds                      %number of proteins required to catalyze each release reaction [reactions X 1]
<a name="l00192"></a>00192         
<a name="l00193"></a>00193         relaxedBasesPerTurn                     %Number of dna bases per turn for the relaxed LK calculation (10.5)
<a name="l00194"></a>00194         equilibriumSuperhelicalDensity          %equilibrium superhelical density; also known as specific linking difference / \sigma_{sp} [-0.06; PUB_0749]
<a name="l00195"></a>00195         supercoiledSuperhelicalDensityTolerance %tolerance in superhelical density to be considered supercoiled (0.1)
<a name="l00196"></a>00196     end
<a name="l00197"></a>00197     
<a name="l00198"></a>00198     %state
<a name="l00199"></a>00199     <a class="code" href="json_parse_8m.html#a6e4256f69b751d3d7ec4ea52ff5a8dee">properties</a>
<a name="l00200"></a>00200         polymerizedRegions       %integers [positions x strands] indicating the start positions of polymerized regions of strands and their lengths
<a name="l00201"></a>00201         linkingNumbers           %integers [positions x strands] indicating the current linking number of each <span class="keywordtype">double</span>-stranded region
<a name="l00202"></a>00202         
<a name="l00203"></a>00203         monomerBoundSites        %indices [positions x strands] indicating start positions of protein monomers bound to DNA bases
<a name="l00204"></a>00204         complexBoundSites        %indices [positions x strands] indicating start positions of macromolecular complexes bound to DNA bases
<a name="l00205"></a>00205         
<a name="l00206"></a>00206         gapSites                 %<span class="keywordtype">boolean</span> [positions x strands] indicating positions of gap sites
<a name="l00207"></a>00207         abasicSites              %<span class="keywordtype">boolean</span> [positions x strands] indicating positions of abasic sites
<a name="l00208"></a>00208         damagedSugarPhosphates   %indices [positions x strands] indicating metabolite identity of damaged sugar-phosphates
<a name="l00209"></a>00209         damagedBases             %indices [positions x strands] indicating metabolite identity of damaged bases
<a name="l00210"></a>00210         intrastrandCrossLinks    %<span class="keywordtype">boolean</span> [positions x strands] indicating metabolite identity of intrastrand cross links in DNA
<a name="l00211"></a>00211         strandBreaks             %<span class="keywordtype">boolean</span> [positions x strands] indicating positions of strand breaks in strands of DNA
<a name="l00212"></a>00212         hollidayJunctions        %<span class="keywordtype">boolean</span> [positions x strands] indicating positions of holliday junctions
<a name="l00213"></a>00213         
<a name="l00214"></a>00214         segregated               %<span class="keywordtype">boolean</span> indicating whether or not the chromsomes are segregated
<a name="l00215"></a>00215     end
<a name="l00216"></a>00216     
<a name="l00217"></a>00217     %<a class="code" href="json_parse_8m.html#a6e4256f69b751d3d7ec4ea52ff5a8dee">properties</a> to keep track of whether or not the dependent <a class="code" href="json_parse_8m.html#a6e4256f69b751d3d7ec4ea52ff5a8dee">properties</a> need to
<a name="l00218"></a>00218     %be recomputed
<a name="l00219"></a>00219     <a class="code" href="json_parse_8m.html#a6e4256f69b751d3d7ec4ea52ff5a8dee">properties</a> (SetAccess = protected)
<a name="l00220"></a>00220         validated
<a name="l00221"></a>00221         
<a name="l00222"></a>00222         validated_polymerizedRegions
<a name="l00223"></a>00223         validated_linkingNumbers
<a name="l00224"></a>00224         validated_proteinBoundSites
<a name="l00225"></a>00225         validated_damaged
<a name="l00226"></a>00226         validated_gapSites
<a name="l00227"></a>00227         validated_abasicSites
<a name="l00228"></a>00228         validated_damagedSugarPhosphates
<a name="l00229"></a>00229         validated_damagedBases
<a name="l00230"></a>00230         validated_intrastrandCrossLinks
<a name="l00231"></a>00231         validated_strandBreaks
<a name="l00232"></a>00232         validated_hollidayJunctions
<a name="l00233"></a>00233         validated_segregated
<a name="l00234"></a>00234         
<a name="l00235"></a>00235         validated_unpolymerizedRegions
<a name="l00236"></a>00236         validated_singleStrandedRegions
<a name="l00237"></a>00237         validated_doubleStrandedRegions
<a name="l00238"></a>00238         validated_geneCopyNumbers
<a name="l00239"></a>00239         validated_ploidy
<a name="l00240"></a>00240         validated_polymerizedGenes
<a name="l00241"></a>00241         validated_transcriptionUnitCopyNumbers
<a name="l00242"></a>00242         validated_polymerizedTranscriptionUnits
<a name="l00243"></a>00243         validated_geneCopyNumbers_Accessible
<a name="l00244"></a>00244         validated_transcriptionUnitCopyNumbers_Accessible
<a name="l00245"></a>00245         validated_accessibleGenes
<a name="l00246"></a>00246         validated_accessibleTranscriptionUnits
<a name="l00247"></a>00247         validated_linkingNumbers_minFreeEnergy
<a name="l00248"></a>00248         validated_supercoils
<a name="l00249"></a>00249         validated_superhelicalDensity
<a name="l00250"></a>00250         validated_supercoiled
<a name="l00251"></a>00251         validated_damagedSites
<a name="l00252"></a>00252         validated_damagedSites_shifted_incm6AD
<a name="l00253"></a>00253         validated_damagedSites_nonRedundant
<a name="l00254"></a>00254         validated_damagedSites_excm6AD
<a name="l00255"></a>00255         validated_gapSites3
<a name="l00256"></a>00256         validated_gapSites5
<a name="l00257"></a>00257         validated_abasicSites3
<a name="l00258"></a>00258         validated_abasicSites5
<a name="l00259"></a>00259         validated_damagedSugarPhosphates3
<a name="l00260"></a>00260         validated_damagedSugarPhosphates5
<a name="l00261"></a>00261         validated_damagedBases3
<a name="l00262"></a>00262         validated_damagedBases5
<a name="l00263"></a>00263         validated_strandBreaks3
<a name="l00264"></a>00264         validated_strandBreaks5
<a name="l00265"></a>00265         validated_intrastrandCrossLinks3
<a name="l00266"></a>00266         validated_intrastrandCrossLinks5
<a name="l00267"></a>00267         validated_hollidayJunctions3
<a name="l00268"></a>00268         validated_hollidayJunctions5
<a name="l00269"></a>00269         validated_singleStrandBreaks
<a name="l00270"></a>00270         validated_doubleStrandBreaks
<a name="l00271"></a>00271         validated_strandBreakClassification
<a name="l00272"></a>00272         validated_munIRMSiteMethylationStatus
<a name="l00273"></a>00273         validated_munIRMSiteRestrictionStatus
<a name="l00274"></a>00274         validated_dryWeight
<a name="l00275"></a>00275     end
<a name="l00276"></a>00276     
<a name="l00277"></a>00277     %dependent local state (implemented as dependent property for convenience)
<a name="l00278"></a>00278     <a class="code" href="json_parse_8m.html#a6e4256f69b751d3d7ec4ea52ff5a8dee">properties</a> (SetAccess = protected)
<a name="l00279"></a>00279         unpolymerizedRegions         %integers indicating the start positions of unpolymerized regions (ie. not yet replicated) of strands and their lengths
<a name="l00280"></a>00280         singleStrandedRegions
<a name="l00281"></a>00281         doubleStrandedRegions
<a name="l00282"></a>00282         geneCopyNumbers
<a name="l00283"></a>00283         polymerizedGenes
<a name="l00284"></a>00284         transcriptionUnitCopyNumbers
<a name="l00285"></a>00285         polymerizedTranscriptionUnits
<a name="l00286"></a>00286         geneCopyNumbers_Accessible
<a name="l00287"></a>00287         transcriptionUnitCopyNumbers_Accessible
<a name="l00288"></a>00288         accessibleGenes
<a name="l00289"></a>00289         accessibleTranscriptionUnits
<a name="l00290"></a>00290         ploidy
<a name="l00291"></a>00291         
<a name="l00292"></a>00292         linkingNumbers_minFreeEnergy %free energy mininum linking number
<a name="l00293"></a>00293         supercoils                   %difference between linkingNumbers and free energy mininum linking number
<a name="l00294"></a>00294         superhelicalDensity          %supercoils / free energy minimum linking number
<a name="l00295"></a>00295         supercoiled                  %<span class="keywordtype">boolean</span> (1 x 2) indicating whether or not each chromosome is properly supercoiled (eg. within some tolerance of the free energy minimum)
<a name="l00296"></a>00296         
<a name="l00297"></a>00297         damagedSites                 %integers (genome length x 4) indicating identities of bases which are damaged or which are adjacent to damaged bonds
<a name="l00298"></a>00298         damagedSites_shifted_incm6AD %integers (genome length x 4) indicating identities of damaged bases/sites
<a name="l00299"></a>00299         damagedSites_nonRedundant    %integers (genome length x 4) indicating identities of damaged bases/sites
<a name="l00300"></a>00300         damagedSites_excm6AD         %integers (genome length x 4) indicating identities of damaged bases/sites
<a name="l00301"></a>00301         gapSites3                    %<span class="keywordtype">boolean</span> (genome length x 4) indicating positions of gap sites 3&#39; to bases
<a name="l00302"></a>00302         gapSites5                    %<span class="keywordtype">boolean</span> (genome length x 4) indicating positions of gap sites 5&#39; to bases
<a name="l00303"></a>00303         abasicSites3                 %<span class="keywordtype">boolean</span> (genome length x 4) indicating positions of abasic sites 3&#39; to bases
<a name="l00304"></a>00304         abasicSites5                 %<span class="keywordtype">boolean</span> (genome length x 4) indicating positions of abasic sites 5&#39; to bases
<a name="l00305"></a>00305         damagedSugarPhosphates3      %integers (genome length x 4) indicating indices of damaged sugar-phosphate 3&#39; to bases
<a name="l00306"></a>00306         damagedSugarPhosphates5      %integers (genome length x 4) indicating indices of damaged sugar-phosphate 5&#39; to bases
<a name="l00307"></a>00307         damagedBases3                %integers (genome length x 4) indicating indices of damaged bases 3&#39; to bases
<a name="l00308"></a>00308         damagedBases5                %integers (genome length x 4) indicating indices of damaged bases 5&#39; to bases
<a name="l00309"></a>00309         strandBreaks3                %<span class="keywordtype">boolean</span> (genome length x 4) indicating positions of strand breaks 3&#39; to bases
<a name="l00310"></a>00310         strandBreaks5                %<span class="keywordtype">boolean</span> (genome length x 4) indicating positions of strand breaks 5&#39; to bases
<a name="l00311"></a>00311         intrastrandCrossLinks3       %<span class="keywordtype">boolean</span> (genome length x 4) indicating positions of intrastrand cross links 3&#39; to bases
<a name="l00312"></a>00312         intrastrandCrossLinks5       %<span class="keywordtype">boolean</span> (genome length x 4) indicating positions of intrastrand cross links 5&#39; to bases
<a name="l00313"></a>00313         hollidayJunctions3           %<span class="keywordtype">boolean</span> (genome length x 4) indicating positions of holliday junctions 3&#39; to bases
<a name="l00314"></a>00314         hollidayJunctions5           %<span class="keywordtype">boolean</span> (genome length x 4) indicating positions of holliday junctions 5&#39; to bases
<a name="l00315"></a>00315         
<a name="l00316"></a>00316         singleStrandBreaks           %<span class="keywordtype">boolean</span> (genome length x 4) indicating positions of single strand breaks (strand breaks excluding <span class="keywordtype">double</span> strand breaks and strand breaks adjacent to gapSites)
<a name="l00317"></a>00317         doubleStrandBreaks           %<span class="keywordtype">boolean</span> (genome length x 4) indicating positions of <span class="keywordtype">double</span> strand breaks        
<a name="l00318"></a>00318         strandBreakClassification
<a name="l00319"></a>00319         
<a name="l00320"></a>00320         restrictableMunIRMSites      %<span class="keywordtype">boolean</span> (genome length x 4) indicating positions of restrictable MunI R/M sites because they aren&#39;t methylated
<a name="l00321"></a>00321         hemiunmethylatedMunIRMSites  %<span class="keywordtype">boolean</span> (genome length x 4) indicating positions of hemi-unmethylated MunI R/M sites
<a name="l00322"></a>00322         
<a name="l00323"></a>00323         dryWeight                    %dry weight of this class&#39; state <a class="code" href="json_parse_8m.html#a6e4256f69b751d3d7ec4ea52ff5a8dee">properties</a>
<a name="l00324"></a>00324     end
<a name="l00325"></a>00325     
<a name="l00326"></a>00326     %references to objects
<a name="l00327"></a>00327     <a class="code" href="json_parse_8m.html#a6e4256f69b751d3d7ec4ea52ff5a8dee">properties</a>
<a name="l00328"></a>00328         compartment   %compartments
<a name="l00329"></a>00329         gene          %genes
<a name="l00330"></a>00330         
<a name="l00331"></a>00331         metabolite    %metabolites
<a name="l00332"></a>00332         transcript    %transcript
<a name="l00333"></a>00333         rnaPolymerase %<a class="code" href="class_r_n_a.html">RNA</a> polymerase
<a name="l00334"></a>00334         
<a name="l00335"></a>00335         dnaRepair     %DNA repair process
<a name="l00336"></a>00336     end
<a name="l00337"></a>00337     
<a name="l00338"></a>00338     %constructor
<a name="l00339"></a>00339     methods
<a name="l00340"></a>00340         function this = <a class="code" href="class_chromosome.html">Chromosome</a>(wholeCellModelID, name)
<a name="l00341"></a>00341             this = this@edu.stanford.covert.cell.sim.<a class="code" href="class_cell_state.html">CellState</a>(wholeCellModelID, name);
<a name="l00342"></a>00342         end
<a name="l00343"></a>00343     end
<a name="l00344"></a>00344     
<a name="l00345"></a>00345     methods
<a name="l00346"></a>00346         function storeObjectReferences(this, simulation)
<a name="l00347"></a>00347             this.compartment = simulation.compartment;
<a name="l00348"></a>00348             this.gene = simulation.gene;
<a name="l00349"></a>00349             this.metabolite = simulation.state(&#39;<a class="code" href="class_metabolite.html">Metabolite</a>&#39;);
<a name="l00350"></a>00350             this.transcript = simulation.state(&#39;Transcript&#39;);
<a name="l00351"></a>00351             this.rnaPolymerase = simulation.state(&#39;RNAPolymerase&#39;);
<a name="l00352"></a>00352             this.dnaRepair = simulation.process(&#39;DNARepair&#39;);
<a name="l00353"></a>00353         end
<a name="l00354"></a>00354     end
<a name="l00355"></a>00355     
<a name="l00356"></a>00356     methods
<a name="l00357"></a>00357         function initializeConstants(this, knowledgeBase, simulation)
<a name="l00358"></a>00358             this.initializeConstants@edu.stanford.covert.cell.sim.<a class="code" href="class_cell_state.html">CellState</a>(knowledgeBase, simulation);
<a name="l00359"></a>00359             
<a name="l00360"></a>00360             %% import classes
<a name="l00361"></a>00361             import edu.stanford.covert.cell.sim.constant.<a class="code" href="class_chromosome_sequence.html">ChromosomeSequence</a>;
<a name="l00362"></a>00362             
<a name="l00363"></a>00363             %% sequence
<a name="l00364"></a>00364             this.sequence = ChromosomeSequence(knowledgeBase.genome.sequence);
<a name="l00365"></a>00365             this.sequenceLen = size(this.sequence, 1);
<a name="l00366"></a>00366             this.sequenceGCContent = getGCContent(this.sequence);
<a name="l00367"></a>00367             oriC = findobj(knowledgeBase.genomeFeatures, &#39;wholeCellModelID&#39;, &#39;oriC&#39;);
<a name="l00368"></a>00368             terC = findobj(knowledgeBase.genomeFeatures, &#39;wholeCellModelID&#39;, &#39;terC&#39;);
<a name="l00369"></a>00369             this.oriCPosition = oriC.startCoordinate;
<a name="l00370"></a>00370             this.terCPosition = terC.startCoordinate;
<a name="l00371"></a>00371             
<a name="l00372"></a>00372             %Ensure that relaxedBasesPerTurn is defined such that the relaxed
<a name="l00373"></a>00373             %linking number will be a whole number for this organism.
<a name="l00374"></a>00374             this.relaxedBasesPerTurn = length(this.sequence) * (1 + this.equilibriumSuperhelicalDensity) / ...
<a name="l00375"></a>00375                 ceil(length(this.sequence) / this.relaxedBasesPerTurn * (1 + this.equilibriumSuperhelicalDensity));
<a name="l00376"></a>00376             
<a name="l00377"></a>00377             %% transcription units
<a name="l00378"></a>00378             this.transcriptionUnitWholeCellModelIDs = {knowledgeBase.transcriptionUnits.wholeCellModelID}<span class="stringliteral">&#39;;</span>
<a name="l00379"></a>00379 <span class="stringliteral">            this.transcriptionUnitNames             = {knowledgeBase.transcriptionUnits.name}&#39;</span>;
<a name="l00380"></a>00380             this.transcriptionUnitStartCoordinates  = [knowledgeBase.transcriptionUnits.startCoordinate]<span class="stringliteral">&#39;;</span>
<a name="l00381"></a>00381 <span class="stringliteral">            this.transcriptionUnitLengths           = [knowledgeBase.transcriptionUnits.sequenceLength]&#39;</span>;
<a name="l00382"></a>00382             this.transcriptionUnitStrands           = 2-[knowledgeBase.transcriptionUnits.direction]&#39;;
<a name="l00383"></a>00383             
<a name="l00384"></a>00384             %% proteins
<a name="l00385"></a>00385             this.monomerIndexs_ligase        = simulation.state(<span class="stringliteral">&#39;ProteinMonomer&#39;</span>).getIndexs({<span class="stringliteral">&#39;MG_254_MONOMER&#39;</span>});
<a name="l00386"></a>00386             this.complexIndexs_dnaPolymerase = simulation.state(<span class="stringliteral">&#39;ProteinComplex&#39;</span>).getIndexs({<span class="stringliteral">&#39;DNA_POLYMERASE_CORE&#39;</span>});
<a name="l00387"></a>00387             this.complexIndexs_DisA          = simulation.state(<span class="stringliteral">&#39;ProteinComplex&#39;</span>).getIndexs({<span class="stringliteral">&#39;MG_105_OCTAMER&#39;</span>});
<a name="l00388"></a>00388             this.complexIndexs_rnaPolymerase = sort(simulation.state(<span class="stringliteral">&#39;ProteinComplex&#39;</span>).getIndexs({<span class="stringliteral">&#39;RNA_POLYMERASE&#39;</span>; <span class="stringliteral">&#39;RNA_POLYMERASE_HOLOENZYME&#39;</span>}));
<a name="l00389"></a>00389             this.monomerIndexs_replisome     = zeros(0, 1);
<a name="l00390"></a>00390             this.complexIndexs_replisome     = sort(simulation.state(<span class="stringliteral">&#39;ProteinComplex&#39;</span>).getIndexs({
<a name="l00391"></a>00391                 <span class="stringliteral">&#39;DNA_POLYMERASE_2CORE_BETA_CLAMP_GAMMA_COMPLEX_PRIMASE&#39;</span>
<a name="l00392"></a>00392                 <span class="stringliteral">&#39;DNA_POLYMERASE_CORE_BETA_CLAMP_GAMMA_COMPLEX&#39;</span>
<a name="l00393"></a>00393                 <span class="stringliteral">&#39;DNA_POLYMERASE_CORE_BETA_CLAMP_PRIMASE&#39;</span>
<a name="l00394"></a>00394                 <span class="stringliteral">&#39;MG_001_DIMER&#39;</span>
<a name="l00395"></a>00395                 <span class="stringliteral">&#39;MG_094_HEXAMER&#39;</span>
<a name="l00396"></a>00396                 }));
<a name="l00397"></a>00397             
<a name="l00398"></a>00398             this.monomerDNAFootprints = ceil([knowledgeBase.proteinMonomers.dnaFootprint]<span class="stringliteral">&#39;);</span>
<a name="l00399"></a>00399 <span class="stringliteral">            this.complexDNAFootprints = ceil([knowledgeBase.proteinComplexs.dnaFootprint]&#39;</span>);
<a name="l00400"></a>00400             
<a name="l00401"></a>00401             strandedValues = cell(3, 1);
<a name="l00402"></a>00402             strandedValues{this.dnaStrandedness_ssDNA} = <span class="stringliteral">&#39;ssDNA&#39;</span>;
<a name="l00403"></a>00403             strandedValues{this.dnaStrandedness_dsDNA} = <span class="stringliteral">&#39;dsDNA&#39;</span>;
<a name="l00404"></a>00404             strandedValues{this.dnaStrandedness_xsDNA} = <span class="stringliteral">&#39;Either&#39;</span>;
<a name="l00405"></a>00405             
<a name="l00406"></a>00406             monomerStrandedness = {knowledgeBase.proteinMonomers.dnaFootprintBindingStrandedness}<span class="stringliteral">&#39;;</span>
<a name="l00407"></a>00407 <span class="stringliteral">            complexStrandedness = {knowledgeBase.proteinComplexs.dnaFootprintBindingStrandedness}&#39;</span>;
<a name="l00408"></a>00408             monomerStrandedness(cellfun(@isempty, monomerStrandedness)) = {<span class="stringliteral">&#39;dsDNA&#39;</span>};
<a name="l00409"></a>00409             complexStrandedness(cellfun(@isempty, complexStrandedness)) = {<span class="stringliteral">&#39;dsDNA&#39;</span>};
<a name="l00410"></a>00410             [~, this.monomerDNAFootprintBindingStrandedness] = ismember(monomerStrandedness, strandedValues);
<a name="l00411"></a>00411             [~, this.complexDNAFootprintBindingStrandedness] = ismember(complexStrandedness, strandedValues);
<a name="l00412"></a>00412             
<a name="l00413"></a>00413             monomerStrandedness = {knowledgeBase.proteinMonomers.dnaFootprintRegionStrandedness}<span class="stringliteral">&#39;;</span>
<a name="l00414"></a>00414 <span class="stringliteral">            complexStrandedness = {knowledgeBase.proteinComplexs.dnaFootprintRegionStrandedness}&#39;</span>;
<a name="l00415"></a>00415             monomerStrandedness(cellfun(@isempty, monomerStrandedness)) = {<span class="stringliteral">&#39;dsDNA&#39;</span>};
<a name="l00416"></a>00416             complexStrandedness(cellfun(@isempty, complexStrandedness)) = {<span class="stringliteral">&#39;dsDNA&#39;</span>};
<a name="l00417"></a>00417             [~, this.monomerDNAFootprintRegionStrandedness] = ismember(monomerStrandedness, strandedValues);
<a name="l00418"></a>00418             [~, this.complexDNAFootprintRegionStrandedness] = ismember(complexStrandedness, strandedValues);
<a name="l00419"></a>00419             
<a name="l00420"></a>00420             %% proteins which have ability to release other proteins bound to chromosomes
<a name="l00421"></a>00421             state = findobj(knowledgeBase.states, <span class="stringliteral">&#39;wholeCellModelID&#39;</span>, <span class="keyword">this</span>.wholeCellModelID);
<a name="l00422"></a>00422             reactions = state.reactions;
<a name="l00423"></a>00423             reactionGlobalIndexs = [reactions.idx]<span class="stringliteral">&#39;;</span>
<a name="l00424"></a>00424 <span class="stringliteral">            this.reactionWholeCellModelIDs = {reactions.wholeCellModelID}&#39;</span>;
<a name="l00425"></a>00425             this.reactionNames = {reactions.name}<span class="stringliteral">&#39;;</span>
<a name="l00426"></a>00426 <span class="stringliteral">            </span>
<a name="l00427"></a>00427 <span class="stringliteral">            this.reactionBoundMonomer = zeros(size(reactions));</span>
<a name="l00428"></a>00428 <span class="stringliteral">            this.reactionBoundComplex = zeros(size(reactions));</span>
<a name="l00429"></a>00429 <span class="stringliteral">            [i, j] = find(max(0, knowledgeBase.reactionProteinMonomerStoichiometryMatrix(:, reactionGlobalIndexs, this.compartment.cytosolIndexs)));</span>
<a name="l00430"></a>00430 <span class="stringliteral">            this.reactionBoundMonomer(j) = i;</span>
<a name="l00431"></a>00431 <span class="stringliteral">            [i, j] = find(max(0, knowledgeBase.reactionProteinComplexStoichiometryMatrix(:, reactionGlobalIndexs, this.compartment.cytosolIndexs)));</span>
<a name="l00432"></a>00432 <span class="stringliteral">            this.reactionBoundComplex(j) = i;</span>
<a name="l00433"></a>00433 <span class="stringliteral">            </span>
<a name="l00434"></a>00434 <span class="stringliteral">            this.reactionMonomerCatalysisMatrix = max(0, -knowledgeBase.reactionProteinMonomerStoichiometryMatrix(:, reactionGlobalIndexs, this.compartment.cytosolIndexs)&#39;</span>);
<a name="l00435"></a>00435             this.reactionComplexCatalysisMatrix = max(0, -knowledgeBase.reactionProteinComplexStoichiometryMatrix(:, reactionGlobalIndexs, <span class="keyword">this</span>.compartment.cytosolIndexs)<span class="stringliteral">&#39;);</span>
<a name="l00436"></a>00436 <span class="stringliteral">            </span>
<a name="l00437"></a>00437 <span class="stringliteral">            this.reactionThresholds = ...</span>
<a name="l00438"></a>00438 <span class="stringliteral">                sum(this.reactionMonomerCatalysisMatrix, 2) + ...</span>
<a name="l00439"></a>00439 <span class="stringliteral">                sum(this.reactionComplexCatalysisMatrix, 2);</span>
<a name="l00440"></a>00440 <span class="stringliteral">        end</span>
<a name="l00441"></a>00441 <span class="stringliteral">    end</span>
<a name="l00442"></a>00442 <span class="stringliteral">    </span>
<a name="l00443"></a>00443 <span class="stringliteral">    methods</span>
<a name="l00444"></a>00444 <span class="stringliteral">        %allocate memory</span>
<a name="l00445"></a>00445 <span class="stringliteral">        function allocateMemory(this, numTimePoints)</span>
<a name="l00446"></a>00446 <span class="stringliteral">            import edu.stanford.covert.util.CircularSparseMat;</span>
<a name="l00447"></a>00447 <span class="stringliteral">            </span>
<a name="l00448"></a>00448 <span class="stringliteral">            this.polymerizedRegions       = CircularSparseMat([], [], [this.sequenceLen, this.nCompartments, numTimePoints], 1);</span>
<a name="l00449"></a>00449 <span class="stringliteral">            this.linkingNumbers           = CircularSparseMat([], [], [this.sequenceLen, this.nCompartments, numTimePoints], 1);</span>
<a name="l00450"></a>00450 <span class="stringliteral"></span>
<a name="l00451"></a>00451 <span class="stringliteral">            this.monomerBoundSites        = CircularSparseMat([], [], [this.sequenceLen, this.nCompartments, numTimePoints], 1);</span>
<a name="l00452"></a>00452 <span class="stringliteral">            this.complexBoundSites        = CircularSparseMat([], [], [this.sequenceLen, this.nCompartments, numTimePoints], 1);</span>
<a name="l00453"></a>00453 <span class="stringliteral">            </span>
<a name="l00454"></a>00454 <span class="stringliteral">            this.gapSites                 = CircularSparseMat([], false(0,1), [this.sequenceLen, this.nCompartments, numTimePoints], 1);</span>
<a name="l00455"></a>00455 <span class="stringliteral">            this.abasicSites              = CircularSparseMat([], false(0,1), [this.sequenceLen, this.nCompartments, numTimePoints], 1);</span>
<a name="l00456"></a>00456 <span class="stringliteral">            this.damagedSugarPhosphates   = CircularSparseMat([], [],         [this.sequenceLen, this.nCompartments, numTimePoints], 1);</span>
<a name="l00457"></a>00457 <span class="stringliteral">            this.damagedBases             = CircularSparseMat([], [],         [this.sequenceLen, this.nCompartments, numTimePoints], 1);</span>
<a name="l00458"></a>00458 <span class="stringliteral">            this.intrastrandCrossLinks    = CircularSparseMat([], [],         [this.sequenceLen, this.nCompartments, numTimePoints], 1);</span>
<a name="l00459"></a>00459 <span class="stringliteral">            this.strandBreaks             = CircularSparseMat([], false(0,1), [this.sequenceLen, this.nCompartments, numTimePoints], 1);</span>
<a name="l00460"></a>00460 <span class="stringliteral">            this.hollidayJunctions        = CircularSparseMat([], false(0,1), [this.sequenceLen, this.nCompartments, numTimePoints], 1);</span>
<a name="l00461"></a>00461 <span class="stringliteral">            </span>
<a name="l00462"></a>00462 <span class="stringliteral">            this.segregated               = false(1, 1, numTimePoints);</span>
<a name="l00463"></a>00463 <span class="stringliteral">            </span>
<a name="l00464"></a>00464 <span class="stringliteral">            this.invalidate();</span>
<a name="l00465"></a>00465 <span class="stringliteral">        end</span>
<a name="l00466"></a>00466 <span class="stringliteral">    end</span>
<a name="l00467"></a>00467 <span class="stringliteral">    </span>
<a name="l00468"></a>00468 <span class="stringliteral">    methods</span>
<a name="l00469"></a>00469 <span class="stringliteral">        function initialize(this)</span>
<a name="l00470"></a>00470 <span class="stringliteral">            this.allocateMemory(1);</span>
<a name="l00471"></a>00471 <span class="stringliteral">            </span>
<a name="l00472"></a>00472 <span class="stringliteral">            this.polymerizedRegions(1, this.strandIndexs_ch1) = this.sequenceLen;</span>
<a name="l00473"></a>00473 <span class="stringliteral">            this.linkingNumbers(1, this.strandIndexs_ch1) = this.sequenceLen / this.relaxedBasesPerTurn * (1 + this.equilibriumSuperhelicalDensity);</span>
<a name="l00474"></a>00474 <span class="stringliteral">            </span>
<a name="l00475"></a>00475 <span class="stringliteral">            this.invalidate();</span>
<a name="l00476"></a>00476 <span class="stringliteral">        end        </span>
<a name="l00477"></a>00477 <span class="stringliteral">    end</span>
<a name="l00478"></a>00478 <span class="stringliteral"></span>
<a name="l00479"></a>00479 <span class="stringliteral">    %general methods which query, but do not modify state</span>
<a name="l00480"></a>00480 <span class="stringliteral">    methods</span>
<a name="l00481"></a>00481 <span class="stringliteral">        %- positionsStrands must be a 2 column vector</span>
<a name="l00482"></a>00482 <span class="stringliteral">        %- lengths must have same number of rows as positionsStrands</span>
<a name="l00483"></a>00483 <span class="stringliteral">        function [tfs, idxs, positionsStrands, lengths] = sampleAccessibleRegions(this, ...</span>
<a name="l00484"></a>00484 <span class="stringliteral">                nSites, weights, positionsStrands, lengths, ...</span>
<a name="l00485"></a>00485 <span class="stringliteral">                bindingMonomers, bindingComplexs, ...</span>
<a name="l00486"></a>00486 <span class="stringliteral">                isPositionsStrandFootprintCentroid, ignoreDamageFilter, returnOverlappingRegions, returnExtentAccessible, ...</span>
<a name="l00487"></a>00487 <span class="stringliteral">                checkRegionSupercoiled)</span>
<a name="l00488"></a>00488 <span class="stringliteral"></span>
<a name="l00489"></a>00489 <span class="stringliteral">            if nargin &lt; 12</span>
<a name="l00490"></a>00490 <span class="stringliteral">                checkRegionSupercoiled = false;</span>
<a name="l00491"></a>00491 <span class="stringliteral">            end</span>
<a name="l00492"></a>00492 <span class="stringliteral">            </span>
<a name="l00493"></a>00493 <span class="stringliteral">            if isempty(weights)</span>
<a name="l00494"></a>00494 <span class="stringliteral">                weights = ones(size(positionsStrands, 1), 1);</span>
<a name="l00495"></a>00495 <span class="stringliteral">            end</span>
<a name="l00496"></a>00496 <span class="stringliteral">            </span>
<a name="l00497"></a>00497 <span class="stringliteral">            [footprint, footprint3Prime, footprint5Prime, footprintBindingStrandedness] = this.getDNAFootprint(bindingMonomers, bindingComplexs);</span>
<a name="l00498"></a>00498 <span class="stringliteral">            </span>
<a name="l00499"></a>00499 <span class="stringliteral">            idxs = [];</span>
<a name="l00500"></a>00500 <span class="stringliteral">            while any(weights) &amp;&amp; numel(idxs) &lt; nSites</span>
<a name="l00501"></a>00501 <span class="stringliteral">                %sample sites</span>
<a name="l00502"></a>00502 <span class="stringliteral">                nMoreSites = min(max(2 * (nSites - numel(idxs)), 10), nnz(weights));</span>
<a name="l00503"></a>00503 <span class="stringliteral">                selectedSites = this.randStream.randsample(numel(weights), nMoreSites, false, weights);</span>
<a name="l00504"></a>00504 <span class="stringliteral">                weights(selectedSites) = 0;</span>
<a name="l00505"></a>00505 <span class="stringliteral">                </span>
<a name="l00506"></a>00506 <span class="stringliteral">                %determine if selected sites are accessible</span>
<a name="l00507"></a>00507 <span class="stringliteral">                [tmpTfs, ~, ~, extents] = this.isRegionAccessible(positionsStrands(selectedSites, :), lengths(selectedSites), ...</span>
<a name="l00508"></a>00508 <span class="stringliteral">                    bindingMonomers, bindingComplexs, isPositionsStrandFootprintCentroid, ignoreDamageFilter, ...</span>
<a name="l00509"></a>00509 <span class="stringliteral">                    returnExtentAccessible, true, checkRegionSupercoiled);</span>
<a name="l00510"></a>00510 <span class="stringliteral">                newIdxs = selectedSites(tmpTfs);</span>
<a name="l00511"></a>00511 <span class="stringliteral">                lengths(selectedSites(~tmpTfs)) = 0;</span>
<a name="l00512"></a>00512 <span class="stringliteral">                lengths(selectedSites(tmpTfs)) = extents;</span>
<a name="l00513"></a>00513 <span class="stringliteral">                </span>
<a name="l00514"></a>00514 <span class="stringliteral">                %if proteins binding, make sure proteins won&#39;</span>t sterically overlap
<a name="l00515"></a>00515                 <span class="keywordflow">if</span> ~returnOverlappingRegions
<a name="l00516"></a>00516                     [idxs, newIdxs] = this.excludeOverlappingRegions(...
<a name="l00517"></a>00517                         idxs, newIdxs, positionsStrands, lengths, ...
<a name="l00518"></a>00518                         footprint, footprint3Prime, footprint5Prime, isPositionsStrandFootprintCentroid, ...
<a name="l00519"></a>00519                         footprintBindingStrandedness == this.dnaStrandedness_dsDNA);
<a name="l00520"></a>00520                 end
<a name="l00521"></a>00521                 
<a name="l00522"></a>00522                 <span class="keywordflow">if</span> numel(newIdxs) &gt; nSites - numel(idxs)
<a name="l00523"></a>00523                     newIdxs = newIdxs(1:nSites - numel(idxs));
<a name="l00524"></a>00524                 end
<a name="l00525"></a>00525                 idxs = [idxs; newIdxs];
<a name="l00526"></a>00526             end
<a name="l00527"></a>00527             
<a name="l00528"></a>00528             %format output            
<a name="l00529"></a>00529             idxs = sort(idxs);
<a name="l00530"></a>00530             tfs = <span class="keyword">false</span>(size(positionsStrands, 1), 1);
<a name="l00531"></a>00531             tfs(idxs) = <span class="keyword">true</span>;
<a name="l00532"></a>00532             positionsStrands = positionsStrands(idxs, :);
<a name="l00533"></a>00533             lengths = lengths(idxs, :);
<a name="l00534"></a>00534         end
<a name="l00535"></a>00535         
<a name="l00536"></a>00536         %randomly select among accessible sites (which <span class="keywordflow">if</span> sequence seq is
<a name="l00537"></a>00537         %specified, have <span class="keyword">this</span> sequence) with probability probOrNSites (or <span class="keywordflow">if</span>
<a name="l00538"></a>00538         %probOrNSites &gt; 1, randomly select probOrNSites sites)
<a name="l00539"></a>00539         <span class="keyword">function</span> positionsStrands = sampleAccessibleSites(<span class="keyword">this</span>, prob, nSites, seq)
<a name="l00540"></a>00540             %<span class="keywordflow">for</span> convenience
<a name="l00541"></a>00541             dnaLength = this.sequenceLen;
<a name="l00542"></a>00542             posStrnds = find(this.polymerizedRegions);
<a name="l00543"></a>00543             nStrands = max(posStrnds(:, 2));
<a name="l00544"></a>00544             seqLen = numel(seq);
<a name="l00545"></a>00545             
<a name="l00546"></a>00546             %estimate total number of accessible sites
<a name="l00547"></a>00547             [~, boundMonomers] = find(this.monomerBoundSites);
<a name="l00548"></a>00548             [~, boundComplexs] = find(this.complexBoundSites);
<a name="l00549"></a>00549             
<a name="l00550"></a>00550             nAccessibleSites = ...
<a name="l00551"></a>00551                 collapse(this.polymerizedRegions) ...
<a name="l00552"></a>00552                 - sum(this.monomerDNAFootprints(boundMonomers, 1)) ...
<a name="l00553"></a>00553                 - sum(this.complexDNAFootprints(boundComplexs, 1)) ...
<a name="l00554"></a>00554                 - nnz(this.damagedSites);
<a name="l00555"></a>00555             
<a name="l00556"></a>00556             %calculate number of sites to select
<a name="l00557"></a>00557             <span class="keywordflow">if</span> ~isempty(prob)
<a name="l00558"></a>00558                 nGC = sum(seq == &#39;G&#39; | seq == &#39;C&#39;);
<a name="l00559"></a>00559                 nSites = min(nSites, this.randStream.stochasticRound(...
<a name="l00560"></a>00560                     nAccessibleSites * prob * ...
<a name="l00561"></a>00561                     (this.sequenceGCContent/2)^nGC * ((1-this.sequenceGCContent)/2)^(seqLen-nGC)));
<a name="l00562"></a>00562             end
<a name="l00563"></a>00563             if nSites == 0
<a name="l00564"></a>00564                 positionsStrands = zeros(0, 2);
<a name="l00565"></a>00565                 return;
<a name="l00566"></a>00566             end
<a name="l00567"></a>00567             
<a name="l00568"></a>00568             %randomly select nSites undamaged sites with sequence equal to seq
<a name="l00569"></a>00569             positionsStrands = zeros(0, 2);
<a name="l00570"></a>00570             iter = 0;
<a name="l00571"></a>00571             <a class="code" href="json_parse_8m.html#ad2fc293e8080616c8c1e2ffbd7b86742">while</a> iter &lt; 15
<a name="l00572"></a>00572                 %iterations
<a name="l00573"></a>00573                 iter = iter + 1;
<a name="l00574"></a>00574                 
<a name="l00575"></a>00575                 %more sites
<a name="l00576"></a>00576                 nMoreSites = nSites - size(positionsStrands, 1);
<a name="l00577"></a>00577                 nMoreSites = max(2 * nMoreSites, nMoreSites + 10);
<a name="l00578"></a>00578                 
<a name="l00579"></a>00579                 %pick random positions and strand
<a name="l00580"></a>00580                 positions = ceil(dnaLength * this.randStream.rand(nMoreSites, 1));
<a name="l00581"></a>00581                 strands   = ceil(nStrands * this.randStream.rand(nMoreSites, 1));
<a name="l00582"></a>00582                 
<a name="l00583"></a>00583                 %throw away positions that aren&#39;t inaccessible
<a name="l00584"></a>00584                 if isempty(seq)
<a name="l00585"></a>00585                     [~, idxs] = this.isRegionAccessible([positions strands], 1, [], [], true, [], false, false);
<a name="l00586"></a>00586                 else
<a name="l00587"></a>00587                     dir = 2 * (mod(strands, 2) == 1) - 1;
<a name="l00588"></a>00588                     pos = 0:seqLen - 1;
<a name="l00589"></a>00589                     
<a name="l00590"></a>00590                     subsequences = this.sequence.subsequence(...
<a name="l00591"></a>00591                         positions(:, ones(1, seqLen)) + ...
<a name="l00592"></a>00592                         dir(:, ones(1, seqLen)) .* pos(ones(nMoreSites, 1), :), ...
<a name="l00593"></a>00593                         strands);
<a name="l00594"></a>00594                     
<a name="l00595"></a>00595                     if size(seq, 1) == 1
<a name="l00596"></a>00596                         if isscalar(seq)
<a name="l00597"></a>00597                             idx = find(subsequences == seq);
<a name="l00598"></a>00598                         elseif size(seq, 2) == 2
<a name="l00599"></a>00599                             idx = find(subsequences(:, 1) == seq(1) &amp; subsequences(:, 2) == seq(2));
<a name="l00600"></a>00600                         else
<a name="l00601"></a>00601                             idx = find(all(subsequences == seq(ones(size(subsequences, 1), 1), :), 2));
<a name="l00602"></a>00602                         end
<a name="l00603"></a>00603                     else
<a name="l00604"></a>00604                         idx = find(ismember(subsequences, seq, &#39;rows&#39;));
<a name="l00605"></a>00605                     end
<a name="l00606"></a>00606                     positions = positions(idx, :);
<a name="l00607"></a>00607                     strands = strands(idx, :);
<a name="l00608"></a>00608                     
<a name="l00609"></a>00609                     [~, idxs] = this.isRegionAccessible([positions strands], seqLen, [], [], true, [], false, false);
<a name="l00610"></a>00610                 end
<a name="l00611"></a>00611                 
<a name="l00612"></a>00612                 %append to list of valid positions and strands
<a name="l00613"></a>00613                 positionsStrands = edu.stanford.covert.util.<a class="code" href="class_sparse_mat.html">SparseMat</a>.unique_subs(...
<a name="l00614"></a>00614                     [positionsStrands; positions(idxs) strands(idxs)], [dnaLength this.nCompartments]);
<a name="l00615"></a>00615                 
<a name="l00616"></a>00616                 %if more sites that requested, randomly select
<a name="l00617"></a>00617                 if size(positionsStrands, 1) &gt;= nSites
<a name="l00618"></a>00618                     positionsStrands = this.randStream.randomlySelectNRows(positionsStrands, nSites);
<a name="l00619"></a>00619                     break;
<a name="l00620"></a>00620                 end
<a name="l00621"></a>00621             end
<a name="l00622"></a>00622             
<a name="l00623"></a>00623             %sort
<a name="l00624"></a>00624             if nSites &gt; 1
<a name="l00625"></a>00625                 positionsStrands = edu.stanford.covert.util.<a class="code" href="class_sparse_mat.html">SparseMat</a>.sort_subs(positionsStrands, [dnaLength this.nCompartments]);
<a name="l00626"></a>00626             end
<a name="l00627"></a>00627         end
<a name="l00628"></a>00628         
<a name="l00629"></a>00629         %Filters a list of sites (positionsStrands -- strands and positions along
<a name="l00630"></a>00630         %strands), returning only those sites which are accessible to the
<a name="l00631"></a>00631         %queried protein monomers and complexes (that is site which have been
<a name="l00632"></a>00632         %polymerized, which aren&#39;t damaged, and which are either not bound by
<a name="l00633"></a>00633         %protein, or are bound by proteins which at least one of the query
<a name="l00634"></a>00634         %protein can release from the chromosome). Query proteins are indicated
<a name="l00635"></a>00635         %by their indices within simulation.matureMatureIndexs
<a name="l00636"></a>00636         %(monomerIndexs) and simulation.matureIndexs (complexIndexs).
<a name="l00637"></a>00637         %
<a name="l00638"></a>00638         %If monomerIndexs and complexIndexs are null, or aren&#39;t defined, this
<a name="l00639"></a>00639         %function only returns sites that have been polymerized, aren&#39;t damaged,
<a name="l00640"></a>00640         %and aren&#39;t bound by any proteins.
<a name="l00641"></a>00641         %
<a name="l00642"></a>00642         %Also returns the indices (idxs) of the query sites which are
<a name="l00643"></a>00643         %accessible, and a <span class="keywordtype">boolean</span> vector (tfs) indicated whether or not each
<a name="l00644"></a>00644         %query site is accessible
<a name="l00645"></a>00645         %
<a name="l00646"></a>00646         %Returns true/false if regions defined by positionsStrands and lengths
<a name="l00647"></a>00647         %are accessible/inaccessible.
<a name="l00648"></a>00648         %
<a name="l00649"></a>00649         %true  ==&gt; region is accessible
<a name="l00650"></a>00650         %false ==&gt; region is not accessible
<a name="l00651"></a>00651         function [tfs, idxs, positionsStrands, lengths] = isRegionAccessible(this, ...
<a name="l00652"></a>00652                 positionsStrands, lengths, ...
<a name="l00653"></a>00653                 bindingMonomers, bindingComplexs, ...
<a name="l00654"></a>00654                 isPositionsStrandFootprintCentroid, ignoreDamageFilter, ...
<a name="l00655"></a>00655                 returnExtent, returnOverlappingRegions, checkRegionSupercoiled)
<a name="l00656"></a>00656             if isempty(positionsStrands)
<a name="l00657"></a>00657                 tfs = false(0, 1);
<a name="l00658"></a>00658                 idxs = zeros(0, 1);
<a name="l00659"></a>00659                 lengths = zeros(0, 1);
<a name="l00660"></a>00660                 return;
<a name="l00661"></a>00661             end
<a name="l00662"></a>00662             
<a name="l00663"></a>00663             %% default values of inputs
<a name="l00664"></a>00664             if ~all(lengths)
<a name="l00665"></a>00665                 throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;, &#39;Lengths must be non-zero integers&#39;));
<a name="l00666"></a>00666             elseif numel(lengths) == 1
<a name="l00667"></a>00667                 lengths = lengths(ones(size(positionsStrands, 1), 1), 1);
<a name="l00668"></a>00668             end
<a name="l00669"></a>00669             if isempty(ignoreDamageFilter)
<a name="l00670"></a>00670                 ignoreDamageFilter = zeros(size(positionsStrands, 1), 0);
<a name="l00671"></a>00671             elseif size(ignoreDamageFilter, 1) &lt;= 1
<a name="l00672"></a>00672                 ignoreDamageFilter = ignoreDamageFilter(ones(size(positionsStrands, 1), 1), :);
<a name="l00673"></a>00673             end
<a name="l00674"></a>00674             if nargin &lt; 9
<a name="l00675"></a>00675                 returnOverlappingRegions = true;
<a name="l00676"></a>00676             end
<a name="l00677"></a>00677             if nargin &lt; 10
<a name="l00678"></a>00678                 checkRegionSupercoiled = false;
<a name="l00679"></a>00679             end
<a name="l00680"></a>00680             
<a name="l00681"></a>00681             %% indices of complexs and monomers which at least one of the the
<a name="l00682"></a>00682             %query proteins can release, and therefore shouldn&#39;t be cause for a
<a name="l00683"></a>00683             %site to be filtered out if they are bound to a site
<a name="l00684"></a>00684             [releasableMonomerIndexs, releasableComplexIndexs] = this.getReleasableProteins(bindingMonomers, bindingComplexs);
<a name="l00685"></a>00685             
<a name="l00686"></a>00686             %% DNA footprint of binding proteins,
<a name="l00687"></a>00687             [footprint, footprint3Prime, footprint5Prime, footprintBindingStrandedness, footprintRegionStrandedness] = this.getDNAFootprint(bindingMonomers, bindingComplexs);
<a name="l00688"></a>00688             
<a name="l00689"></a>00689             %adding query positions if input positions are the centroid of
<a name="l00690"></a>00690             %the binding proteins&#39; DNA footpring
<a name="l00691"></a>00691             queryPositionsStrands = positionsStrands;
<a name="l00692"></a>00692             if isPositionsStrandFootprintCentroid
<a name="l00693"></a>00693                 strnd = queryPositionsStrands(:, 2);
<a name="l00694"></a>00694                 
<a name="l00695"></a>00695                 queryPositionsStrands(mod(strnd, 2) == 1 &amp; lengths &gt; 0, 1) = queryPositionsStrands(mod(strnd, 2) == 1 &amp; lengths &gt; 0, 1) - footprint5Prime;
<a name="l00696"></a>00696                 queryPositionsStrands(mod(strnd, 2) == 0 &amp; lengths &gt; 0, 1) = queryPositionsStrands(mod(strnd, 2) == 0 &amp; lengths &gt; 0, 1) - footprint3Prime;
<a name="l00697"></a>00697                 queryPositionsStrands(mod(strnd, 2) == 1 &amp; lengths &lt; 0, 1) = queryPositionsStrands(mod(strnd, 2) == 1 &amp; lengths &lt; 0, 1) + footprint3Prime;
<a name="l00698"></a>00698                 queryPositionsStrands(mod(strnd, 2) == 0 &amp; lengths &lt; 0, 1) = queryPositionsStrands(mod(strnd, 2) == 0 &amp; lengths &lt; 0, 1) + footprint5Prime;
<a name="l00699"></a>00699                 
<a name="l00700"></a>00700                 ignoreDamageFilter(mod(strnd, 2) == 1 &amp; lengths &gt; 0, :) = ignoreDamageFilter(mod(strnd, 2) == 1 &amp; lengths &gt; 0, :) + footprint5Prime;
<a name="l00701"></a>00701                 ignoreDamageFilter(mod(strnd, 2) == 0 &amp; lengths &gt; 0, :) = ignoreDamageFilter(mod(strnd, 2) == 0 &amp; lengths &gt; 0, :) + footprint3Prime;
<a name="l00702"></a>00702                 ignoreDamageFilter(mod(strnd, 2) == 1 &amp; lengths &lt; 0, :) = ignoreDamageFilter(mod(strnd, 2) == 1 &amp; lengths &lt; 0, :) - footprint3Prime;
<a name="l00703"></a>00703                 ignoreDamageFilter(mod(strnd, 2) == 0 &amp; lengths &lt; 0, :) = ignoreDamageFilter(mod(strnd, 2) == 0 &amp; lengths &lt; 0, :) - footprint5Prime;
<a name="l00704"></a>00704             elseif lengths &lt; 0
<a name="l00705"></a>00705                 queryPositionsStrands(:, 1) = queryPositionsStrands(:, 1) + footprint - 1;
<a name="l00706"></a>00706             end
<a name="l00707"></a>00707             queryLengths = lengths + sign(lengths) * (footprint - 1);
<a name="l00708"></a>00708             
<a name="l00709"></a>00709             %% filter query sites
<a name="l00710"></a>00710             switch footprintRegionStrandedness
<a name="l00711"></a>00711                 case this.dnaStrandedness_dsDNA
<a name="l00712"></a>00712                     [~, ~, ~, polymerized] = this.isRegionDoubleStranded(queryPositionsStrands, queryLengths, true, checkRegionSupercoiled);
<a name="l00713"></a>00713                 case this.dnaStrandedness_ssDNA
<a name="l00714"></a>00714                     [~, ~, ~, polymerized] = this.isRegionSingleStranded(queryPositionsStrands, queryLengths, true);                
<a name="l00715"></a>00715                 case this.dnaStrandedness_xsDNA
<a name="l00716"></a>00716                     %TODO: calculate extent
<a name="l00717"></a>00717                     polymerized = queryLengths;
<a name="l00718"></a>00718                 otherwise
<a name="l00719"></a>00719                     throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;,&#39;Invalid footprint strandedness&#39;));
<a name="l00720"></a>00720             end
<a name="l00721"></a>00721             
<a name="l00722"></a>00722             [~, ~, ~, proteinFree] = this.isRegionProteinFree(queryPositionsStrands, queryLengths, true, ...
<a name="l00723"></a>00723                 releasableMonomerIndexs, releasableComplexIndexs, ...
<a name="l00724"></a>00724                 footprintBindingStrandedness == this.dnaStrandedness_dsDNA, ...
<a name="l00725"></a>00725                 footprintRegionStrandedness == this.dnaStrandedness_xsDNA);
<a name="l00726"></a>00726             [~, ~, ~, undamaged] = this.isRegionUndamaged(queryPositionsStrands, queryLengths, ...
<a name="l00727"></a>00727                 footprintBindingStrandedness == this.dnaStrandedness_dsDNA, ignoreDamageFilter, true, ...
<a name="l00728"></a>00728                 footprintRegionStrandedness == this.dnaStrandedness_xsDNA);
<a name="l00729"></a>00729             
<a name="l00730"></a>00730             extents = sign(lengths) .* max(0, (min(abs([proteinFree polymerized undamaged]), [], 2) - (footprint - 1)));
<a name="l00731"></a>00731             
<a name="l00732"></a>00732             %% Make sure regions don&#39;t sterically overlap
<a name="l00733"></a>00733             if ~returnOverlappingRegions
<a name="l00734"></a>00734                 if returnExtent
<a name="l00735"></a>00735                     tfs = find(extents ~= 0);
<a name="l00736"></a>00736                 else
<a name="l00737"></a>00737                     tfs = find(lengths == extents);
<a name="l00738"></a>00738                 end
<a name="l00739"></a>00739                 [~, idxs] = this.excludeOverlappingRegions([], tfs, positionsStrands, extents, ...
<a name="l00740"></a>00740                     footprint, footprint3Prime, footprint5Prime, isPositionsStrandFootprintCentroid, ...
<a name="l00741"></a>00741                     footprintBindingStrandedness == this.dnaStrandedness_dsDNA);
<a name="l00742"></a>00742                 extents(setdiff(1:end, idxs)) = 0;
<a name="l00743"></a>00743             end
<a name="l00744"></a>00744             
<a name="l00745"></a>00745             %% format output
<a name="l00746"></a>00746             %- extract sites which pass filter
<a name="l00747"></a>00747             %- reshape indices of sites which pass filter
<a name="l00748"></a>00748             %- construct <span class="keywordtype">boolean</span> indicating which sites pass filter
<a name="l00749"></a>00749             if returnExtent
<a name="l00750"></a>00750                 tfs = true(size(positionsStrands, 1), 1);
<a name="l00751"></a>00751             else
<a name="l00752"></a>00752                 tfs = lengths == extents;
<a name="l00753"></a>00753             end
<a name="l00754"></a>00754             idxs = find(tfs);
<a name="l00755"></a>00755             idxs = idxs(:);
<a name="l00756"></a>00756             positionsStrands = positionsStrands(idxs, :);
<a name="l00757"></a>00757             lengths = extents(idxs, :);
<a name="l00758"></a>00758         end
<a name="l00759"></a>00759     end
<a name="l00760"></a>00760     
<a name="l00761"></a>00761     %private methods for query state by region
<a name="l00762"></a>00762     methods
<a name="l00763"></a>00763         function [tfs, idxs, positionsStrands, lengths] = isRegionSingleStranded(this, positionsStrands, lengths, returnExtent)
<a name="l00764"></a>00764             if isempty(positionsStrands)
<a name="l00765"></a>00765                 tfs = false(0, 1);
<a name="l00766"></a>00766                 idxs = zeros(0, 1);
<a name="l00767"></a>00767                 lengths = zeros(0, 1);
<a name="l00768"></a>00768                 return;
<a name="l00769"></a>00769             end
<a name="l00770"></a>00770             if numel(lengths) == 1
<a name="l00771"></a>00771                 lengths = lengths(ones(size(positionsStrands, 1), 1), 1);
<a name="l00772"></a>00772             end
<a name="l00773"></a>00773             
<a name="l00774"></a>00774             [polPosStrnds, polLens] = find(this.polymerizedRegions);
<a name="l00775"></a>00775             
<a name="l00776"></a>00776             %only 1 chromosome
<a name="l00777"></a>00777             if size(positionsStrands, 2) == 2 &amp;&amp; all(polLens == this.sequenceLen) &amp;&amp; mod(numel(polLens), 2) == 0 &amp;&amp; all(polPosStrnds(:, 2) == (1:numel(polLens))&#39;)
<a name="l00778"></a>00778                 if returnExtent
<a name="l00779"></a>00779                     tfs = true(size(positionsStrands, 1), 1);
<a name="l00780"></a>00780                     idxs = (1:numel(tfs))&#39;;
<a name="l00781"></a>00781                     lengths(:) = 0;
<a name="l00782"></a>00782                 else
<a name="l00783"></a>00783                     tfs = false(size(lengths));
<a name="l00784"></a>00784                     idxs = zeros(0, 1);
<a name="l00785"></a>00785                     positionsStrands = zeros(0, 2);
<a name="l00786"></a>00786                     lengths = zeros(0, 1);
<a name="l00787"></a>00787                 end
<a name="l00788"></a>00788                 return;
<a name="l00789"></a>00789             end
<a name="l00790"></a>00790             
<a name="l00791"></a>00791             %all other cases
<a name="l00792"></a>00792             [tfs, idxs, positionsStrands, lengths] = this.isRegionPolymerized(positionsStrands, lengths, returnExtent, this.dnaStrandedness_ssDNA);
<a name="l00793"></a>00793         end
<a name="l00794"></a>00794         
<a name="l00795"></a>00795         function [tfs, idxs, positionsStrands, lengths] = isRegionDoubleStranded(this, positionsStrands, lengths, returnExtent, checkRegionSupercoiled)
<a name="l00796"></a>00796             if isempty(positionsStrands)
<a name="l00797"></a>00797                 tfs = false(0, 1);
<a name="l00798"></a>00798                 idxs = zeros(0, 1);
<a name="l00799"></a>00799                 lengths = zeros(0, 1);
<a name="l00800"></a>00800                 return;
<a name="l00801"></a>00801             end
<a name="l00802"></a>00802             if nargin &lt; 5
<a name="l00803"></a>00803                 checkRegionSupercoiled = false;
<a name="l00804"></a>00804             end
<a name="l00805"></a>00805             
<a name="l00806"></a>00806             if numel(lengths) == 1
<a name="l00807"></a>00807                 lengths = lengths(ones(size(positionsStrands, 1), 1), 1);
<a name="l00808"></a>00808             end
<a name="l00809"></a>00809             
<a name="l00810"></a>00810             [polPosStrnds, polLens] = find(this.polymerizedRegions);
<a name="l00811"></a>00811             if checkRegionSupercoiled
<a name="l00812"></a>00812                 supPosStrnds = find(this.supercoiled);
<a name="l00813"></a>00813             end
<a name="l00814"></a>00814             
<a name="l00815"></a>00815             %only fully formed chromosomes
<a name="l00816"></a>00816             if size(positionsStrands, 2) == 2 &amp;&amp; all(polLens == this.sequenceLen) &amp;&amp; mod(numel(polLens), 2) == 0 &amp;&amp; all(polPosStrnds(:, 2) == (1:numel(polLens))&#39;)
<a name="l00817"></a>00817                 if numel(polLens) == 2
<a name="l00818"></a>00818                     if returnExtent
<a name="l00819"></a>00819                         tfs = true(size(positionsStrands, 1), 1);
<a name="l00820"></a>00820                         idxs = (1:numel(tfs))&#39;;
<a name="l00821"></a>00821                         lengths(positionsStrands(:, 2) &gt; 2) = 0;
<a name="l00822"></a>00822                         if checkRegionSupercoiled
<a name="l00823"></a>00823                             lengths(~ismembc(positionsStrands(:, 2), supPosStrnds(:, 2))) = 0;
<a name="l00824"></a>00824                         end
<a name="l00825"></a>00825                     else
<a name="l00826"></a>00826                         tfs = positionsStrands(:, 2) &lt;= 2;
<a name="l00827"></a>00827                         if checkRegionSupercoiled
<a name="l00828"></a>00828                             tfs = tfs &amp; ismembc(positionsStrands(:, 2), supPosStrnds(:, 2));
<a name="l00829"></a>00829                         end
<a name="l00830"></a>00830                         idxs = find(tfs);
<a name="l00831"></a>00831                         positionsStrands = positionsStrands(tfs, :);
<a name="l00832"></a>00832                         lengths = lengths(tfs, 1);
<a name="l00833"></a>00833                     end
<a name="l00834"></a>00834                 else
<a name="l00835"></a>00835                     if returnExtent
<a name="l00836"></a>00836                         tfs = true(size(positionsStrands, 1), 1);
<a name="l00837"></a>00837                         idxs = (1:numel(tfs))&#39;;
<a name="l00838"></a>00838                         if checkRegionSupercoiled
<a name="l00839"></a>00839                             lengths(~ismembc(positionsStrands(:, 2), supPosStrnds(:, 2))) = 0;
<a name="l00840"></a>00840                         end
<a name="l00841"></a>00841                     else
<a name="l00842"></a>00842                         tfs = true(size(positionsStrands, 1), 1);
<a name="l00843"></a>00843                         if checkRegionSupercoiled
<a name="l00844"></a>00844                             tfs = tfs &amp; ismembc(positionsStrands(:, 2), supPosStrnds(:, 2));
<a name="l00845"></a>00845                         end
<a name="l00846"></a>00846                         idxs = find(tfs);
<a name="l00847"></a>00847                         positionsStrands = positionsStrands(tfs, :);
<a name="l00848"></a>00848                         lengths = lengths(tfs, 1);
<a name="l00849"></a>00849                     end
<a name="l00850"></a>00850                 end
<a name="l00851"></a>00851                 return;
<a name="l00852"></a>00852             end
<a name="l00853"></a>00853             
<a name="l00854"></a>00854             %all other cases
<a name="l00855"></a>00855             [tfs, idxs, positionsStrands, lengths] = this.isRegionPolymerized(positionsStrands, lengths, returnExtent, this.dnaStrandedness_dsDNA, checkRegionSupercoiled);
<a name="l00856"></a>00856         end
<a name="l00857"></a>00857         
<a name="l00858"></a>00858         function [tfs, idxs, positionsStrands, lengths] = isRegionPolymerized(this, ...
<a name="l00859"></a>00859                 positionsStrands, lengths, returnExtent, checkRegionStrandedness, checkRegionSupercoiled, polymerizedRegions)
<a name="l00860"></a>00860             if isempty(positionsStrands)
<a name="l00861"></a>00861                 tfs = false(0, 1);
<a name="l00862"></a>00862                 idxs = zeros(0, 1);
<a name="l00863"></a>00863                 lengths = zeros(0, 1);
<a name="l00864"></a>00864                 return;
<a name="l00865"></a>00865             end
<a name="l00866"></a>00866             if ~all(lengths)
<a name="l00867"></a>00867                 throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;,&#39;Lengths must be non-zero integers&#39;));
<a name="l00868"></a>00868             elseif numel(lengths) == 1
<a name="l00869"></a>00869                 lengths = lengths(ones(size(positionsStrands, 1), 1), 1);
<a name="l00870"></a>00870             end
<a name="l00871"></a>00871             if nargin &lt; 7
<a name="l00872"></a>00872                 polymerizedRegions = this.polymerizedRegions;
<a name="l00873"></a>00873             end
<a name="l00874"></a>00874             
<a name="l00875"></a>00875             if nargin &gt;= 5 &amp;&amp; ~isempty(checkRegionStrandedness) &amp;&amp; checkRegionStrandedness == this.dnaStrandedness_dsDNA
<a name="l00876"></a>00876                 [regions, regionLengths] = find(this.doubleStrandedRegions);
<a name="l00877"></a>00877                 if nargin &gt;= 6 &amp;&amp; ~isempty(checkRegionSupercoiled) &amp;&amp; checkRegionSupercoiled
<a name="l00878"></a>00878                     tfs = this.supercoiled(regions);
<a name="l00879"></a>00879                     regions = regions(tfs, :);
<a name="l00880"></a>00880                     regionLengths = regionLengths(tfs, :);
<a name="l00881"></a>00881                 end
<a name="l00882"></a>00882             elseif nargin &gt;= 5 &amp;&amp; ~isempty(checkRegionStrandedness) &amp;&amp; checkRegionStrandedness == this.dnaStrandedness_ssDNA
<a name="l00883"></a>00883                 [regions, regionLengths] = find(this.singleStrandedRegions);
<a name="l00884"></a>00884             else
<a name="l00885"></a>00885                 [regions, regionLengths] = find(polymerizedRegions);
<a name="l00886"></a>00886             end
<a name="l00887"></a>00887             
<a name="l00888"></a>00888             %all strands either fully, or not at all synthesized
<a name="l00889"></a>00889             if all(regionLengths == this.sequenceLen) &amp;&amp; size(regions, 2) == 2
<a name="l00890"></a>00890                 if size(regions, 1) == this.nCompartments
<a name="l00891"></a>00891                     %all chromosomes fully synethesized
<a name="l00892"></a>00892                     tfs = true(size(positionsStrands,1), 1);
<a name="l00893"></a>00893                     idxs = (1:size(positionsStrands,1))&#39;;
<a name="l00894"></a>00894                 elseif isequal(regions(:,2), [1; 2])
<a name="l00895"></a>00895                     %first chromosome fully synethesized
<a name="l00896"></a>00896                     if returnExtent
<a name="l00897"></a>00897                         tfs = true(size(positionsStrands,1), 1);
<a name="l00898"></a>00898                         idxs = (1:size(positionsStrands,1))&#39;;
<a name="l00899"></a>00899                         lengths(~ismembc(positionsStrands(:,2), regions(:, 2))) = 0;
<a name="l00900"></a>00900                     else
<a name="l00901"></a>00901                         tfs = ceil(positionsStrands(:,2)/2) == 1;
<a name="l00902"></a>00902                         idxs = reshape(find(tfs), [], 1);
<a name="l00903"></a>00903                         positionsStrands = positionsStrands(idxs, :);
<a name="l00904"></a>00904                         lengths = lengths(idxs, :);
<a name="l00905"></a>00905                     end
<a name="l00906"></a>00906                 else
<a name="l00907"></a>00907                     %all strands either fully, or not at all synthesized
<a name="l00908"></a>00908                     if returnExtent
<a name="l00909"></a>00909                         tfs = true(size(positionsStrands,1), 1);
<a name="l00910"></a>00910                         idxs = (1:size(positionsStrands,1))&#39;;
<a name="l00911"></a>00911                         lengths(~ismembc(positionsStrands(:,2), regions(:, 2))) = 0;
<a name="l00912"></a>00912                     else
<a name="l00913"></a>00913                         tfs = ismembc(positionsStrands(:,2), regions(:, 2));
<a name="l00914"></a>00914                         idxs = reshape(find(tfs), [], 1);
<a name="l00915"></a>00915                         positionsStrands = positionsStrands(idxs, :);
<a name="l00916"></a>00916                         lengths = lengths(idxs, :);
<a name="l00917"></a>00917                     end
<a name="l00918"></a>00918                 end
<a name="l00919"></a>00919                 return;
<a name="l00920"></a>00920             end
<a name="l00921"></a>00921             
<a name="l00922"></a>00922             regionStartCoors = regions(:, 1);
<a name="l00923"></a>00923             regionEndCoors = regionStartCoors  + regionLengths - 1;
<a name="l00924"></a>00924             regionStrandTimes = [regions(:, 2:end) ones(size(regions, 1), size(positionsStrands,2) - size(regions, 2))];
<a name="l00925"></a>00925             
<a name="l00926"></a>00926             startCoors = mod(positionsStrands(:, 1) + min(0, lengths+1) - 1, this.sequenceLen) +1;
<a name="l00927"></a>00927             endCoors = startCoors + abs(lengths) - 1;
<a name="l00928"></a>00928             strandTimes = [positionsStrands(:, 2:end) ones(size(positionsStrands, 1), size(regions, 2) - size(positionsStrands,2))];
<a name="l00929"></a>00929             idxs = (1:size(positionsStrands, 1))&#39;;
<a name="l00930"></a>00930             
<a name="l00931"></a>00931             tmpIdxs = find(endCoors &gt; this.sequenceLen);
<a name="l00932"></a>00932             strandTimes = [strandTimes; strandTimes(tmpIdxs, :)];
<a name="l00933"></a>00933             startCoors = [startCoors; max(1, startCoors(tmpIdxs) - this.sequenceLen)];
<a name="l00934"></a>00934             endCoors = [endCoors; endCoors(tmpIdxs) - this.sequenceLen];
<a name="l00935"></a>00935             endCoors(tmpIdxs) = this.sequenceLen;
<a name="l00936"></a>00936             idxs = [idxs; idxs(tmpIdxs)];
<a name="l00937"></a>00937             
<a name="l00938"></a>00938             tmpIdxs = find(startCoors &lt; 0);
<a name="l00939"></a>00939             strandTimes = [strandTimes; strandTimes(tmpIdxs, :)];
<a name="l00940"></a>00940             startCoors = [startCoors; startCoors(tmpIdxs) + this.sequenceLen];
<a name="l00941"></a>00941             endCoors = [endCoors; min(this.sequenceLen, endCoors(tmpIdxs) + this.sequenceLen)];
<a name="l00942"></a>00942             startCoors(tmpIdxs) = 1;
<a name="l00943"></a>00943             idxs = [idxs; idxs(tmpIdxs)];
<a name="l00944"></a>00944             
<a name="l00945"></a>00945             extents = zeros(size(positionsStrands, 1), 1);
<a name="l00946"></a>00946             if ndims(polymerizedRegions) == 2
<a name="l00947"></a>00947                 regionStrandTimeSiz = size(polymerizedRegions, 2);
<a name="l00948"></a>00948             else
<a name="l00949"></a>00949                 regionStrandTimeSiz = [size(polymerizedRegions, 2) size(polymerizedRegions, 3)];
<a name="l00950"></a>00950             end
<a name="l00951"></a>00951             
<a name="l00952"></a>00952             tfs = ...
<a name="l00953"></a>00953                 ((max(endCoors) &gt;= regionStartCoors &amp; max(endCoors) &lt;= regionEndCoors) | ...
<a name="l00954"></a>00954                 (min(startCoors) &gt;= regionStartCoors &amp; min(startCoors) &lt;= regionEndCoors) | ...
<a name="l00955"></a>00955                 (min(startCoors) &lt; regionStartCoors &amp; max(endCoors) &gt; regionEndCoors)) &amp; ...
<a name="l00956"></a>00956                 edu.stanford.covert.util.<a class="code" href="class_sparse_mat.html">SparseMat</a>.ismember_subs(regionStrandTimes, strandTimes, regionStrandTimeSiz);
<a name="l00957"></a>00957             regionStartCoors = regionStartCoors(tfs);
<a name="l00958"></a>00958             regionEndCoors = regionEndCoors(tfs);
<a name="l00959"></a>00959             regionStrandTimes = regionStrandTimes(tfs, :);
<a name="l00960"></a>00960             
<a name="l00961"></a>00961             if size(positionsStrands, 1) == numel(idxs)
<a name="l00962"></a>00962                 [~, idxs1, idxs2] = edu.stanford.covert.util.<a class="code" href="class_sparse_mat.html">SparseMat</a>.unique_subs([startCoors endCoors], [this.sequenceLen; this.sequenceLen]);
<a name="l00963"></a>00963                 for j = 1:numel(idxs1)
<a name="l00964"></a>00964                     idxs3 = find(idxs2 == j);
<a name="l00965"></a>00965                     startCoor = startCoors(idxs3(1));
<a name="l00966"></a>00966                     endCoor = endCoors(idxs3(1));
<a name="l00967"></a>00967                     len = lengths(idxs(idxs3(1)));
<a name="l00968"></a>00968                     if len &gt; 0
<a name="l00969"></a>00969                         idxs3 = idxs3(idxs3 &lt;= size(positionsStrands, 1) | extents(idxs(idxs3)) &gt;= this.sequenceLen - startCoor + 1);
<a name="l00970"></a>00970                         tfs = startCoor &gt;= regionStartCoors &amp; startCoor &lt;= regionEndCoors;
<a name="l00971"></a>00971                         tmpregionEndCoors = regionEndCoors(tfs);
<a name="l00972"></a>00972                         [tfs, idxs4] = edu.stanford.covert.util.<a class="code" href="class_sparse_mat.html">SparseMat</a>.ismember_subs(strandTimes(idxs3, :), regionStrandTimes(tfs, :), regionStrandTimeSiz);
<a name="l00973"></a>00973                         extents(idxs(idxs3(tfs))) = extents(idxs(idxs3(tfs))) + min(tmpregionEndCoors(idxs4(tfs)), endCoor) - startCoor + 1;
<a name="l00974"></a>00974                     else
<a name="l00975"></a>00975                         idxs3 = idxs3(idxs3 &lt;= size(positionsStrands, 1) | -extents(idxs(idxs3)) &gt;= endCoor);
<a name="l00976"></a>00976                         tfs = endCoor &gt;= regionStartCoors &amp; endCoor &lt;= regionEndCoors;
<a name="l00977"></a>00977                         tmpregionStartCoors = regionStartCoors(tfs);
<a name="l00978"></a>00978                         [tfs, idxs4] = edu.stanford.covert.util.<a class="code" href="class_sparse_mat.html">SparseMat</a>.ismember_subs(strandTimes(idxs3, :), regionStrandTimes(tfs, :), regionStrandTimeSiz);
<a name="l00979"></a>00979                         extents(idxs(idxs3(tfs))) = extents(idxs(idxs3(tfs))) - (endCoor - max(tmpregionStartCoors(idxs4(tfs)), startCoor) + 1);
<a name="l00980"></a>00980                     end
<a name="l00981"></a>00981                 end
<a name="l00982"></a>00982             else
<a name="l00983"></a>00983                 for i = 1:numel(startCoors)
<a name="l00984"></a>00984                     if lengths(idxs(i)) &gt; 0
<a name="l00985"></a>00985                         if i &gt; size(positionsStrands, 1) &amp;&amp; extents(idxs(i)) &lt; this.sequenceLen - startCoors(idxs(i)) + 1
<a name="l00986"></a>00986                             continue;
<a name="l00987"></a>00987                         end
<a name="l00988"></a>00988                         
<a name="l00989"></a>00989                         tmpIdxs = find(...
<a name="l00990"></a>00990                             startCoors(i) &gt;= regionStartCoors &amp; ...
<a name="l00991"></a>00991                             startCoors(i) &lt;= regionEndCoors &amp; ...
<a name="l00992"></a>00992                             ismember(regionStrandTimes, strandTimes(i, :), &#39;rows&#39;), 1, &#39;first&#39;);
<a name="l00993"></a>00993                         
<a name="l00994"></a>00994                         if ~isempty(tmpIdxs)
<a name="l00995"></a>00995                             extents(idxs(i)) = extents(idxs(i)) + min(regionEndCoors(tmpIdxs), endCoors(i)) - startCoors(i) + 1;
<a name="l00996"></a>00996                         end
<a name="l00997"></a>00997                     else
<a name="l00998"></a>00998                         if i &gt; size(positionsStrands, 1) &amp;&amp; -extents(idxs(i)) &lt; endCoors(idxs(i))
<a name="l00999"></a>00999                             continue;
<a name="l01000"></a>01000                         end
<a name="l01001"></a>01001                         
<a name="l01002"></a>01002                         tmpIdxs = find(...
<a name="l01003"></a>01003                             endCoors(i) &gt;= regionStartCoors &amp; ...
<a name="l01004"></a>01004                             endCoors(i) &lt;= regionEndCoors &amp; ...
<a name="l01005"></a>01005                             ismember(regionStrandTimes, strandTimes(i, :), &#39;rows&#39;), 1, &#39;first&#39;);
<a name="l01006"></a>01006                         
<a name="l01007"></a>01007                         if ~isempty(tmpIdxs)
<a name="l01008"></a>01008                             extents(idxs(i)) = extents(idxs(i)) - (endCoors(i) - max(regionStartCoors(tmpIdxs), startCoors(i)) + 1);
<a name="l01009"></a>01009                         end
<a name="l01010"></a>01010                     end
<a name="l01011"></a>01011                 end
<a name="l01012"></a>01012             end
<a name="l01013"></a>01013             
<a name="l01014"></a>01014             if returnExtent
<a name="l01015"></a>01015                 tfs = true(size(positionsStrands, 1), 1);
<a name="l01016"></a>01016             else
<a name="l01017"></a>01017                 tfs = extents == lengths;
<a name="l01018"></a>01018             end
<a name="l01019"></a>01019             
<a name="l01020"></a>01020             idxs = reshape(find(tfs), [], 1);
<a name="l01021"></a>01021             positionsStrands = positionsStrands(idxs, :);
<a name="l01022"></a>01022             lengths = extents(idxs, :);
<a name="l01023"></a>01023         end
<a name="l01024"></a>01024         
<a name="l01025"></a>01025         function [tfs, idxs, positionsStrands, lengths] = isRegionNotPolymerized(this, positionsStrands, lengths, returnExtent)
<a name="l01026"></a>01026             if isempty(positionsStrands)
<a name="l01027"></a>01027                 tfs = false(0, 1);
<a name="l01028"></a>01028                 idxs = zeros(0, 1);
<a name="l01029"></a>01029                 lengths = zeros(0, 1);
<a name="l01030"></a>01030                 return;
<a name="l01031"></a>01031             end
<a name="l01032"></a>01032             
<a name="l01033"></a>01033             if ~all(lengths)
<a name="l01034"></a>01034                 throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;,&#39;Lengths must be non-zero integers&#39;));
<a name="l01035"></a>01035             elseif numel(lengths) == 1
<a name="l01036"></a>01036                 lengths = lengths(ones(size(positionsStrands, 1), 1), 1);
<a name="l01037"></a>01037             end
<a name="l01038"></a>01038             
<a name="l01039"></a>01039             unpolRgns = this.unpolymerizedRegions;
<a name="l01040"></a>01040             if nnz(unpolRgns) == 0
<a name="l01041"></a>01041                 if returnExtent
<a name="l01042"></a>01042                     tfs = true(size(positionsStrands,1), 1);
<a name="l01043"></a>01043                     idxs = (1:size(positionsStrands,1))&#39;;
<a name="l01044"></a>01044                     lengths =  zeros(size(positionsStrands,1), 1);
<a name="l01045"></a>01045                 else
<a name="l01046"></a>01046                     tfs = false(size(positionsStrands,1), 1);
<a name="l01047"></a>01047                     idxs = zeros(0, 1);
<a name="l01048"></a>01048                     positionsStrands = zeros(0, ndims(positionsStrands));
<a name="l01049"></a>01049                     lengths = zeros(0, 1);
<a name="l01050"></a>01050                 end
<a name="l01051"></a>01051                 return;
<a name="l01052"></a>01052             end
<a name="l01053"></a>01053             
<a name="l01054"></a>01054             [regions, regionLengths] = find(unpolRgns);
<a name="l01055"></a>01055             regionStartCoors = regions(:, 1);
<a name="l01056"></a>01056             regionEndCoors = regionStartCoors  + regionLengths - 1;
<a name="l01057"></a>01057             regionStrandTimes = [regions(: ,2:end) ones(size(regions, 1), size(positionsStrands,2) - size(regions, 2))];
<a name="l01058"></a>01058             
<a name="l01059"></a>01059             startCoors = mod(positionsStrands(:, 1) + min(0, lengths+1) - 1, this.sequenceLen) +1;
<a name="l01060"></a>01060             endCoors = startCoors + abs(lengths) - 1;
<a name="l01061"></a>01061             strandTimes = [positionsStrands(: ,2:end) ones(size(positionsStrands, 1), size(regions, 2) - size(positionsStrands,2))];
<a name="l01062"></a>01062             idxs = (1:size(positionsStrands, 1))&#39;;
<a name="l01063"></a>01063             
<a name="l01064"></a>01064             tmpIdxs = find(endCoors &gt; this.sequenceLen);
<a name="l01065"></a>01065             strandTimes = [strandTimes; strandTimes(tmpIdxs, :)];
<a name="l01066"></a>01066             startCoors = [startCoors; max(1, startCoors(tmpIdxs) - this.sequenceLen)];
<a name="l01067"></a>01067             endCoors = [endCoors; endCoors(tmpIdxs) - this.sequenceLen];
<a name="l01068"></a>01068             endCoors(tmpIdxs) = this.sequenceLen;
<a name="l01069"></a>01069             idxs = [idxs; idxs(tmpIdxs)];
<a name="l01070"></a>01070             
<a name="l01071"></a>01071             tmpIdxs = find(startCoors &lt; 0);
<a name="l01072"></a>01072             strandTimes = [strandTimes; strandTimes(tmpIdxs, :)];
<a name="l01073"></a>01073             startCoors = [startCoors; startCoors(tmpIdxs) + this.sequenceLen];
<a name="l01074"></a>01074             endCoors = [endCoors; min(this.sequenceLen, endCoors(tmpIdxs) + this.sequenceLen)];
<a name="l01075"></a>01075             startCoors(tmpIdxs) = 1;
<a name="l01076"></a>01076             idxs = [idxs; idxs(tmpIdxs)];
<a name="l01077"></a>01077             
<a name="l01078"></a>01078             extents = zeros(size(positionsStrands, 1), 1);
<a name="l01079"></a>01079             for i = 1:numel(startCoors)
<a name="l01080"></a>01080                 if lengths(idxs(i)) &gt; 0
<a name="l01081"></a>01081                     if i &gt; size(positionsStrands, 1) &amp;&amp; extents(idxs(i)) &lt; this.sequenceLen - startCoors(idxs(i)) + 1
<a name="l01082"></a>01082                         continue;
<a name="l01083"></a>01083                     end
<a name="l01084"></a>01084                     
<a name="l01085"></a>01085                     tmpIdxs = find(...
<a name="l01086"></a>01086                         startCoors(i) &gt;= regionStartCoors &amp; ...
<a name="l01087"></a>01087                         startCoors(i) &lt;= regionEndCoors &amp; ...
<a name="l01088"></a>01088                         ismember(regionStrandTimes, strandTimes(i, :), &#39;rows&#39;), 1, &#39;first&#39;);
<a name="l01089"></a>01089                     
<a name="l01090"></a>01090                     if ~isempty(tmpIdxs)
<a name="l01091"></a>01091                         extents(idxs(i)) = extents(idxs(i)) + min(regionEndCoors(tmpIdxs), endCoors(i)) - startCoors(i) + 1;
<a name="l01092"></a>01092                     end
<a name="l01093"></a>01093                 else
<a name="l01094"></a>01094                     if i &gt; size(positionsStrands, 1) &amp;&amp; -extents(idxs(i)) &lt; endCoors(idxs(i))
<a name="l01095"></a>01095                         continue;
<a name="l01096"></a>01096                     end
<a name="l01097"></a>01097                     
<a name="l01098"></a>01098                     tmpIdxs = find(...
<a name="l01099"></a>01099                         endCoors(i) &gt;= regionStartCoors &amp; ...
<a name="l01100"></a>01100                         endCoors(i) &lt;= regionEndCoors &amp; ...
<a name="l01101"></a>01101                         ismember(regionStrandTimes, strandTimes(i, :), &#39;rows&#39;), 1, &#39;first&#39;);
<a name="l01102"></a>01102                     
<a name="l01103"></a>01103                     if ~isempty(tmpIdxs)
<a name="l01104"></a>01104                         extents(idxs(i)) = extents(idxs(i)) - (endCoors(i) - max(regionStartCoors(tmpIdxs), startCoors(i)) + 1);
<a name="l01105"></a>01105                     end
<a name="l01106"></a>01106                 end
<a name="l01107"></a>01107             end
<a name="l01108"></a>01108             
<a name="l01109"></a>01109             if returnExtent
<a name="l01110"></a>01110                 tfs = true(size(positionsStrands, 1), 1);
<a name="l01111"></a>01111             else
<a name="l01112"></a>01112                 tfs = extents == lengths;
<a name="l01113"></a>01113             end
<a name="l01114"></a>01114             
<a name="l01115"></a>01115             idxs = reshape(find(tfs), [], 1);
<a name="l01116"></a>01116             positionsStrands = positionsStrands(idxs, :);
<a name="l01117"></a>01117             lengths = extents(idxs, :);
<a name="l01118"></a>01118         end
<a name="l01119"></a>01119 
<a name="l01120"></a>01120         %lengths must be non-negative integer
<a name="l01121"></a>01121         %releasableMonomerIndexs and releasableComplexIndexs must be sorted
<a name="l01122"></a>01122         function [tfs, idxs, positionsStrands, lengths, monomers, complexs] = isRegionProteinFree(this, ...
<a name="l01123"></a>01123                 positionsStrands, lengths, returnExtent, releasableMonomerIndexs, releasableComplexIndexs, bothStrands, allStrands)
<a name="l01124"></a>01124             if isempty(positionsStrands)
<a name="l01125"></a>01125                 tfs = false(0, 1);
<a name="l01126"></a>01126                 idxs = zeros(0, 1);
<a name="l01127"></a>01127                 lengths = zeros(0, 1);
<a name="l01128"></a>01128                 monomers = zeros(0, 0);
<a name="l01129"></a>01129                 complexs = zeros(0, 0);
<a name="l01130"></a>01130                 return;
<a name="l01131"></a>01131             end
<a name="l01132"></a>01132             
<a name="l01133"></a>01133             if numel(lengths) == 1
<a name="l01134"></a>01134                 lengths = lengths(ones(size(positionsStrands, 1), 1), 1);
<a name="l01135"></a>01135             end
<a name="l01136"></a>01136             if nargin &lt; 8
<a name="l01137"></a>01137                 allStrands = false;
<a name="l01138"></a>01138             end
<a name="l01139"></a>01139             
<a name="l01140"></a>01140             startCoors = mod(positionsStrands(:, 1) + min(0, lengths+1) - 1, this.sequenceLen) + 1;
<a name="l01141"></a>01141             endCoors = startCoors + abs(lengths) - 1;
<a name="l01142"></a>01142             strnds = positionsStrands(:, 2);
<a name="l01143"></a>01143             if bothStrands
<a name="l01144"></a>01144                 strnds = ceil(strnds/2);
<a name="l01145"></a>01145             end
<a name="l01146"></a>01146             if allStrands
<a name="l01147"></a>01147                 strnds(:) = 1;
<a name="l01148"></a>01148             end
<a name="l01149"></a>01149             idxs = (1:size(positionsStrands, 1))&#39;;
<a name="l01150"></a>01150             
<a name="l01151"></a>01151             tmpIdxs = find(endCoors &gt; this.sequenceLen);
<a name="l01152"></a>01152             startCoors = [startCoors; max(1, startCoors(tmpIdxs) - this.sequenceLen)];
<a name="l01153"></a>01153             endCoors = [endCoors; endCoors(tmpIdxs) - this.sequenceLen];
<a name="l01154"></a>01154             endCoors(tmpIdxs) = this.sequenceLen;
<a name="l01155"></a>01155             strnds = [strnds; strnds(tmpIdxs, :)];
<a name="l01156"></a>01156             idxs = [idxs; idxs(tmpIdxs)];
<a name="l01157"></a>01157             
<a name="l01158"></a>01158             tmpIdxs = find(startCoors &lt; 0);
<a name="l01159"></a>01159             startCoors = [startCoors; startCoors(tmpIdxs) + this.sequenceLen];
<a name="l01160"></a>01160             endCoors = [endCoors; min(this.sequenceLen, endCoors(tmpIdxs) + this.sequenceLen)];
<a name="l01161"></a>01161             startCoors(tmpIdxs) = 1;
<a name="l01162"></a>01162             strnds = [strnds; strnds(tmpIdxs, :)];
<a name="l01163"></a>01163             idxs = [idxs; idxs(tmpIdxs)];
<a name="l01164"></a>01164             
<a name="l01165"></a>01165             %initialize output
<a name="l01166"></a>01166             extents  = abs(lengths);
<a name="l01167"></a>01167             monomers = sparse(size(positionsStrands, 1), max(abs([lengths; 0])));
<a name="l01168"></a>01168             complexs = sparse(size(positionsStrands, 1), max(abs([lengths; 0])));
<a name="l01169"></a>01169             
<a name="l01170"></a>01170             %bound monomers
<a name="l01171"></a>01171             [subs, vals] = find(this.monomerBoundSites);
<a name="l01172"></a>01172             if ~bothStrands
<a name="l01173"></a>01173                 dsTfs = this.monomerDNAFootprintBindingStrandedness(vals) == this.dnaStrandedness_dsDNA;
<a name="l01174"></a>01174                 subs = [
<a name="l01175"></a>01175                     subs(~dsTfs, :)
<a name="l01176"></a>01176                     subs( dsTfs, 1) 2*ceil(subs(dsTfs, 2)/2)-1
<a name="l01177"></a>01177                     subs( dsTfs, 1) 2*ceil(subs(dsTfs, 2)/2)
<a name="l01178"></a>01178                     ];
<a name="l01179"></a>01179                 vals = [
<a name="l01180"></a>01180                     vals(~dsTfs)
<a name="l01181"></a>01181                     vals( dsTfs)
<a name="l01182"></a>01182                     vals( dsTfs)
<a name="l01183"></a>01183                     ];
<a name="l01184"></a>01184                 [subs, order] = edu.stanford.covert.util.<a class="code" href="class_sparse_mat.html">SparseMat</a>.sort_subs(subs, [this.sequenceLen this.nCompartments]);
<a name="l01185"></a>01185                 vals = vals(order, :);
<a name="l01186"></a>01186             end
<a name="l01187"></a>01187             if allStrands
<a name="l01188"></a>01188                 tfs = ~ismembc(vals, this.monomerIndexs_replisome);
<a name="l01189"></a>01189                 subs = subs(tfs, :);
<a name="l01190"></a>01190                 vals = vals(tfs);
<a name="l01191"></a>01191             end
<a name="l01192"></a>01192             monomerStarts = subs(:, 1);
<a name="l01193"></a>01193             monomerEnds   = monomerStarts + this.monomerDNAFootprints(vals, :) - 1;
<a name="l01194"></a>01194             monomerStrnds = subs(:, 2);
<a name="l01195"></a>01195             if bothStrands
<a name="l01196"></a>01196                 monomerStrnds = ceil(monomerStrnds/2);
<a name="l01197"></a>01197             end
<a name="l01198"></a>01198             if allStrands
<a name="l01199"></a>01199                 monomerStrnds(:) = 1;
<a name="l01200"></a>01200             end
<a name="l01201"></a>01201             
<a name="l01202"></a>01202             tmpIdxs = find(monomerEnds &gt; this.sequenceLen);
<a name="l01203"></a>01203             monomerStarts = [monomerStarts; ones(numel(tmpIdxs), 1)];
<a name="l01204"></a>01204             monomerEnds   = [monomerEnds;   monomerEnds(tmpIdxs, :) - this.sequenceLen];
<a name="l01205"></a>01205             monomerStrnds = [monomerStrnds; monomerStrnds(tmpIdxs, :)];
<a name="l01206"></a>01206             vals = [vals; vals(tmpIdxs, :)];
<a name="l01207"></a>01207             
<a name="l01208"></a>01208             for i = 1:numel(startCoors)
<a name="l01209"></a>01209                 monMask = ...
<a name="l01210"></a>01210                     (monomerStarts &gt;= startCoors(i) &amp; monomerStarts &lt;= endCoors(i)) | ...
<a name="l01211"></a>01211                     (monomerEnds &gt;= startCoors(i) &amp; monomerEnds &lt;= endCoors(i)) | ...
<a name="l01212"></a>01212                     (monomerStarts &lt;= startCoors(i) &amp; monomerEnds &gt;= endCoors(i));
<a name="l01213"></a>01213                 tmpIdxs = find(monMask);
<a name="l01214"></a>01214                 if isempty(tmpIdxs); continue; end;
<a name="l01215"></a>01215                 
<a name="l01216"></a>01216                 tmpIdxs = tmpIdxs(monomerStrnds(monMask, 1) ==  strnds(i, 1));
<a name="l01217"></a>01217                 if isempty(tmpIdxs); continue; end;
<a name="l01218"></a>01218                 
<a name="l01219"></a>01219                 if lengths(idxs(i)) &gt; 0
<a name="l01220"></a>01220                     if i &lt;= size(positionsStrands, 1)
<a name="l01221"></a>01221                         monomerPos = monomerStarts(tmpIdxs) - startCoors(i) + 1;
<a name="l01222"></a>01222                     else
<a name="l01223"></a>01223                         monomerPos = monomerStarts(tmpIdxs) - startCoors(i) + 1 + (this.sequenceLen-positionsStrands(idxs(i), 1));
<a name="l01224"></a>01224                     end
<a name="l01225"></a>01225                 else
<a name="l01226"></a>01226                     if i &lt;= size(positionsStrands, 1)
<a name="l01227"></a>01227                         monomerPos = endCoors(i) - monomerEnds(tmpIdxs) + 1;
<a name="l01228"></a>01228                     else
<a name="l01229"></a>01229                         monomerPos = endCoors(i) - monomerEnds(tmpIdxs) + 1 + positionsStrands(idxs(i), 1);
<a name="l01230"></a>01230                     end
<a name="l01231"></a>01231                 end
<a name="l01232"></a>01232                 monomerPos = max(monomerPos, 1);
<a name="l01233"></a>01233                 
<a name="l01234"></a>01234                 extents(idxs(i)) = min([
<a name="l01235"></a>01235                     extents(idxs(i));
<a name="l01236"></a>01236                     monomerPos(~ismembc(vals(tmpIdxs), releasableMonomerIndexs))-1]);
<a name="l01237"></a>01237                 
<a name="l01238"></a>01238                 monomers(idxs(i), monomerPos) = vals(tmpIdxs); %<span class="preprocessor">#ok&lt;SPRIX&gt;</span>
<a name="l01239"></a>01239 <span class="preprocessor"></span>            end
<a name="l01240"></a>01240             
<a name="l01241"></a>01241             %bound complexes
<a name="l01242"></a>01242             [subs, vals] = find(this.complexBoundSites);
<a name="l01243"></a>01243             <span class="keywordflow">if</span> ~bothStrands
<a name="l01244"></a>01244                 dsTfs = this.complexDNAFootprintBindingStrandedness(vals) == this.dnaStrandedness_dsDNA;
<a name="l01245"></a>01245                 subs = [
<a name="l01246"></a>01246                     subs(~dsTfs, :)
<a name="l01247"></a>01247                     subs( dsTfs, 1) 2*ceil(subs(dsTfs, 2)/2)-1
<a name="l01248"></a>01248                     subs( dsTfs, 1) 2*ceil(subs(dsTfs, 2)/2)
<a name="l01249"></a>01249                     ];
<a name="l01250"></a>01250                 vals = [
<a name="l01251"></a>01251                     vals(~dsTfs)
<a name="l01252"></a>01252                     vals( dsTfs)
<a name="l01253"></a>01253                     vals( dsTfs)
<a name="l01254"></a>01254                     ];
<a name="l01255"></a>01255                 [subs, order] = edu.stanford.covert.util.SparseMat.sort_subs(subs, [this.sequenceLen this.nCompartments]);
<a name="l01256"></a>01256                 vals = vals(order, :);
<a name="l01257"></a>01257             end
<a name="l01258"></a>01258             <span class="keywordflow">if</span> allStrands
<a name="l01259"></a>01259                 tfs = ~ismembc(vals, this.complexIndexs_replisome);
<a name="l01260"></a>01260                 subs = subs(tfs, :);
<a name="l01261"></a>01261                 vals = vals(tfs);
<a name="l01262"></a>01262             end
<a name="l01263"></a>01263             complexStarts = subs(:, 1);
<a name="l01264"></a>01264             complexEnds   = complexStarts + this.complexDNAFootprints(vals, :) - 1;
<a name="l01265"></a>01265             complexStrnds = subs(:, 2);
<a name="l01266"></a>01266             <span class="keywordflow">if</span> bothStrands
<a name="l01267"></a>01267                 complexStrnds = ceil(complexStrnds/2);
<a name="l01268"></a>01268             end
<a name="l01269"></a>01269             <span class="keywordflow">if</span> allStrands
<a name="l01270"></a>01270                 complexStrnds(:) = 1;
<a name="l01271"></a>01271             end
<a name="l01272"></a>01272             
<a name="l01273"></a>01273             tmpIdxs = find(complexEnds &gt; this.sequenceLen);
<a name="l01274"></a>01274             complexStarts = [complexStarts; ones(numel(tmpIdxs), 1)];
<a name="l01275"></a>01275             complexEnds   = [complexEnds;   complexEnds(tmpIdxs, :) - this.sequenceLen];
<a name="l01276"></a>01276             complexStrnds = [complexStrnds; complexStrnds(tmpIdxs, :)];
<a name="l01277"></a>01277             vals = [vals; vals(tmpIdxs, :)];
<a name="l01278"></a>01278             
<a name="l01279"></a>01279             <span class="keywordflow">for</span> i = 1:numel(startCoors)
<a name="l01280"></a>01280                 comMask = ...
<a name="l01281"></a>01281                     (complexStarts &gt;= startCoors(i) &amp; complexStarts &lt;= endCoors(i)) | ...
<a name="l01282"></a>01282                     (complexEnds &gt;= startCoors(i) &amp; complexEnds &lt;= endCoors(i)) | ...
<a name="l01283"></a>01283                     (complexStarts &lt;= startCoors(i) &amp; complexEnds &gt;= endCoors(i));
<a name="l01284"></a>01284                 tmpIdxs = find(comMask);
<a name="l01285"></a>01285                 if isempty(tmpIdxs); continue; end;
<a name="l01286"></a>01286                 
<a name="l01287"></a>01287                 tmpIdxs = tmpIdxs(complexStrnds(comMask, 1) ==  strnds(i, 1));
<a name="l01288"></a>01288                 if isempty(tmpIdxs); continue; end;
<a name="l01289"></a>01289                 
<a name="l01290"></a>01290                 if lengths(idxs(i)) &gt; 0
<a name="l01291"></a>01291                     if i &lt;= size(positionsStrands, 1)
<a name="l01292"></a>01292                         complexPos = complexStarts(tmpIdxs) - startCoors(i) + 1;
<a name="l01293"></a>01293                     else
<a name="l01294"></a>01294                         complexPos = complexStarts(tmpIdxs) - startCoors(i) + 1 + (this.sequenceLen-positionsStrands(idxs(i), 1));
<a name="l01295"></a>01295                     end
<a name="l01296"></a>01296                 else
<a name="l01297"></a>01297                     if i &lt;= size(positionsStrands, 1)
<a name="l01298"></a>01298                         complexPos = endCoors(i) - complexEnds(tmpIdxs) + 1;
<a name="l01299"></a>01299                     else
<a name="l01300"></a>01300                         complexPos = endCoors(i) - complexEnds(tmpIdxs) + 1 + positionsStrands(idxs(i), 1);
<a name="l01301"></a>01301                     end
<a name="l01302"></a>01302                 end
<a name="l01303"></a>01303                 complexPos = max(complexPos, 1);
<a name="l01304"></a>01304                 
<a name="l01305"></a>01305                 extents(idxs(i)) = min([
<a name="l01306"></a>01306                     extents(idxs(i));
<a name="l01307"></a>01307                     complexPos(~ismembc(vals(tmpIdxs), releasableComplexIndexs))-1]);
<a name="l01308"></a>01308                 
<a name="l01309"></a>01309                 complexs(idxs(i), complexPos) = vals(tmpIdxs); %<span class="preprocessor">#ok&lt;SPRIX&gt;</span>
<a name="l01310"></a>01310 <span class="preprocessor"></span>            end
<a name="l01311"></a>01311             
<a name="l01312"></a>01312             %format output
<a name="l01313"></a>01313             extents = sign(lengths) .* extents;
<a name="l01314"></a>01314             <span class="keywordflow">if</span> returnExtent
<a name="l01315"></a>01315                 tfs = <span class="keyword">true</span>(size(positionsStrands, 1), 1);
<a name="l01316"></a>01316             <span class="keywordflow">else</span>
<a name="l01317"></a>01317                 tfs = extents == lengths;
<a name="l01318"></a>01318             end
<a name="l01319"></a>01319             idxs = reshape(find(tfs), [], 1);
<a name="l01320"></a>01320             positionsStrands = positionsStrands(idxs, :);
<a name="l01321"></a>01321             lengths = extents(idxs, :);
<a name="l01322"></a>01322         end
<a name="l01323"></a>01323         
<a name="l01324"></a>01324         %lengths must be non-negative integer
<a name="l01325"></a>01325         function [tfs, idxs, positionsStrands, lengths] = isRegionUndamaged(this, ...
<a name="l01326"></a>01326                 positionsStrands, lengths, isEitherStrandDamaged, ignoreDamageFilter, returnExtent, isAnyStrandDamaged)
<a name="l01327"></a>01327             if isempty(positionsStrands)
<a name="l01328"></a>01328                 tfs = false(0, 1);
<a name="l01329"></a>01329                 idxs = zeros(0, 1);
<a name="l01330"></a>01330                 lengths = zeros(0, 1);
<a name="l01331"></a>01331                 <span class="keywordflow">return</span>;
<a name="l01332"></a>01332             end
<a name="l01333"></a>01333             
<a name="l01334"></a>01334             <span class="keywordflow">if</span> numel(lengths) == 1
<a name="l01335"></a>01335                 lengths = lengths(ones(size(positionsStrands, 1), 1), 1);
<a name="l01336"></a>01336             end
<a name="l01337"></a>01337             <span class="keywordflow">if</span> nargin &lt; 7
<a name="l01338"></a>01338                 isAnyStrandDamaged = <span class="keyword">false</span>;
<a name="l01339"></a>01339             end
<a name="l01340"></a>01340             
<a name="l01341"></a>01341             [damagedPosStrnds, damages] = find(this.damagedSites);
<a name="l01342"></a>01342             <span class="keywordflow">if</span> isempty(damages)
<a name="l01343"></a>01343                 tfs = true(size(lengths));
<a name="l01344"></a>01344                 idxs = (1:numel(lengths))&#39;;
<a name="l01345"></a>01345                 return;
<a name="l01346"></a>01346             end
<a name="l01347"></a>01347             
<a name="l01348"></a>01348             if isempty(ignoreDamageFilter)
<a name="l01349"></a>01349                 ignoreDamageFilter = zeros(size(positionsStrands, 1), 0);
<a name="l01350"></a>01350             elseif size(ignoreDamageFilter, 1) &lt;= 1
<a name="l01351"></a>01351                 ignoreDamageFilter = reshape(ignoreDamageFilter(ones(size(positionsStrands, 1), 1), :), size(positionsStrands, 1), []);
<a name="l01352"></a>01352             end
<a name="l01353"></a>01353                         
<a name="l01354"></a>01354             damagedPositions   = damagedPosStrnds(:, 1);
<a name="l01355"></a>01355             damagedStrandTimes = [damagedPosStrnds(:, 2:end) ones(size(damagedPosStrnds, 1), size(positionsStrands, 2) - size(damagedPosStrnds, 2))];
<a name="l01356"></a>01356             strandTimes        = [positionsStrands(:, 2:end) ones(size(positionsStrands, 1), size(damagedPosStrnds, 2) - size(positionsStrands, 2))];
<a name="l01357"></a>01357             
<a name="l01358"></a>01358             if isAnyStrandDamaged
<a name="l01359"></a>01359                 strandTimes(:, 1) = 1;
<a name="l01360"></a>01360                 damagedStrandTimes(:, 1) = 1;
<a name="l01361"></a>01361             elseif isEitherStrandDamaged
<a name="l01362"></a>01362                 strandTimes(:, 1) = ceil(strandTimes(:, 1) / 2);
<a name="l01363"></a>01363                 damagedStrandTimes(:, 1) = ceil(damagedStrandTimes(:, 1) / 2);
<a name="l01364"></a>01364             end
<a name="l01365"></a>01365                         
<a name="l01366"></a>01366             startPositions = mod(positionsStrands(:, 1) + min(0, lengths+1) - 1, this.sequenceLen) + 1;
<a name="l01367"></a>01367             endPositions   = startPositions + abs(lengths) - 1;
<a name="l01368"></a>01368             idxs = (1:size(positionsStrands,1))&#39;;
<a name="l01369"></a>01369             
<a name="l01370"></a>01370             tmpIdxs = find(endPositions &gt; this.sequenceLen);
<a name="l01371"></a>01371             strandTimes = [strandTimes; strandTimes(tmpIdxs)];
<a name="l01372"></a>01372             startPositions = [startPositions; max(1, startPositions(tmpIdxs) - this.sequenceLen)];
<a name="l01373"></a>01373             endPositions = [endPositions; endPositions(tmpIdxs) - this.sequenceLen];
<a name="l01374"></a>01374             endPositions(tmpIdxs) = this.sequenceLen;
<a name="l01375"></a>01375             idxs = [idxs; idxs(tmpIdxs)];
<a name="l01376"></a>01376             
<a name="l01377"></a>01377             tmpIdxs = find(startPositions &lt; 0);
<a name="l01378"></a>01378             strandTimes = [strandTimes; strandTimes(tmpIdxs)];
<a name="l01379"></a>01379             startPositions = [startPositions; startPositions(tmpIdxs) + this.sequenceLen];
<a name="l01380"></a>01380             endPositions = [endPositions; min(this.sequenceLen, endPositions(tmpIdxs) + this.sequenceLen)];
<a name="l01381"></a>01381             startPositions(tmpIdxs) = 1;
<a name="l01382"></a>01382             idxs = [idxs; idxs(tmpIdxs)];
<a name="l01383"></a>01383             
<a name="l01384"></a>01384             extents = zeros(size(positionsStrands,1), 1);
<a name="l01385"></a>01385             for i = 1:numel(startPositions)
<a name="l01386"></a>01386                 tmpIdxs = ...
<a name="l01387"></a>01387                     damagedPositions &gt;= startPositions(i, 1) &amp; ...
<a name="l01388"></a>01388                     damagedPositions &lt;= endPositions(i, 1) &amp; ...
<a name="l01389"></a>01389                     ismember(damagedStrandTimes, strandTimes(i, :), &#39;rows&#39;);
<a name="l01390"></a>01390                 
<a name="l01391"></a>01391                 if lengths(idxs(i)) &gt; 0
<a name="l01392"></a>01392                     if i &gt; size(positionsStrands, 1) &amp;&amp; extents(idxs(i)) &lt; this.sequenceLen - startPositions(idxs(i)) + 1
<a name="l01393"></a>01393                         continue;
<a name="l01394"></a>01394                     end
<a name="l01395"></a>01395                     
<a name="l01396"></a>01396                     if i &lt;= size(positionsStrands, 1)
<a name="l01397"></a>01397                         tmpIgnoreDamageFilter = ignoreDamageFilter(idxs(i), :);
<a name="l01398"></a>01398                     else
<a name="l01399"></a>01399                         tmpIgnoreDamageFilter = ignoreDamageFilter(idxs(i), :) - (this.sequenceLen - startPositions(idxs(i)) + 1);
<a name="l01400"></a>01400                     end
<a name="l01401"></a>01401                     
<a name="l01402"></a>01402                     extent = min(setdiff(damagedPositions(tmpIdxs) - startPositions(i) + 1, tmpIgnoreDamageFilter)) - 1;
<a name="l01403"></a>01403                     if isempty(extent)
<a name="l01404"></a>01404                         extent = endPositions(i) - startPositions(i) + 1;
<a name="l01405"></a>01405                     end
<a name="l01406"></a>01406                     extents(idxs(i)) = extents(idxs(i)) + extent;
<a name="l01407"></a>01407                 else
<a name="l01408"></a>01408                     if i &lt;= size(positionsStrands, 1)
<a name="l01409"></a>01409                         tmpIgnoreDamageFilter = ignoreDamageFilter(idxs(i), :);
<a name="l01410"></a>01410                     else
<a name="l01411"></a>01411                         tmpIgnoreDamageFilter = ignoreDamageFilter(idxs(i), :) + positionsStrands(idxs(i), 1);
<a name="l01412"></a>01412                     end
<a name="l01413"></a>01413                     
<a name="l01414"></a>01414                     extent = min(setdiff(endPositions(i) - damagedPositions(tmpIdxs) + 1, tmpIgnoreDamageFilter - lengths(idxs(i)) - 1)) - 1;
<a name="l01415"></a>01415                     if isempty(extent)
<a name="l01416"></a>01416                         extents(idxs(i)) = extents(idxs(i)) -(endPositions(i) - startPositions(i) + 1);
<a name="l01417"></a>01417                     else
<a name="l01418"></a>01418                         extents(idxs(i)) = extents(idxs(i)) - extent;
<a name="l01419"></a>01419                     end
<a name="l01420"></a>01420                 end
<a name="l01421"></a>01421             end
<a name="l01422"></a>01422             
<a name="l01423"></a>01423             if returnExtent
<a name="l01424"></a>01424                 tfs = true(size(positionsStrands, 1), 1);
<a name="l01425"></a>01425             else
<a name="l01426"></a>01426                 tfs = extents == lengths;
<a name="l01427"></a>01427             end
<a name="l01428"></a>01428             idxs = reshape(find(tfs), [], 1);
<a name="l01429"></a>01429             positionsStrands = positionsStrands(idxs, :);
<a name="l01430"></a>01430             lengths = extents(idxs, :);
<a name="l01431"></a>01431         end
<a name="l01432"></a>01432     end
<a name="l01433"></a>01433     
<a name="l01434"></a>01434     %additional private methods used to query state
<a name="l01435"></a>01435     methods
<a name="l01436"></a>01436         %Converts from the base-pair centric view of the chromosomes that this
<a name="l01437"></a>01437         %class uses to a strand-centric view where each column represents a
<a name="l01438"></a>01438         %single strand.
<a name="l01439"></a>01439         function varargout = getStrandView(this, outputs)
<a name="l01440"></a>01440             import edu.stanford.covert.util.<a class="code" href="class_circular_sparse_mat.html">CircularSparseMat</a>;
<a name="l01441"></a>01441             
<a name="l01442"></a>01442             if nargin &lt; 2
<a name="l01443"></a>01443                 outputs = {
<a name="l01444"></a>01444                     <span class="stringliteral">&#39;polymerizedRegions&#39;</span>;
<a name="l01445"></a>01445                     <span class="stringliteral">&#39;monomerBoundSites&#39;</span>;
<a name="l01446"></a>01446                     <span class="stringliteral">&#39;complexBoundSites&#39;</span>;
<a name="l01447"></a>01447                     <span class="stringliteral">&#39;gapSites&#39;</span>;
<a name="l01448"></a>01448                     <span class="stringliteral">&#39;abasicSites&#39;</span>;
<a name="l01449"></a>01449                     <span class="stringliteral">&#39;damagedSugarPhosphates&#39;</span>;
<a name="l01450"></a>01450                     <span class="stringliteral">&#39;damagedBases&#39;</span>;
<a name="l01451"></a>01451                     <span class="stringliteral">&#39;intrastrandCrossLinks&#39;</span>;
<a name="l01452"></a>01452                     <span class="stringliteral">&#39;strandBreaks&#39;</span>;
<a name="l01453"></a>01453                     <span class="stringliteral">&#39;hollidayJunctions&#39;</span>;
<a name="l01454"></a>01454                     };
<a name="l01455"></a>01455             end
<a name="l01456"></a>01456             <span class="keywordflow">if</span> ~iscell(outputs)
<a name="l01457"></a>01457                 outputs = {outputs};
<a name="l01458"></a>01458             end
<a name="l01459"></a>01459             <span class="keywordflow">if</span> numel(outputs) &lt; nargout
<a name="l01460"></a>01460                 <span class="keywordflow">throw</span>(MException(<span class="stringliteral">&#39;Chromosome:tooManyOutputs&#39;</span>, <span class="stringliteral">&#39;Too many outputs requested&#39;</span>));
<a name="l01461"></a>01461             end
<a name="l01462"></a>01462             
<a name="l01463"></a>01463             varargout = cell(nargout, 1);            
<a name="l01464"></a>01464             <span class="keywordflow">for</span> i = 1:nargout
<a name="l01465"></a>01465                 tmp = this.(outputs{i});
<a name="l01466"></a>01466                 <span class="keywordflow">switch</span> outputs{i}
<a name="l01467"></a>01467                     <span class="keywordflow">case</span> <span class="stringliteral">&#39;polymerizedRegions&#39;</span>
<a name="l01468"></a>01468                         [positionsStrands, lengths] = find(this.polymerizedRegions);
<a name="l01469"></a>01469                         positionsStrands = [positionsStrands ones(size(positionsStrands,1), 3-size(positionsStrands,2))];
<a name="l01470"></a>01470                         idx1 = find(positionsStrands(:,2) == this.strandIndexs_negative(1));
<a name="l01471"></a>01471                         idx2 = find(positionsStrands(:,2) == this.strandIndexs_negative(2));
<a name="l01472"></a>01472                         
<a name="l01473"></a>01473                         starts1 = positionsStrands(idx1, 1);
<a name="l01474"></a>01474                         starts2 = positionsStrands(idx2, 1);
<a name="l01475"></a>01475                         ends1 = starts1 + lengths(idx1) - 1;
<a name="l01476"></a>01476                         ends2 = starts2 + lengths(idx2) - 1;
<a name="l01477"></a>01477                         times1 = positionsStrands(idx1, 3:end);
<a name="l01478"></a>01478                         times2 = positionsStrands(idx2, 3:end);
<a name="l01479"></a>01479                         
<a name="l01480"></a>01480                         tmpStarts2 = zeros(0,1);
<a name="l01481"></a>01481                         tmpEnds2 = zeros(0,1);
<a name="l01482"></a>01482                         tmpTimes2 = zeros(0,size(times2,2));
<a name="l01483"></a>01483                         <span class="keywordflow">for</span> j = 1:numel(idx2)
<a name="l01484"></a>01484                             idx = find(...
<a name="l01485"></a>01485                                 ((starts1 &gt;= starts2(j) &amp; starts1 &lt;= ends2(j)) | ...
<a name="l01486"></a>01486                                 (ends1    &gt;= starts2(j) &amp; ends1   &lt;= ends2(j)) | ...
<a name="l01487"></a>01487                                 (starts1  &lt;= starts2(j) &amp; ends1   &gt;= ends2(j))) &amp; ...
<a name="l01488"></a>01488                                 all(times1 == times2(j, :), 2));                                                                                   
<a name="l01489"></a>01489                             
<a name="l01490"></a>01490                             tmpStarts2 = [tmpStarts2;
<a name="l01491"></a>01491                                 max(starts1(idx), starts2(j))];
<a name="l01492"></a>01492                             tmpEnds2 = [tmpEnds2;
<a name="l01493"></a>01493                                 min(ends1(idx), ends2(j))];
<a name="l01494"></a>01494                             tmpTimes2 = [tmpTimes2;
<a name="l01495"></a>01495                                 times1(idx, :)];
<a name="l01496"></a>01496                             
<a name="l01497"></a>01497                             starts1 = [starts1(setdiff(1:end, idx));
<a name="l01498"></a>01498                                 min([starts1(idx); starts2(j)])];
<a name="l01499"></a>01499                             ends1 = [ends1(setdiff(1:end, idx));
<a name="l01500"></a>01500                                 max([ends1(idx); ends2(j)])];
<a name="l01501"></a>01501                             times1 = [times1(setdiff(1:end, idx), :);
<a name="l01502"></a>01502                                 times2(j)];
<a name="l01503"></a>01503                         end
<a name="l01504"></a>01504                         
<a name="l01505"></a>01505                         tmpPosStrnds = [positionsStrands(setdiff(1:end, [idx1; idx2]), :);
<a name="l01506"></a>01506                             starts1 this.strandIndexs_negative(ones(numel(starts1), 1)) times1;
<a name="l01507"></a>01507                             tmpStarts2 this.strandIndexs_negative(2 * ones(numel(tmpStarts2), 1)) tmpTimes2];
<a name="l01508"></a>01508                         tmpLengths = [lengths(setdiff(1:end, [idx1; idx2]), :);
<a name="l01509"></a>01509                             ends1 - starts1 + 1;
<a name="l01510"></a>01510                             tmpEnds2 - tmpStarts2 + 1;];                        
<a name="l01511"></a>01511                         tmp = <a class="code" href="class_circular_sparse_mat.html">CircularSparseMat</a>(tmpPosStrnds, tmpLengths, size(tmp), 1);
<a name="l01512"></a>01512                         tmp = this.mergeAdjacentRegions(tmp);
<a name="l01513"></a>01513                     case &#39;linkingNumbers&#39;
<a name="l01514"></a>01514                         throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:tooLazy&#39;, &#39;You&#39;&#39;re going to have to write this yourself.&#39;));
<a name="l01515"></a>01515                     otherwise
<a name="l01516"></a>01516                         [positionsStrands, lengths] = find(this.polymerizedRegions(:, this.strandIndexs_negative(2), :));            
<a name="l01517"></a>01517                         [tmpPosStrnds, tmpVals] = find(tmp);
<a name="l01518"></a>01518                         
<a name="l01519"></a>01519                         positionsStrands = [positionsStrands ones(size(positionsStrands,1), 3-size(positionsStrands,2))];
<a name="l01520"></a>01520                         tmpPosStrnds = [tmpPosStrnds ones(size(tmpPosStrnds,1), 3-size(tmpPosStrnds,2))];
<a name="l01521"></a>01521                         for j = size(positionsStrands, 1)
<a name="l01522"></a>01522                             idx1 = ...
<a name="l01523"></a>01523                                 tmpPosStrnds(:, 1) &gt;= positionsStrands(j, 1) &amp; ...
<a name="l01524"></a>01524                                 tmpPosStrnds(:, 1) &lt;= positionsStrands(j, 1) + lengths(j)-1 &amp; ...
<a name="l01525"></a>01525                                 tmpPosStrnds(:, 2) == this.strandIndexs_negative(1) &amp; ...
<a name="l01526"></a>01526                                 all(tmpPosStrnds(:, 3:end) == positionsStrands(j, 3:end), 2);
<a name="l01527"></a>01527                             idx2 = ...
<a name="l01528"></a>01528                                 tmpPosStrnds(:, 1) &gt;= positionsStrands(j, 1) &amp; ...
<a name="l01529"></a>01529                                 tmpPosStrnds(:, 1) &lt;= positionsStrands(j, 1) + lengths(j)-1 &amp; ...
<a name="l01530"></a>01530                                 tmpPosStrnds(:, 2) == this.strandIndexs_negative(2) &amp; ...
<a name="l01531"></a>01531                                 all(tmpPosStrnds(:, 3:end) == positionsStrands(j, 3:end), 2);
<a name="l01532"></a>01532                             tmpPosStrnds(idx1, 2) = this.strandIndexs_negative(2);
<a name="l01533"></a>01533                             tmpPosStrnds(idx2, 2) = this.strandIndexs_negative(1);
<a name="l01534"></a>01534                         end
<a name="l01535"></a>01535                         tmp = <a class="code" href="class_circular_sparse_mat.html">CircularSparseMat</a>(tmpPosStrnds, tmpVals, size(tmp), 1);
<a name="l01536"></a>01536                 end
<a name="l01537"></a>01537                 varargout{i} = tmp;
<a name="l01538"></a>01538             end
<a name="l01539"></a>01539         end
<a name="l01540"></a>01540         
<a name="l01541"></a>01541         %Calculates the footprint of a group of proteins as the maximum of their
<a name="l01542"></a>01542         %individual footprints. Also calculates the number of bases that the
<a name="l01543"></a>01543         %footprint spans 3<span class="stringliteral">&#39;- and 5&#39;</span>- to the centroid base of the footprint.
<a name="l01544"></a>01544         function [footprint, footprint3Prime, footprint5Prime, bindingStrandedness, regionStrandedness] = getDNAFootprint(this, monomers, complexs)
<a name="l01545"></a>01545             footprint = max([1;
<a name="l01546"></a>01546                 this.monomerDNAFootprints(monomers);
<a name="l01547"></a>01547                 this.complexDNAFootprints(complexs)]);
<a name="l01548"></a>01548             
<a name="l01549"></a>01549             [footprint3Prime, footprint5Prime] = this.calculateFootprintOverhangs(footprint);
<a name="l01550"></a>01550             
<a name="l01551"></a>01551             bindingStrandedness = [this.monomerDNAFootprintBindingStrandedness(monomers); this.complexDNAFootprintBindingStrandedness(complexs)];
<a name="l01552"></a>01552             <span class="keywordflow">if</span> isempty(bindingStrandedness)
<a name="l01553"></a>01553                 bindingStrandedness = this.dnaStrandedness_dsDNA;
<a name="l01554"></a>01554             elseif ~isscalar(bindingStrandedness)
<a name="l01555"></a>01555                 if any(bindingStrandedness ~= bindingStrandedness(1))
<a name="l01556"></a>01556                     throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;,&#39;Footprints must be of a single strandedness&#39;));
<a name="l01557"></a>01557                 else
<a name="l01558"></a>01558                     bindingStrandedness = bindingStrandedness(1);
<a name="l01559"></a>01559                 end
<a name="l01560"></a>01560             end
<a name="l01561"></a>01561             
<a name="l01562"></a>01562             regionStrandedness = [this.monomerDNAFootprintRegionStrandedness(monomers); this.complexDNAFootprintRegionStrandedness(complexs)];
<a name="l01563"></a>01563             if isempty(regionStrandedness)
<a name="l01564"></a>01564                 regionStrandedness = this.dnaStrandedness_dsDNA;
<a name="l01565"></a>01565             elseif ~isscalar(regionStrandedness)
<a name="l01566"></a>01566                 if any(regionStrandedness ~= regionStrandedness(1))
<a name="l01567"></a>01567                     throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;,&#39;Footprints must be of a single strandedness&#39;));
<a name="l01568"></a>01568                 else
<a name="l01569"></a>01569                     regionStrandedness = regionStrandedness(1);
<a name="l01570"></a>01570                 end
<a name="l01571"></a>01571             end
<a name="l01572"></a>01572         end
<a name="l01573"></a>01573         
<a name="l01574"></a>01574         %return sorted releasableMonomerIndexs, releasableComplexIndexs
<a name="l01575"></a>01575         function [releasableMonomerIndexs, releasableComplexIndexs] = getReleasableProteins(this, bindingMonomers, bindingComplexs)
<a name="l01576"></a>01576             releasableMonomerIndexs = this.reactionBoundMonomer .* (...
<a name="l01577"></a>01577                 sum(this.reactionMonomerCatalysisMatrix(:, bindingMonomers), 2) + ...
<a name="l01578"></a>01578                 sum(this.reactionComplexCatalysisMatrix(:, bindingComplexs), 2) &gt;= ...
<a name="l01579"></a>01579                 this.reactionThresholds);
<a name="l01580"></a>01580             
<a name="l01581"></a>01581             if any(releasableMonomerIndexs)
<a name="l01582"></a>01582                 releasableMonomerIndexs = sort(releasableMonomerIndexs);
<a name="l01583"></a>01583                 if ~isempty(releasableMonomerIndexs)
<a name="l01584"></a>01584                     releasableMonomerIndexs = releasableMonomerIndexs([diff(releasableMonomerIndexs) ~= 0; true], 1);
<a name="l01585"></a>01585                 end
<a name="l01586"></a>01586             else
<a name="l01587"></a>01587                 releasableMonomerIndexs = 0;
<a name="l01588"></a>01588             end
<a name="l01589"></a>01589             
<a name="l01590"></a>01590             releasableComplexIndexs = this.reactionBoundComplex .* (...
<a name="l01591"></a>01591                 sum(this.reactionMonomerCatalysisMatrix(:, bindingMonomers), 2) + ...
<a name="l01592"></a>01592                 sum(this.reactionComplexCatalysisMatrix(:, bindingComplexs), 2) &gt;= ...
<a name="l01593"></a>01593                 this.reactionThresholds);
<a name="l01594"></a>01594             if any(releasableComplexIndexs)
<a name="l01595"></a>01595                 releasableComplexIndexs = sort(releasableComplexIndexs);
<a name="l01596"></a>01596                 if ~isempty(releasableComplexIndexs)
<a name="l01597"></a>01597                     releasableComplexIndexs = releasableComplexIndexs([diff(releasableComplexIndexs) ~= 0; true], 1);
<a name="l01598"></a>01598                 end
<a name="l01599"></a>01599             else
<a name="l01600"></a>01600                 releasableComplexIndexs = 0;
<a name="l01601"></a>01601             end
<a name="l01602"></a>01602         end
<a name="l01603"></a>01603         
<a name="l01604"></a>01604         %Estimates regions that are accessible to a given protein species. That is
<a name="l01605"></a>01605         %regions:
<a name="l01606"></a>01606         %- that are polymerized, and have the strandedness that the protein requires
<a name="l01607"></a>01607         %- that are not already bound by the specified protein species
<a name="l01608"></a>01608         function [rgnPosStrnds, rgnLens] = getAccessibleRegions(this, monomerIdx, complexIdx, checkRegionSupercoiled)
<a name="l01609"></a>01609             if nargin &lt; 4
<a name="l01610"></a>01610                 checkRegionSupercoiled = false;
<a name="l01611"></a>01611             end
<a name="l01612"></a>01612             
<a name="l01613"></a>01613             %find lengths and type of footprint
<a name="l01614"></a>01614             [dnaFtpt, ~, ~, dnaFtptBindingStrandedness, dnaFtptRegionStrandedness] = this.getDNAFootprint(monomerIdx, complexIdx);
<a name="l01615"></a>01615             
<a name="l01616"></a>01616             %initialize excluded regions
<a name="l01617"></a>01617             excPosStrnds = [];
<a name="l01618"></a>01618             excLens = [];
<a name="l01619"></a>01619             
<a name="l01620"></a>01620             %exclude regions which are bound by proteins
<a name="l01621"></a>01621             [releasableMonomerIndexs, releasableComplexIndexs] = this.getReleasableProteins(monomerIdx, complexIdx);
<a name="l01622"></a>01622             
<a name="l01623"></a>01623             [monPosStrnds, mons] = find(this.monomerBoundSites);
<a name="l01624"></a>01624             [cpxPosStrnds, cpxs] = find(this.complexBoundSites);
<a name="l01625"></a>01625             
<a name="l01626"></a>01626             iMonSS = find(~ismembc(mons, releasableMonomerIndexs) &amp; this.monomerDNAFootprintBindingStrandedness(mons) == this.dnaStrandedness_ssDNA);
<a name="l01627"></a>01627             iMonDS = find(~ismembc(mons, releasableMonomerIndexs) &amp; this.monomerDNAFootprintBindingStrandedness(mons) == this.dnaStrandedness_dsDNA);
<a name="l01628"></a>01628             iCpxSS = find(~ismembc(cpxs, releasableComplexIndexs) &amp; this.complexDNAFootprintBindingStrandedness(cpxs) == this.dnaStrandedness_ssDNA);
<a name="l01629"></a>01629             iCpxDS = find(~ismembc(cpxs, releasableComplexIndexs) &amp; this.complexDNAFootprintBindingStrandedness(cpxs) == this.dnaStrandedness_dsDNA);
<a name="l01630"></a>01630             
<a name="l01631"></a>01631             excPosStrnds = [
<a name="l01632"></a>01632                 excPosStrnds
<a name="l01633"></a>01633                 monPosStrnds(iMonSS, :)
<a name="l01634"></a>01634                 monPosStrnds(iMonDS, 1) 2*ceil(monPosStrnds(iMonDS, 2)/2)-1
<a name="l01635"></a>01635                 monPosStrnds(iMonDS, 1) 2*ceil(monPosStrnds(iMonDS, 2)/2)
<a name="l01636"></a>01636                 cpxPosStrnds(iCpxSS, :)
<a name="l01637"></a>01637                 cpxPosStrnds(iCpxDS, 1) 2*ceil(cpxPosStrnds(iCpxDS, 2)/2)-1
<a name="l01638"></a>01638                 cpxPosStrnds(iCpxDS, 1) 2*ceil(cpxPosStrnds(iCpxDS, 2)/2)
<a name="l01639"></a>01639                 ];
<a name="l01640"></a>01640             excLens = [
<a name="l01641"></a>01641                 excLens
<a name="l01642"></a>01642                 this.monomerDNAFootprints(mons(iMonSS))
<a name="l01643"></a>01643                 this.monomerDNAFootprints(mons(iMonDS))
<a name="l01644"></a>01644                 this.monomerDNAFootprints(mons(iMonDS))
<a name="l01645"></a>01645                 this.complexDNAFootprints(cpxs(iCpxSS))
<a name="l01646"></a>01646                 this.complexDNAFootprints(cpxs(iCpxDS))
<a name="l01647"></a>01647                 this.complexDNAFootprints(cpxs(iCpxDS))
<a name="l01648"></a>01648                 ];
<a name="l01649"></a>01649             
<a name="l01650"></a>01650             %exclude regions which are damaged
<a name="l01651"></a>01651             dmgPosStrnds = find(this.damagedSites);
<a name="l01652"></a>01652             
<a name="l01653"></a>01653             excPosStrnds = [
<a name="l01654"></a>01654                 excPosStrnds;
<a name="l01655"></a>01655                 dmgPosStrnds];
<a name="l01656"></a>01656             excLens = [
<a name="l01657"></a>01657                 excLens;
<a name="l01658"></a>01658                 ones(size(dmgPosStrnds, 1), 1)];
<a name="l01659"></a>01659             
<a name="l01660"></a>01660             %exclude other strand if proteins by both strands
<a name="l01661"></a>01661             if dnaFtptBindingStrandedness == this.dnaStrandedness_dsDNA
<a name="l01662"></a>01662                 excPosStrnds(:, 2) = ceil(excPosStrnds(:, 2) / 2);
<a name="l01663"></a>01663             end
<a name="l01664"></a>01664             
<a name="l01665"></a>01665             %find polymerized regions
<a name="l01666"></a>01666             switch dnaFtptRegionStrandedness
<a name="l01667"></a>01667                 case this.dnaStrandedness_ssDNA
<a name="l01668"></a>01668                     if dnaFtptBindingStrandedness == this.dnaStrandedness_ssDNA
<a name="l01669"></a>01669                         [polRgnPosStrnds, polRgnLens] = find(this.singleStrandedRegions);
<a name="l01670"></a>01670                     else
<a name="l01671"></a>01671                         throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:error&#39;, &#39;unsupported strandedness: %s&#39;, dnaFtptRegionStrandedness));
<a name="l01672"></a>01672                     end
<a name="l01673"></a>01673                 case this.dnaStrandedness_dsDNA
<a name="l01674"></a>01674                     if dnaFtptBindingStrandedness == this.dnaStrandedness_dsDNA
<a name="l01675"></a>01675                         [polRgnPosStrnds, polRgnLens] = find(this.doubleStrandedRegions(:, 1:2:end));
<a name="l01676"></a>01676                         if checkRegionSupercoiled
<a name="l01677"></a>01677                             tfs = this.supercoiled([polRgnPosStrnds(:, 1) 2 * polRgnPosStrnds(:, 2)]);
<a name="l01678"></a>01678                             polRgnPosStrnds = polRgnPosStrnds(tfs, :);
<a name="l01679"></a>01679                             polRgnLens = polRgnLens(tfs, :);
<a name="l01680"></a>01680                         end
<a name="l01681"></a>01681                     else
<a name="l01682"></a>01682                         [polRgnPosStrnds, polRgnLens] = find(this.doubleStrandedRegions);
<a name="l01683"></a>01683                         if checkRegionSupercoiled
<a name="l01684"></a>01684                             tfs = this.supercoiled(polRgnPosStrnds);
<a name="l01685"></a>01685                             polRgnPosStrnds = polRgnPosStrnds(tfs, :);
<a name="l01686"></a>01686                             polRgnLens = polRgnLens(tfs, :);
<a name="l01687"></a>01687                         end
<a name="l01688"></a>01688                     end
<a name="l01689"></a>01689                 otherwise
<a name="l01690"></a>01690                     throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:error&#39;, &#39;unsupported strandedness: %s&#39;, dnaFtptRegionStrandedness));
<a name="l01691"></a>01691             end
<a name="l01692"></a>01692             
<a name="l01693"></a>01693             %find difference of polymerized and excluded regions
<a name="l01694"></a>01694             [rgnPosStrnds, rgnLens] = this.excludeRegions(polRgnPosStrnds, polRgnLens, excPosStrnds, excLens);
<a name="l01695"></a>01695             
<a name="l01696"></a>01696             %return strands
<a name="l01697"></a>01697             if dnaFtptBindingStrandedness == this.dnaStrandedness_dsDNA
<a name="l01698"></a>01698                 rgnPosStrnds(:, 2) = 2 * rgnPosStrnds(:, 2) - 1;
<a name="l01699"></a>01699             end
<a name="l01700"></a>01700             
<a name="l01701"></a>01701             %return only regions with length at least dnaFtpt
<a name="l01702"></a>01702             idx = find(rgnLens &gt;= dnaFtpt);
<a name="l01703"></a>01703             rgnPosStrnds = rgnPosStrnds(idx, :);
<a name="l01704"></a>01704             rgnLens = rgnLens(idx, :);
<a name="l01705"></a>01705         end
<a name="l01706"></a>01706         
<a name="l01707"></a>01707         function value = getDamagedSites(this, includeBases, includeBonds, includeBase5Prime, includeBond5Prime, includeBase3Prime, includeBond3Prime, includeM6AD)
<a name="l01708"></a>01708             import edu.stanford.covert.util.<a class="code" href="class_circular_sparse_mat.html">CircularSparseMat</a>;                        
<a name="l01709"></a>01709             
<a name="l01710"></a>01710             if ~includeBases
<a name="l01711"></a>01711                 value = CircularSparseMat([], [], size(this.gapSites), 1);
<a name="l01712"></a>01712             else
<a name="l01713"></a>01713                 %damaged based
<a name="l01714"></a>01714                 if includeM6AD
<a name="l01715"></a>01715                     value = this.damagedBases;
<a name="l01716"></a>01716                 else
<a name="l01717"></a>01717                     [posStrnds, dmgs] = find(this.damagedBases);
<a name="l01718"></a>01718                     posStrnds(dmgs == this.metabolite.m6ADIndexs, :) = [];
<a name="l01719"></a>01719                     dmgs(dmgs == this.metabolite.m6ADIndexs, :) = [];
<a name="l01720"></a>01720                     value = CircularSparseMat(posStrnds, dmgs, [this.sequenceLen this.nCompartments], 1);
<a name="l01721"></a>01721                 end
<a name="l01722"></a>01722                 
<a name="l01723"></a>01723                 if nnz(this.gapSites)
<a name="l01724"></a>01724                     value = value + this.gapSites;
<a name="l01725"></a>01725                 end
<a name="l01726"></a>01726                 if nnz(this.abasicSites)
<a name="l01727"></a>01727                     value = value + this.abasicSites;
<a name="l01728"></a>01728                 end
<a name="l01729"></a>01729                 if nnz(this.damagedSugarPhosphates)
<a name="l01730"></a>01730                     value = value + this.damagedSugarPhosphates;
<a name="l01731"></a>01731                 end
<a name="l01732"></a>01732                 if nnz(this.intrastrandCrossLinks)
<a name="l01733"></a>01733                     value = value + this.intrastrandCrossLinks;
<a name="l01734"></a>01734                     if includeBase5Prime
<a name="l01735"></a>01735                         value = value + this.intrastrandCrossLinks5;
<a name="l01736"></a>01736                     end
<a name="l01737"></a>01737                     if includeBase3Prime
<a name="l01738"></a>01738                         value = value + this.intrastrandCrossLinks3;
<a name="l01739"></a>01739                     end
<a name="l01740"></a>01740                 end
<a name="l01741"></a>01741             end
<a name="l01742"></a>01742             
<a name="l01743"></a>01743             if includeBonds
<a name="l01744"></a>01744                 if nnz(this.strandBreaks)
<a name="l01745"></a>01745                     value = value + this.strandBreaks;
<a name="l01746"></a>01746                     if includeBond5Prime
<a name="l01747"></a>01747                         value = value + this.strandBreaks5;
<a name="l01748"></a>01748                     end
<a name="l01749"></a>01749                     if includeBond3Prime
<a name="l01750"></a>01750                         value = value + this.strandBreaks3;
<a name="l01751"></a>01751                     end
<a name="l01752"></a>01752                 end
<a name="l01753"></a>01753                 if nnz(this.hollidayJunctions)
<a name="l01754"></a>01754                     value = value + this.hollidayJunctions;
<a name="l01755"></a>01755                     if includeBond5Prime
<a name="l01756"></a>01756                         value = value + this.hollidayJunctions5;
<a name="l01757"></a>01757                     end
<a name="l01758"></a>01758                     if includeBond3Prime
<a name="l01759"></a>01759                         value = value + this.hollidayJunctions3;
<a name="l01760"></a>01760                     end
<a name="l01761"></a>01761                 end
<a name="l01762"></a>01762             end
<a name="l01763"></a>01763         end
<a name="l01764"></a>01764     end
<a name="l01765"></a>01765     
<a name="l01766"></a>01766     %additional methods which query, but do not modify state
<a name="l01767"></a>01767     %unlike those above, these methods are very focused; they return information
<a name="l01768"></a>01768     %about the <a class="code" href="class_chromosome.html">Chromosome</a> useful to only specific processes
<a name="l01769"></a>01769     methods
<a name="l01770"></a>01770         function [unmethylatedSites, hemimethylatedSites, methylatedSites, cleavedSites, inaccessibleRegions] = rmStatus(this, ...
<a name="l01771"></a>01771                 sites, methylatedPositions, restrictionPositions, bindingMonomers, bindingComplexs)
<a name="l01772"></a>01772             import edu.stanford.covert.util.<a class="code" href="class_sparse_mat.html">SparseMat</a>;
<a name="l01773"></a>01773             
<a name="l01774"></a>01774             warningState = warning(&#39;query&#39;, &#39;SparseMat:inefficient&#39;);
<a name="l01775"></a>01775             warning(&#39;off&#39;, &#39;SparseMat:inefficient&#39;);
<a name="l01776"></a>01776             
<a name="l01777"></a>01777             if nargin &lt; 5
<a name="l01778"></a>01778                 bindingMonomers = [];
<a name="l01779"></a>01779             end
<a name="l01780"></a>01780             if nargin &lt; 6
<a name="l01781"></a>01781                 bindingComplexs = [];
<a name="l01782"></a>01782             end
<a name="l01783"></a>01783             
<a name="l01784"></a>01784             nonmethylatedPositions = [
<a name="l01785"></a>01785                 1:methylatedPositions(1)-1 methylatedPositions(1)+1:size(sites,2);
<a name="l01786"></a>01786                 1:methylatedPositions(2)-1 methylatedPositions(2)+1:size(sites,2)]&#39;;
<a name="l01787"></a>01787             nonRestrictionPositions = [
<a name="l01788"></a>01788                 1:restrictionPositions(1)-1 restrictionPositions(1)+1:size(sites,2);
<a name="l01789"></a>01789                 1:restrictionPositions(2)-1 restrictionPositions(2)+1:size(sites,2)]&#39;;
<a name="l01790"></a>01790             
<a name="l01791"></a>01791             sitesChromosomesPositions = [
<a name="l01792"></a>01792                 size(sites, 1)
<a name="l01793"></a>01793                 size(sites, 2)
<a name="l01794"></a>01794                 size(this.damagedBases, 2)/2
<a name="l01795"></a>01795                 size(this.damagedBases, 3)
<a name="l01796"></a>01796                 ]&#39;;
<a name="l01797"></a>01797             
<a name="l01798"></a>01798             damagedRegions = ...
<a name="l01799"></a>01799                 (                this.damagedBases(                  sites(:,methylatedPositions(1)),                   1:2:end,:)~=this.metabolite.m6ADIndexs &gt;0 &amp; ...
<a name="l01800"></a>01800                 this.damagedBases(                  sites(:,methylatedPositions(1)),                   1:2:end,:)~=0                                       &gt;0)   | ...
<a name="l01801"></a>01801                 (                this.damagedBases(                  sites(:,methylatedPositions(2)),                   2:2:end,:)~=this.metabolite.m6ADIndexs &gt;0 &amp; ...
<a name="l01802"></a>01802                 this.damagedBases(                  sites(:,methylatedPositions(2)),                   2:2:end,:)~=0                                       &gt;0)   | ...
<a name="l01803"></a>01803                 xor(             this.strandBreaks(                  sites(:,restrictionPositions(1)),                  1:2:end,:), ...
<a name="l01804"></a>01804                 this.strandBreaks(                  sites(:,restrictionPositions(2)),                  2:2:end,:))                                               | ...
<a name="l01805"></a>01805                 collapse(reshape(this.damagedBases(          reshape(sites(:,nonmethylatedPositions(:,1)),        [],1), 1:2:end,:), sitesChromosomesPositions-[0 1 0 0]),2) &gt;0   | ...
<a name="l01806"></a>01806                 collapse(reshape(this.damagedBases(          reshape(sites(:,nonmethylatedPositions(:,2)),        [],1), 2:2:end,:), sitesChromosomesPositions-[0 1 0 0]),2) &gt;0   | ...
<a name="l01807"></a>01807                 this.damagedBases(                  sites(:,methylatedPositions(1)),                   2:2:end,:) ~=0                                            | ...
<a name="l01808"></a>01808                 this.damagedBases(                  sites(:,methylatedPositions(2)),                   1:2:end,:) ~=0                                            | ...
<a name="l01809"></a>01809                 collapse(reshape(this.strandBreaks(          reshape(sites(:,nonRestrictionPositions(1:end-1,1)),[],1), 1:2:end,:), sitesChromosomesPositions-[0 2 0 0]),2) &gt;0    | ...
<a name="l01810"></a>01810                 collapse(reshape(this.strandBreaks(          reshape(sites(:,nonRestrictionPositions(2:end  ,2)),[],1), 2:2:end,:), sitesChromosomesPositions-[0 2 0 0]),2) &gt;0    | ...
<a name="l01811"></a>01811                 this.strandBreaks(                  sites(:,restrictionPositions(1)),                  2:2:end,:) ~=0                                            | ...
<a name="l01812"></a>01812                 this.strandBreaks(                  sites(:,restrictionPositions(2)),                  1:2:end,:) ~=0                                            | ...
<a name="l01813"></a>01813                 collapse(reshape(this.intrastrandCrossLinks( reshape(sites,                                      [],1), 1:2:end,:), sitesChromosomesPositions),2)           &gt;0    | ...
<a name="l01814"></a>01814                 collapse(reshape(this.intrastrandCrossLinks( reshape(sites,                                      [],1), 2:2:end,:), sitesChromosomesPositions),2)           &gt;0    | ...
<a name="l01815"></a>01815                 collapse(reshape(this.damagedSugarPhosphates(reshape(sites,                                      [],1), 1:2:end,:), sitesChromosomesPositions),2)           &gt;0    | ...
<a name="l01816"></a>01816                 collapse(reshape(this.damagedSugarPhosphates(reshape(sites,                                      [],1), 2:2:end,:), sitesChromosomesPositions),2)           &gt;0    | ...
<a name="l01817"></a>01817                 collapse(reshape(this.abasicSites(           reshape(sites,                                      [],1), 1:2:end,:), sitesChromosomesPositions),2)           &gt;0    | ...
<a name="l01818"></a>01818                 collapse(reshape(this.abasicSites(           reshape(sites,                                      [],1), 2:2:end,:), sitesChromosomesPositions),2)           &gt;0    | ...
<a name="l01819"></a>01819                 collapse(reshape(this.gapSites(              reshape(sites,                                      [],1), 1:2:end,:), sitesChromosomesPositions),2)           &gt;0    | ...
<a name="l01820"></a>01820                 collapse(reshape(this.gapSites(              reshape(sites,                                      [],1), 2:2:end,:), sitesChromosomesPositions),2)           &gt;0    | ...
<a name="l01821"></a>01821                 collapse(reshape(this.hollidayJunctions(     reshape(sites(:,1:end-1),                           [],1), 1:2:end,:), sitesChromosomesPositions-[0 1 0 0]),2) &gt;0    | ...
<a name="l01822"></a>01822                 collapse(reshape(this.hollidayJunctions(     reshape(sites(:,2:end),                             [],1), 2:2:end,:), sitesChromosomesPositions-[0 1 0 0]),2) &gt;0;
<a name="l01823"></a>01823             
<a name="l01824"></a>01824             methylatedSites = ...
<a name="l01825"></a>01825                 this.damagedBases(sites(:, methylatedPositions(1)), 1:2:end,:) == this.metabolite.m6ADIndexs &amp; ...
<a name="l01826"></a>01826                 this.damagedBases(sites(:, methylatedPositions(2)), 2:2:end,:) == this.metabolite.m6ADIndexs;
<a name="l01827"></a>01827             
<a name="l01828"></a>01828             hemimethylatedSites = xor(...
<a name="l01829"></a>01829                 this.damagedBases(sites(:, methylatedPositions(1)), 1:2:end,:) == this.metabolite.m6ADIndexs, ...
<a name="l01830"></a>01830                 this.damagedBases(sites(:, methylatedPositions(2)), 2:2:end,:) == this.metabolite.m6ADIndexs);
<a name="l01831"></a>01831             
<a name="l01832"></a>01832             unmethylatedSites = ...
<a name="l01833"></a>01833                 this.damagedBases(sites(:, methylatedPositions(1)), 1:2:end,:) ~= this.metabolite.m6ADIndexs &amp; ...
<a name="l01834"></a>01834                 this.damagedBases(sites(:, methylatedPositions(2)), 2:2:end,:) ~= this.metabolite.m6ADIndexs;
<a name="l01835"></a>01835             
<a name="l01836"></a>01836             cleavedSites = ...
<a name="l01837"></a>01837                 this.strandBreaks(sites(:, restrictionPositions(1)), 1:2:end,:) &amp; ...
<a name="l01838"></a>01838                 this.strandBreaks(sites(:, restrictionPositions(2)), 2:2:end,:);
<a name="l01839"></a>01839             
<a name="l01840"></a>01840             siteLength = size(sites, 2);
<a name="l01841"></a>01841             ignoreDamageFilter =  1:siteLength;
<a name="l01842"></a>01842             sitesStrands = [
<a name="l01843"></a>01843                 sites(:, 1)   ones(size(sites, 1), 1)
<a name="l01844"></a>01844                 sites(:, 1) 3*ones(size(sites, 1), 1)];
<a name="l01845"></a>01845             inaccessibleRegions = damagedRegions | ...
<a name="l01846"></a>01846                 (cleavedSites &amp; ~unmethylatedSites) | ...
<a name="l01847"></a>01847                 ~reshape(this.isRegionAccessible(sitesStrands, siteLength, bindingMonomers, bindingComplexs, true, ignoreDamageFilter, false, true), [], this.nCompartments / 2);
<a name="l01848"></a>01848                         
<a name="l01849"></a>01849             methylatedSites     = ~inaccessibleRegions &amp; methylatedSites;
<a name="l01850"></a>01850             hemimethylatedSites = ~inaccessibleRegions &amp; hemimethylatedSites;
<a name="l01851"></a>01851             unmethylatedSites   = ~inaccessibleRegions &amp; unmethylatedSites &amp; ~cleavedSites;
<a name="l01852"></a>01852             cleavedSites        = ~inaccessibleRegions &amp; cleavedSites;            
<a name="l01853"></a>01853             
<a name="l01854"></a>01854             unmethylatedSites   = SparseMat(unmethylatedSites);
<a name="l01855"></a>01855             hemimethylatedSites = SparseMat(hemimethylatedSites);
<a name="l01856"></a>01856             methylatedSites     = SparseMat(methylatedSites);
<a name="l01857"></a>01857             cleavedSites        = SparseMat(cleavedSites);
<a name="l01858"></a>01858             inaccessibleRegions = SparseMat(inaccessibleRegions);
<a name="l01859"></a>01859             
<a name="l01860"></a>01860             if strcmp(warningState.state, &#39;on&#39;); warning(&#39;on&#39;, &#39;SparseMat:inefficient&#39;); end;
<a name="l01861"></a>01861         end
<a name="l01862"></a>01862     end
<a name="l01863"></a>01863 
<a name="l01864"></a>01864     %methods which modify the state of this class, and possibly request
<a name="l01865"></a>01865     %modifications to other parts of the simulation&#39;s state
<a name="l01866"></a>01866     methods
<a name="l01867"></a>01867         function sideEffects = setRegionUnwound(this, positions, lengths)
<a name="l01868"></a>01868             sideEffects = edu.stanford.covert.cell.sim.<a class="code" href="class_simulation_state_side_effect.html">SimulationStateSideEffect</a>.empty(0, 1);
<a name="l01869"></a>01869 
<a name="l01870"></a>01870             if ~isequal(size(positions, 1), size(lengths, 1))
<a name="l01871"></a>01871                 throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;, &#39;positions and lengths must have same number of rows&#39;));
<a name="l01872"></a>01872             end
<a name="l01873"></a>01873             if size(positions, 2) ~= 1
<a name="l01874"></a>01874                 throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;, &#39;positions must have 1 columns&#39;));
<a name="l01875"></a>01875             end
<a name="l01876"></a>01876             if size(lengths, 2) ~= 1
<a name="l01877"></a>01877                 throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;, &#39;lengths must have 1 column&#39;));
<a name="l01878"></a>01878             end
<a name="l01879"></a>01879             if ~any(lengths)
<a name="l01880"></a>01880                 return;
<a name="l01881"></a>01881             end
<a name="l01882"></a>01882             L = this.sequenceLen;
<a name="l01883"></a>01883             if any(positions &gt; L)
<a name="l01884"></a>01884                 throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;, &#39;positions cannot wrap ORI&#39;));
<a name="l01885"></a>01885             end
<a name="l01886"></a>01886             
<a name="l01887"></a>01887             positions = positions(logical(lengths));
<a name="l01888"></a>01888             lengths = lengths(logical(lengths));
<a name="l01889"></a>01889             n = size(positions, 1);
<a name="l01890"></a>01890             if ~all(this.isRegionDoubleStranded([positions ones(n, 1)], lengths, false))
<a name="l01891"></a>01891                 throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;, &#39;regions must be <span class="keywordtype">double</span>-stranded&#39;));
<a name="l01892"></a>01892             end
<a name="l01893"></a>01893             if ~all(positions == 1 | positions == L | ...
<a name="l01894"></a>01894                     this.isRegionSingleStranded([max(1, positions - 1) ones(n, 1)], 1, false) | ...
<a name="l01895"></a>01895                     this.isRegionSingleStranded([min(L, positions + 1) ones(n, 1)], 1, false))
<a name="l01896"></a>01896                 throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;,...
<a name="l01897"></a>01897                     &#39;unwinding must begin at either end of <a class="code" href="classds_d_n_a.html">dsDNA</a> or continue where it left off&#39;));
<a name="l01898"></a>01898             end
<a name="l01899"></a>01899             if ~all(this.isRegionNotPolymerized([
<a name="l01900"></a>01900                     positions 3*ones(n, 1);
<a name="l01901"></a>01901                     positions 4*ones(n, 1)],...
<a name="l01902"></a>01902                     [lengths; lengths], false))
<a name="l01903"></a>01903                 throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;,&#39;chromosome 2 region cannot be polymerized&#39;));
<a name="l01904"></a>01904             end
<a name="l01905"></a>01905             
<a name="l01906"></a>01906             oldStrd = this.strandIndexs_ch1(2);
<a name="l01907"></a>01907             newStrd = this.strandIndexs_ch2(2);
<a name="l01908"></a>01908             
<a name="l01909"></a>01909             directions = sign(lengths);
<a name="l01910"></a>01910             positions = positions + min(0, lengths + 1);
<a name="l01911"></a>01911             lengths = abs(lengths);
<a name="l01912"></a>01912             
<a name="l01913"></a>01913             for i = 1:n
<a name="l01914"></a>01914                 len = lengths(i);
<a name="l01915"></a>01915                 pos = positions(i,1);
<a name="l01916"></a>01916                 dir = directions(i);
<a name="l01917"></a>01917                 
<a name="l01918"></a>01918                 %if necessary, move region of initial negative strand of
<a name="l01919"></a>01919                 %chromosome 1 to chromosome 2
<a name="l01920"></a>01920                 this.monomerBoundSites      = this.shiftStrandToNewChromosome(this.monomerBoundSites,      pos, len, oldStrd, newStrd);
<a name="l01921"></a>01921                 this.complexBoundSites      = this.shiftStrandToNewChromosome(this.complexBoundSites,      pos, len, oldStrd, newStrd);
<a name="l01922"></a>01922                 this.gapSites               = this.shiftStrandToNewChromosome(this.gapSites,               pos, len, oldStrd, newStrd);
<a name="l01923"></a>01923                 this.abasicSites            = this.shiftStrandToNewChromosome(this.abasicSites,            pos, len, oldStrd, newStrd);
<a name="l01924"></a>01924                 this.damagedSugarPhosphates = this.shiftStrandToNewChromosome(this.damagedSugarPhosphates, pos, len, oldStrd, newStrd);
<a name="l01925"></a>01925                 this.damagedBases           = this.shiftStrandToNewChromosome(this.damagedBases,           pos, len, oldStrd, newStrd);
<a name="l01926"></a>01926                 this.intrastrandCrossLinks  = this.shiftStrandToNewChromosome(this.intrastrandCrossLinks,  pos, len, oldStrd, newStrd);
<a name="l01927"></a>01927                 this.strandBreaks           = this.shiftStrandToNewChromosome(this.strandBreaks,           pos, len, oldStrd, newStrd);
<a name="l01928"></a>01928                 this.hollidayJunctions      = this.shiftStrandToNewChromosome(this.hollidayJunctions,      pos, len, oldStrd, newStrd);                
<a name="l01929"></a>01929                 
<a name="l01930"></a>01930                 %update region of chromosomes that have been polymerized                
<a name="l01931"></a>01931                 [regionStartPositions, regionLengths] = find(this.polymerizedRegions(:, oldStrd));
<a name="l01932"></a>01932                 regionStartPositions = regionStartPositions(:, 1);
<a name="l01933"></a>01933                 idx = find(regionStartPositions &lt;= pos &amp; regionStartPositions + regionLengths &gt; pos);                
<a name="l01934"></a>01934                 this.polymerizedRegions(regionStartPositions(idx), oldStrd) = pos - regionStartPositions(idx);
<a name="l01935"></a>01935                 if dir == 1
<a name="l01936"></a>01936                     if pos ~= regionStartPositions(idx)
<a name="l01937"></a>01937                         throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:error&#39;, &#39;programmer error: unwinding bad region&#39;));
<a name="l01938"></a>01938                     end
<a name="l01939"></a>01939                     this.linkingNumbers(pos + len, 1:2) = this.linkingNumbers(pos, oldStrd);
<a name="l01940"></a>01940                     this.linkingNumbers(pos, 1:2) = 0;
<a name="l01941"></a>01941                 end
<a name="l01942"></a>01942                 if (dir == 1 &amp;&amp; len == regionLengths(idx) || ...
<a name="l01943"></a>01943                     dir == -1 &amp;&amp; pos == regionStartPositions(idx)) &amp;&amp; ...
<a name="l01944"></a>01944                     abs(this.linkingNumbers([pos oldStrd])) &gt; 1<a class="code" href="json_parse_8m.html#ac14d26badced2970320ee4d772ad0ae9">e</a>-6
<a name="l01945"></a>01945                     throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;,...
<a name="l01946"></a>01946                         &#39;cannot completely unwind region with nonzero linking number&#39;));
<a name="l01947"></a>01947                 end
<a name="l01948"></a>01948                 if regionLengths(idx) - (pos - regionStartPositions(idx)) - len ~= 0
<a name="l01949"></a>01949                     this.polymerizedRegions(pos+len, oldStrd) = ...
<a name="l01950"></a>01950                         regionLengths(idx) - (pos - regionStartPositions(idx)) - len;
<a name="l01951"></a>01951                 end
<a name="l01952"></a>01952                 this.polymerizedRegions(pos, newStrd) = len;
<a name="l01953"></a>01953                 
<a name="l01954"></a>01954                 this.mergeOwnAdjacentRegions();
<a name="l01955"></a>01955             end
<a name="l01956"></a>01956         end
<a name="l01957"></a>01957                 
<a name="l01958"></a>01958         function spmat = shiftStrandToNewChromosome(~, spmat, pos, len, oldStrd, newStrd)
<a name="l01959"></a>01959             import edu.stanford.covert.util.CircularSparseMat;
<a name="l01960"></a>01960             
<a name="l01961"></a>01961             [subs, vals] = find(spmat);
<a name="l01962"></a>01962             tfs = ...
<a name="l01963"></a>01963                 subs(:, 1) &gt;= pos &amp; ...
<a name="l01964"></a>01964                 subs(:, 1) &lt;= pos + len - 1 &amp; ...
<a name="l01965"></a>01965                 subs(:, 2) == oldStrd;
<a name="l01966"></a>01966             subs(tfs, 2) = newStrd;
<a name="l01967"></a>01967             spmat = CircularSparseMat(subs, vals, size(spmat), 1);
<a name="l01968"></a>01968         end
<a name="l01969"></a>01969         
<a name="l01970"></a>01970         function sideEffects = setRegionPolymerized(this, positionsStrands, lengths)
<a name="l01971"></a>01971             import edu.stanford.covert.cell.sim.<a class="code" href="class_simulation_state_side_effect.html">SimulationStateSideEffect</a>;
<a name="l01972"></a>01972 
<a name="l01973"></a>01973             L = this.sequenceLen;            
<a name="l01974"></a>01974             if ~all(positionsStrands(:,2) == 1 | positionsStrands(:,2) == 2)
<a name="l01975"></a>01975                 throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;, &#39;positionsStrands must be a valid template strand (eg. 1 or 2)&#39;));
<a name="l01976"></a>01976             end
<a name="l01977"></a>01977             if any(positionsStrands(:,1) + lengths -1 &gt; L)
<a name="l01978"></a>01978                 throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;, &#39;positionsStrands cannot wrap ORI&#39;));
<a name="l01979"></a>01979             end
<a name="l01980"></a>01980             if ~isequal(size(positionsStrands,1), size(lengths,1))
<a name="l01981"></a>01981                 throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;, &#39;positionsStrands and lengths must have same number of rows&#39;));
<a name="l01982"></a>01982             end
<a name="l01983"></a>01983             if size(positionsStrands, 2) ~= 2
<a name="l01984"></a>01984                 throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;, &#39;positionsStrands must have 2 columns&#39;));
<a name="l01985"></a>01985             end
<a name="l01986"></a>01986             if size(lengths, 2) ~= 1
<a name="l01987"></a>01987                 throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;, &#39;lengths must have 1 column&#39;));
<a name="l01988"></a>01988             end
<a name="l01989"></a>01989             
<a name="l01990"></a>01990             positionsStrands(:, 1) = positionsStrands(: ,1) + min(0, lengths + 1);
<a name="l01991"></a>01991             lengths = abs(lengths);
<a name="l01992"></a>01992             
<a name="l01993"></a>01993             for i = 1:size(positionsStrands, 1)
<a name="l01994"></a>01994                 len = lengths(i);
<a name="l01995"></a>01995                 pos = positionsStrands(i,1);
<a name="l01996"></a>01996                 tmpStrd = this.strandIndexs_template(positionsStrands(i,2), :);
<a name="l01997"></a>01997                 nonTmpStrd = this.strandIndexs_nonTemplate(positionsStrands(i,2), :);
<a name="l01998"></a>01998                 
<a name="l01999"></a>01999                 %if no polymerization requested, do nothing
<a name="l02000"></a>02000                 if len == 0
<a name="l02001"></a>02001                     continue;
<a name="l02002"></a>02002                 end
<a name="l02003"></a>02003 
<a name="l02004"></a>02004                 %check that template exists
<a name="l02005"></a>02005                 if ~this.isRegionPolymerized([pos tmpStrd], len, false)
<a name="l02006"></a>02006                     throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:error&#39;,&#39;cannot polymerize a region without a template&#39;));
<a name="l02007"></a>02007                 end
<a name="l02008"></a>02008 
<a name="l02009"></a>02009                 %check that strand hasn&#39;t been polymerized
<a name="l02010"></a>02010                 if ~this.isRegionNotPolymerized([pos nonTmpStrd], len, false)
<a name="l02011"></a>02011                     throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:error&#39;,&#39;cannot polymerize a region that&#39;&#39;s already been polymerized&#39;));
<a name="l02012"></a>02012                 end
<a name="l02013"></a>02013 
<a name="l02014"></a>02014                 %set region polymerized
<a name="l02015"></a>02015                 this.polymerizedRegions([pos nonTmpStrd]) = len;
<a name="l02016"></a>02016                 this.linkingNumbers([pos tmpStrd; pos nonTmpStrd]) = len / this.relaxedBasesPerTurn;
<a name="l02017"></a>02017                 this.mergeOwnAdjacentRegions();
<a name="l02018"></a>02018             end
<a name="l02019"></a>02019 
<a name="l02020"></a>02020             %side effects
<a name="l02021"></a>02021             sideEffects = SimulationStateSideEffect.empty(0, 1);
<a name="l02022"></a>02022         end
<a name="l02023"></a>02023 
<a name="l02024"></a>02024         %lengths must be non-negative integers
<a name="l02025"></a>02025         function [releasedMonomers, releasedComplexs, sideEffects, tfs, idxs, positionsStrands, lengths] = ...
<a name="l02026"></a>02026                 setSiteProteinBound(this, positionsStrands, maxBindings, weights, binding_monomerIndexs, binding_complexIndexs, ...
<a name="l02027"></a>02027                 mainEffects_monomerIndexs, mainEffects_complexIndexs, ...
<a name="l02028"></a>02028                 isBindingStable, isPositionsStrandFootprintCentroid, lengths, isBindingProcessive, ignoreDamageFilter, checkRegionSupercoiled)
<a name="l02029"></a>02029                 
<a name="l02030"></a>02030             if nargin &lt; 14
<a name="l02031"></a>02031                 checkRegionSupercoiled = false;
<a name="l02032"></a>02032             end
<a name="l02033"></a>02033             
<a name="l02034"></a>02034             if isBindingStable &amp;&amp; numel(binding_monomerIndexs) + numel(binding_complexIndexs) &gt; 1
<a name="l02035"></a>02035                 throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;, &#39;Can only bind 1 protein at a time&#39;));
<a name="l02036"></a>02036             end
<a name="l02037"></a>02037             if isBindingStable &amp;&amp; ~isBindingProcessive &amp;&amp; ~all(lengths == 1)
<a name="l02038"></a>02038                 throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;,&#39;If any(lengths~=1) then if binding is stable it must be processive&#39;));
<a name="l02039"></a>02039             end
<a name="l02040"></a>02040             if numel(lengths) == 1
<a name="l02041"></a>02041                 lengths = lengths(ones(size(positionsStrands, 1), 1), 1);
<a name="l02042"></a>02042             end
<a name="l02043"></a>02043             
<a name="l02044"></a>02044             %randomly select among accessible sites
<a name="l02045"></a>02045             [tfs, idxs, positionsStrands, lengths] = this.sampleAccessibleRegions(maxBindings, weights, positionsStrands, lengths, ...
<a name="l02046"></a>02046                 binding_monomerIndexs, binding_complexIndexs, isPositionsStrandFootprintCentroid, ignoreDamageFilter, ~isBindingStable, isBindingProcessive, checkRegionSupercoiled);
<a name="l02047"></a>02047             
<a name="l02048"></a>02048             %if positions are centroid, shift positions to start coordinate view
<a name="l02049"></a>02049             [footprint, footprint3Prime, footprint5Prime, footprintBindingStrandedness, footprintRegionStrandedness] = this.getDNAFootprint(binding_monomerIndexs, binding_complexIndexs);
<a name="l02050"></a>02050             
<a name="l02051"></a>02051             releasePositionsStrands = positionsStrands;
<a name="l02052"></a>02052             releasePositionsStrands(:, 1) = releasePositionsStrands(:, 1) + min(0, lengths + 1);
<a name="l02053"></a>02053             if isPositionsStrandFootprintCentroid
<a name="l02054"></a>02054                 releasePositionsStrands(mod(releasePositionsStrands(:,2),2)==1, 1) = releasePositionsStrands(mod(releasePositionsStrands(:,2),2)==1, 1) - footprint5Prime;
<a name="l02055"></a>02055                 releasePositionsStrands(mod(releasePositionsStrands(:,2),2)==0, 1) = releasePositionsStrands(mod(releasePositionsStrands(:,2),2)==0, 1) - footprint3Prime;
<a name="l02056"></a>02056             end
<a name="l02057"></a>02057             
<a name="l02058"></a>02058             %remove proteins currently bound to selected accessible sites
<a name="l02059"></a>02059             if footprintRegionStrandedness == this.dnaStrandedness_xsDNA
<a name="l02060"></a>02060                 [monomerPosStrands, monomers] = find(this.monomerBoundSites);
<a name="l02061"></a>02061                 [complexPosStrands, complexs] = find(this.complexBoundSites);
<a name="l02062"></a>02062                 [releasableMonomerIndexs, releasableComplexIndexs] = this.getReleasableProteins(binding_monomerIndexs, binding_complexIndexs);
<a name="l02063"></a>02063                 
<a name="l02064"></a>02064                 tmpIdxs = find(~ismembc(monomers, releasableMonomerIndexs));
<a name="l02065"></a>02065                 monomerPosStrands = monomerPosStrands(tmpIdxs, :);
<a name="l02066"></a>02066                 monomers = monomers(tmpIdxs, :);
<a name="l02067"></a>02067                 
<a name="l02068"></a>02068                 tmpIdxs = find(~ismembc(complexs, releasableComplexIndexs));
<a name="l02069"></a>02069                 complexPosStrands = complexPosStrands(tmpIdxs, :);
<a name="l02070"></a>02070                 complexs = complexs(tmpIdxs, :);
<a name="l02071"></a>02071                 
<a name="l02072"></a>02072                 [releasePositionsStrands, releaseLens] = this.excludeRegions([
<a name="l02073"></a>02073                     releasePositionsStrands(:, 1)     ones(size(releasePositionsStrands, 1), 1)
<a name="l02074"></a>02074                     releasePositionsStrands(:, 1) 2 * ones(size(releasePositionsStrands, 1), 1)
<a name="l02075"></a>02075                     releasePositionsStrands(:, 1) 3 * ones(size(releasePositionsStrands, 1), 1)
<a name="l02076"></a>02076                     releasePositionsStrands(:, 1) 4 * ones(size(releasePositionsStrands, 1), 1)], ...
<a name="l02077"></a>02077                     repmat(footprint + abs(lengths) - 1, 4, 1), ...
<a name="l02078"></a>02078                     [monomerPosStrands; complexPosStrands], [this.monomerDNAFootprints(monomers); this.complexDNAFootprints(complexs)]);
<a name="l02079"></a>02079             else
<a name="l02080"></a>02080                 releaseLens = footprint + abs(lengths) - 1;
<a name="l02081"></a>02081             end
<a name="l02082"></a>02082             [releasedMonomers, releasedComplexs, sideEffects] = ...
<a name="l02083"></a>02083                 this.setRegionProteinUnbound(releasePositionsStrands, releaseLens, ...
<a name="l02084"></a>02084                 mainEffects_monomerIndexs, mainEffects_complexIndexs, ...                
<a name="l02085"></a>02085                 footprintRegionStrandedness == this.dnaStrandedness_dsDNA, ...
<a name="l02086"></a>02086                 footprintBindingStrandedness == this.dnaStrandedness_dsDNA, ...
<a name="l02087"></a>02087                 false, false);
<a name="l02088"></a>02088             
<a name="l02089"></a>02089             %if binding is stable, bind protein to selected accessible sites
<a name="l02090"></a>02090             if isBindingStable
<a name="l02091"></a>02091                 bindPositionsStrands = positionsStrands;
<a name="l02092"></a>02092                 if isBindingProcessive
<a name="l02093"></a>02093                     bindPositionsStrands(:,1) = bindPositionsStrands(:,1) + lengths - sign(lengths);
<a name="l02094"></a>02094                 end
<a name="l02095"></a>02095                 if isPositionsStrandFootprintCentroid
<a name="l02096"></a>02096                     bindPositionsStrands(mod(bindPositionsStrands(:,2),2)==1, 1) = bindPositionsStrands(mod(bindPositionsStrands(:,2),2)==1, 1) - footprint5Prime;
<a name="l02097"></a>02097                     bindPositionsStrands(mod(bindPositionsStrands(:,2),2)==0, 1) = bindPositionsStrands(mod(bindPositionsStrands(:,2),2)==0, 1) - footprint3Prime;
<a name="l02098"></a>02098                 end
<a name="l02099"></a>02099 
<a name="l02100"></a>02100                 if ~isempty(binding_monomerIndexs)
<a name="l02101"></a>02101                     this.monomerBoundSites(bindPositionsStrands) = binding_monomerIndexs;
<a name="l02102"></a>02102                     releasedMonomers(mainEffects_monomerIndexs == binding_monomerIndexs) = ...
<a name="l02103"></a>02103                         releasedMonomers(mainEffects_monomerIndexs == binding_monomerIndexs) - ...
<a name="l02104"></a>02104                         numel(idxs);
<a name="l02105"></a>02105                 else
<a name="l02106"></a>02106                     this.complexBoundSites(bindPositionsStrands) = binding_complexIndexs;
<a name="l02107"></a>02107                     releasedComplexs(mainEffects_complexIndexs == binding_complexIndexs) = ...
<a name="l02108"></a>02108                         releasedComplexs(mainEffects_complexIndexs == binding_complexIndexs) - ...
<a name="l02109"></a>02109                         numel(idxs);
<a name="l02110"></a>02110                 end
<a name="l02111"></a>02111             end
<a name="l02112"></a>02112         end
<a name="l02113"></a>02113         
<a name="l02114"></a>02114         %change the identity of bound proteins
<a name="l02115"></a>02115         function [releasedMonomers, releasedComplexs, sideEffects] = ...
<a name="l02116"></a>02116                 modifyBoundProtein(this, positionsStrands, newMonomers, newComplexs, ...
<a name="l02117"></a>02117                 mainEffects_monomerIndexs, mainEffects_complexIndexs)
<a name="l02118"></a>02118                         
<a name="l02119"></a>02119             import edu.stanford.covert.cell.sim.SimulationStateSideEffect;
<a name="l02120"></a>02120             import edu.stanford.covert.cell.sim.<a class="code" href="class_simulation_state_side_effect_item.html">SimulationStateSideEffectItem</a>;
<a name="l02121"></a>02121             import edu.stanford.covert.util.<a class="code" href="count_unique_8m.html#a410e08d5000569bcf7496572e8ce1729">countUnique</a>;
<a name="l02122"></a>02122                     
<a name="l02123"></a>02123             if any(all([newMonomers newComplexs], 2))
<a name="l02124"></a>02124                 throw(MException(&#39;Only 1 protein can be bound at each site&#39;));
<a name="l02125"></a>02125             end
<a name="l02126"></a>02126             
<a name="l02127"></a>02127             %get identities of currently bound proteins
<a name="l02128"></a>02128             oldMonomers = this.monomerBoundSites(positionsStrands);
<a name="l02129"></a>02129             oldComplexs = this.complexBoundSites(positionsStrands);
<a name="l02130"></a>02130             
<a name="l02131"></a>02131             %check that changing protein identify doesn&#39;t increase footprint
<a name="l02132"></a>02132             %size (otherwise setSiteProteinBound should be used)
<a name="l02133"></a>02133             oldFootprints = zeros(size(positionsStrands, 1));
<a name="l02134"></a>02134             oldFootprints(oldMonomers ~= 0) = this.monomerDNAFootprints(oldMonomers(oldMonomers~=0));
<a name="l02135"></a>02135             oldFootprints(oldComplexs ~= 0) = this.complexDNAFootprints(oldComplexs(oldComplexs~=0));
<a name="l02136"></a>02136             
<a name="l02137"></a>02137             newFootprints = zeros(size(positionsStrands, 1));
<a name="l02138"></a>02138             newFootprints(newMonomers ~= 0) = this.monomerDNAFootprints(newMonomers(newMonomers~=0));
<a name="l02139"></a>02139             newFootprints(newComplexs ~= 0) = this.complexDNAFootprints(newComplexs(newComplexs~=0));
<a name="l02140"></a>02140             
<a name="l02141"></a>02141             if any(newFootprints &gt; oldFootprints)
<a name="l02142"></a>02142                 throw(MException(&#39;New protein footprints cannot be larger that old ones&#39;));
<a name="l02143"></a>02143             end
<a name="l02144"></a>02144             
<a name="l02145"></a>02145             %modify identities of bound proteins
<a name="l02146"></a>02146             this.monomerBoundSites(positionsStrands(newMonomers~=0, :)) = newMonomers(newMonomers~=0, :);
<a name="l02147"></a>02147             this.complexBoundSites(positionsStrands(newComplexs~=0, :)) = newComplexs(newComplexs~=0, :);
<a name="l02148"></a>02148             
<a name="l02149"></a>02149             %summarize bound/released monomers/complexs
<a name="l02150"></a>02150             releasedMonomers = zeros(size(mainEffects_monomerIndexs));
<a name="l02151"></a>02151             releasedComplexs = zeros(size(mainEffects_complexIndexs));
<a name="l02152"></a>02152             
<a name="l02153"></a>02153             oldMonomers = oldMonomers(oldMonomers~=0);
<a name="l02154"></a>02154             [tfs, idxs] = ismember(oldMonomers, mainEffects_monomerIndexs);
<a name="l02155"></a>02155             if ~all(tfs)
<a name="l02156"></a>02156                 throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;,&#39;All binding/releasing proteins must be mainEffects&#39;));
<a name="l02157"></a>02157             end
<a name="l02158"></a>02158             [idxs, counts] = countUnique(idxs);
<a name="l02159"></a>02159             releasedMonomers(idxs) = releasedMonomers(idxs) + counts;
<a name="l02160"></a>02160             
<a name="l02161"></a>02161             newMonomers = newMonomers(newMonomers~=0);
<a name="l02162"></a>02162             [tfs, idxs] = ismember(newMonomers, mainEffects_monomerIndexs);
<a name="l02163"></a>02163             if ~all(tfs)
<a name="l02164"></a>02164                 throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;,&#39;All binding/releasing proteins must be mainEffects&#39;));
<a name="l02165"></a>02165             end
<a name="l02166"></a>02166             [idxs, counts] = countUnique(idxs);
<a name="l02167"></a>02167             releasedMonomers(idxs) = releasedMonomers(idxs) - counts;
<a name="l02168"></a>02168             
<a name="l02169"></a>02169             oldComplexs = oldComplexs(oldComplexs~=0);
<a name="l02170"></a>02170             [tfs, idxs] = ismember(oldComplexs, mainEffects_complexIndexs);
<a name="l02171"></a>02171             if ~all(tfs)
<a name="l02172"></a>02172                 throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;,&#39;All binding/releasing proteins must be mainEffects&#39;));
<a name="l02173"></a>02173             end
<a name="l02174"></a>02174             [idxs, counts] = countUnique(idxs);
<a name="l02175"></a>02175             releasedComplexs(idxs) = releasedComplexs(idxs) + counts;
<a name="l02176"></a>02176             
<a name="l02177"></a>02177             newComplexs = newComplexs(newComplexs~=0);
<a name="l02178"></a>02178             [tfs, idxs] = ismember(newComplexs, mainEffects_complexIndexs);
<a name="l02179"></a>02179             if ~all(tfs)
<a name="l02180"></a>02180                 throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;,&#39;All binding/releasing proteins must be mainEffects&#39;));
<a name="l02181"></a>02181             end
<a name="l02182"></a>02182             [idxs, counts] = countUnique(idxs);
<a name="l02183"></a>02183             releasedComplexs(idxs) = releasedComplexs(idxs) - counts;
<a name="l02184"></a>02184                         
<a name="l02185"></a>02185             sideEffects = SimulationStateSideEffect.empty(0, 1);
<a name="l02186"></a>02186         end
<a name="l02187"></a>02187         
<a name="l02188"></a>02188         function [releasedMonomers, releasedComplexs, sideEffects] = setRegionProteinUnbound(this, ...
<a name="l02189"></a>02189                 positionsStrands, lengths, mainEffects_monomerIndexs, mainEffects_complexIndexs, ...
<a name="l02190"></a>02190                 regionBothStrands, bindingBothStrands, suspendExternalStateUpdating, proteinIsDegraded)
<a name="l02191"></a>02191             import edu.stanford.covert.cell.sim.SimulationStateSideEffect;
<a name="l02192"></a>02192             import edu.stanford.covert.cell.sim.SimulationStateSideEffectItem;
<a name="l02193"></a>02193             import edu.stanford.covert.util.CircularSparseMat;
<a name="l02194"></a>02194             import edu.stanford.covert.util.countUnique;
<a name="l02195"></a>02195             
<a name="l02196"></a>02196             startCoors = mod(positionsStrands(:, 1) + min(0, lengths+1) - 1, this.sequenceLen) + 1;
<a name="l02197"></a>02197             endCoors = startCoors + abs(lengths) - 1;
<a name="l02198"></a>02198             strndTimes = [positionsStrands(:, 2:end) ones(size(positionsStrands, 1), size(this.monomerBoundSites, 3) - size(positionsStrands,2))];
<a name="l02199"></a>02199             if bindingBothStrands
<a name="l02200"></a>02200                 strndTimes(:, 1) = ceil(strndTimes(:, 1) / 2); 
<a name="l02201"></a>02201             end
<a name="l02202"></a>02202             
<a name="l02203"></a>02203             tmpIdxs = find(endCoors &gt; this.sequenceLen);
<a name="l02204"></a>02204             startCoors = [startCoors; max(1, startCoors(tmpIdxs) - this.sequenceLen)];
<a name="l02205"></a>02205             endCoors = [endCoors; endCoors(tmpIdxs) - this.sequenceLen];
<a name="l02206"></a>02206             endCoors(tmpIdxs) = this.sequenceLen;
<a name="l02207"></a>02207             strndTimes = [strndTimes; strndTimes(tmpIdxs, :)];
<a name="l02208"></a>02208             
<a name="l02209"></a>02209             tmpIdxs = find(startCoors &lt; 0);
<a name="l02210"></a>02210             startCoors = [startCoors; startCoors(tmpIdxs) + this.sequenceLen];
<a name="l02211"></a>02211             endCoors = [endCoors; min(this.sequenceLen, endCoors(tmpIdxs) + this.sequenceLen)];
<a name="l02212"></a>02212             startCoors(tmpIdxs) = 1;
<a name="l02213"></a>02213             strndTimes = [strndTimes; strndTimes(tmpIdxs, :)];
<a name="l02214"></a>02214             
<a name="l02215"></a>02215             %bound monomers
<a name="l02216"></a>02216             [subs, vals] = find(this.monomerBoundSites);
<a name="l02217"></a>02217             unbindingMonomers = false(size(vals));
<a name="l02218"></a>02218             monomerStarts = subs(:, 1);
<a name="l02219"></a>02219             monomerEnds   = monomerStarts + this.monomerDNAFootprints(vals, :) - 1;
<a name="l02220"></a>02220             monomerStrndTimes = [subs(:, 2:end) ones(size(subs,1), size(strndTimes,2)-size(subs,2)+1)];
<a name="l02221"></a>02221             idxs = (1:numel(vals))&#39;;
<a name="l02222"></a>02222             if bindingBothStrands
<a name="l02223"></a>02223                 monomerStrndTimes(:, 1) = ceil(monomerStrndTimes(:, 1) / 2);
<a name="l02224"></a>02224             elseif regionBothStrands
<a name="l02225"></a>02225                 tfs = this.monomerDNAFootprintBindingStrandedness(vals) == this.dnaStrandedness_dsDNA;
<a name="l02226"></a>02226                 idxs = [idxs(~tfs); idxs(tfs); idxs(tfs)];
<a name="l02227"></a>02227                 monomerStarts = [monomerStarts(~tfs); monomerStarts(tfs); monomerStarts(tfs)];
<a name="l02228"></a>02228                 monomerEnds = [monomerEnds(~tfs); monomerEnds(tfs); monomerEnds(tfs)];
<a name="l02229"></a>02229                 monomerStrndTimes = [
<a name="l02230"></a>02230                     monomerStrndTimes(~tfs, :)
<a name="l02231"></a>02231                     2*ceil(monomerStrndTimes(tfs, 1)/2)-1 monomerStrndTimes(tfs, 2:end)
<a name="l02232"></a>02232                     2*ceil(monomerStrndTimes(tfs, 1)/2) monomerStrndTimes(tfs, 2:end)
<a name="l02233"></a>02233                     ];
<a name="l02234"></a>02234             end
<a name="l02235"></a>02235             
<a name="l02236"></a>02236             tmpIdxs = find(monomerEnds &gt; this.sequenceLen);
<a name="l02237"></a>02237             monomerStarts = [monomerStarts; ones(numel(tmpIdxs), 1)];
<a name="l02238"></a>02238             monomerEnds   = [monomerEnds;   monomerEnds(tmpIdxs, :) - this.sequenceLen];
<a name="l02239"></a>02239             monomerStrndTimes = [monomerStrndTimes; monomerStrndTimes(tmpIdxs, :)];
<a name="l02240"></a>02240             idxs = [idxs; idxs(tmpIdxs, :)];
<a name="l02241"></a>02241             
<a name="l02242"></a>02242             for i = 1:numel(startCoors)
<a name="l02243"></a>02243                 monMask = ...
<a name="l02244"></a>02244                     (monomerStarts &gt;= startCoors(i) &amp; monomerStarts &lt;= endCoors(i)) | ...
<a name="l02245"></a>02245                     (monomerEnds &gt;= startCoors(i) &amp; monomerEnds &lt;= endCoors(i)) | ...
<a name="l02246"></a>02246                     (monomerStarts &lt;= startCoors(i) &amp; monomerEnds &gt;= endCoors(i));
<a name="l02247"></a>02247                 tmpIdxs = find(monMask);
<a name="l02248"></a>02248                 if isempty(tmpIdxs); continue; end;
<a name="l02249"></a>02249                 
<a name="l02250"></a>02250                 if isvector(strndTimes)
<a name="l02251"></a>02251                     tmpIdxs = tmpIdxs(monomerStrndTimes(monMask, 1) ==  strndTimes(i, 1));
<a name="l02252"></a>02252                 elseif isscalar(tmpIdxs)
<a name="l02253"></a>02253                     tmpIdxs = tmpIdxs(all(monomerStrndTimes(monMask, :) == strndTimes(i, :)));
<a name="l02254"></a>02254                 else
<a name="l02255"></a>02255                     tmpIdxs = tmpIdxs(ismember(monomerStrndTimes(monMask, :), strndTimes(i, :), &#39;rows&#39;));
<a name="l02256"></a>02256                 end
<a name="l02257"></a>02257                 if isempty(tmpIdxs); continue; end;
<a name="l02258"></a>02258                 
<a name="l02259"></a>02259                 unbindingMonomers(idxs(tmpIdxs)) = true;
<a name="l02260"></a>02260             end            
<a name="l02261"></a>02261             
<a name="l02262"></a>02262             releasedMonomers = zeros(numel(mainEffects_monomerIndexs), 1);
<a name="l02263"></a>02263             if isempty(unbindingMonomers) || ~any(unbindingMonomers)
<a name="l02264"></a>02264                 gblIdxs = [];
<a name="l02265"></a>02265                 counts = [];                
<a name="l02266"></a>02266             elseif isscalar(unbindingMonomers)
<a name="l02267"></a>02267                 gblIdxs = vals(unbindingMonomers);
<a name="l02268"></a>02268                 counts = 1;
<a name="l02269"></a>02269                 releasedMonomers(gblIdxs == mainEffects_monomerIndexs, 1) = 1;
<a name="l02270"></a>02270             else
<a name="l02271"></a>02271                 [gblIdxs, counts] = countUnique(vals(unbindingMonomers, 1));
<a name="l02272"></a>02272                 [tfs, lclIdxs] = ismember(gblIdxs, mainEffects_monomerIndexs);
<a name="l02273"></a>02273                 
<a name="l02274"></a>02274                 releasedMonomers(lclIdxs(tfs)) = counts(tfs);
<a name="l02275"></a>02275                 
<a name="l02276"></a>02276                 tfs = tfs | gblIdxs == 0;
<a name="l02277"></a>02277                 gblIdxs = gblIdxs(~tfs);
<a name="l02278"></a>02278                 counts = counts(~tfs);
<a name="l02279"></a>02279             end
<a name="l02280"></a>02280 
<a name="l02281"></a>02281             if isempty(gblIdxs)
<a name="l02282"></a>02282                 sideEffects_releasedMonomers = SimulationStateSideEffect.empty(0, 1);
<a name="l02283"></a>02283             else
<a name="l02284"></a>02284                 sideEffects_releasedMonomers = SimulationStateSideEffect.empty(numel(gblIdxs), 0);
<a name="l02285"></a>02285             end
<a name="l02286"></a>02286             for i = 1:numel(gblIdxs)
<a name="l02287"></a>02287                 sideEffects_releasedMonomers(i, 1) = SimulationStateSideEffect([...
<a name="l02288"></a>02288                     SimulationStateSideEffectItem(&#39;<a class="code" href="class_protein_monomer.html">ProteinMonomer</a>&#39;, &#39;counts&#39;, &#39;matureIndexs&#39;, gblIdxs(i), this.compartment.cytosolIndexs,  counts(i)); ...
<a name="l02289"></a>02289                     SimulationStateSideEffectItem(&#39;ProteinMonomer&#39;, &#39;counts&#39;, &#39;boundIndexs&#39;,  gblIdxs(i), this.compartment.cytosolIndexs, -counts(i))]);
<a name="l02290"></a>02290             end
<a name="l02291"></a>02291             
<a name="l02292"></a>02292             unbindingMonomerSubs = subs(unbindingMonomers, :);
<a name="l02293"></a>02293             unbindingMonomerVals = vals(unbindingMonomers, :);
<a name="l02294"></a>02294             this.monomerBoundSites = CircularSparseMat(subs(~unbindingMonomers, :), vals(~unbindingMonomers, 1), [this.sequenceLen this.nCompartments], 1);
<a name="l02295"></a>02295             
<a name="l02296"></a>02296             %bound complexes
<a name="l02297"></a>02297             [subs, vals] = find(this.complexBoundSites);
<a name="l02298"></a>02298             unbindingComplexs = false(size(vals));
<a name="l02299"></a>02299             complexStarts = subs(:, 1);
<a name="l02300"></a>02300             complexEnds   = complexStarts + this.complexDNAFootprints(vals, :) - 1;
<a name="l02301"></a>02301             complexStrndTimes = [subs(:, 2:end) ones(size(subs,1), size(strndTimes,2)-size(subs,2)+1)];
<a name="l02302"></a>02302             idxs = (1:numel(vals))&#39;;
<a name="l02303"></a>02303             if bindingBothStrands
<a name="l02304"></a>02304                 complexStrndTimes(:, 1) = ceil(complexStrndTimes(:, 1) / 2);
<a name="l02305"></a>02305             elseif regionBothStrands
<a name="l02306"></a>02306                 tfs = this.complexDNAFootprintBindingStrandedness(vals) == this.dnaStrandedness_dsDNA;
<a name="l02307"></a>02307                 idxs = [idxs(~tfs); idxs(tfs); idxs(tfs)];
<a name="l02308"></a>02308                 complexStarts = [complexStarts(~tfs); complexStarts(tfs); complexStarts(tfs)];
<a name="l02309"></a>02309                 complexEnds = [complexEnds(~tfs); complexEnds(tfs); complexEnds(tfs)];
<a name="l02310"></a>02310                 complexStrndTimes = [
<a name="l02311"></a>02311                     complexStrndTimes(~tfs, :)
<a name="l02312"></a>02312                     2*ceil(complexStrndTimes(tfs, 1)/2)-1 complexStrndTimes(tfs, 2:end)
<a name="l02313"></a>02313                     2*ceil(complexStrndTimes(tfs, 1)/2) complexStrndTimes(tfs, 2:end)
<a name="l02314"></a>02314                     ];
<a name="l02315"></a>02315             end
<a name="l02316"></a>02316             
<a name="l02317"></a>02317             tmpIdxs = find(complexEnds &gt; this.sequenceLen);
<a name="l02318"></a>02318             complexStarts = [complexStarts; ones(numel(tmpIdxs), 1)];
<a name="l02319"></a>02319             complexEnds   = [complexEnds;   complexEnds(tmpIdxs, :) - this.sequenceLen];
<a name="l02320"></a>02320             complexStrndTimes    = [complexStrndTimes; complexStrndTimes(tmpIdxs, :)];
<a name="l02321"></a>02321             idxs = [idxs; idxs(tmpIdxs, :)];
<a name="l02322"></a>02322             
<a name="l02323"></a>02323             for i = 1:numel(startCoors)
<a name="l02324"></a>02324                 comMask = ...
<a name="l02325"></a>02325                     (complexStarts &gt;= startCoors(i) &amp; complexStarts &lt;= endCoors(i)) | ...
<a name="l02326"></a>02326                     (complexEnds &gt;= startCoors(i) &amp; complexEnds &lt;= endCoors(i)) | ...
<a name="l02327"></a>02327                     (complexStarts &lt;= startCoors(i) &amp; complexEnds &gt;= endCoors(i));
<a name="l02328"></a>02328                 tmpIdxs = find(comMask);
<a name="l02329"></a>02329                 if isempty(tmpIdxs); continue; end;
<a name="l02330"></a>02330                 
<a name="l02331"></a>02331                 if isvector(strndTimes)
<a name="l02332"></a>02332                     tmpIdxs = tmpIdxs(complexStrndTimes(comMask, 1) ==  strndTimes(i, 1));
<a name="l02333"></a>02333                 elseif isscalar(tmpIdxs)
<a name="l02334"></a>02334                     tmpIdxs = tmpIdxs(all(complexStrndTimes(comMask, :) == strndTimes(i, :)));
<a name="l02335"></a>02335                 else
<a name="l02336"></a>02336                     tmpIdxs = tmpIdxs(ismember(complexStrndTimes(comMask, :), strndTimes(i, :), &#39;rows&#39;));
<a name="l02337"></a>02337                 end                
<a name="l02338"></a>02338                 if isempty(tmpIdxs); continue; end;
<a name="l02339"></a>02339                 
<a name="l02340"></a>02340                 unbindingComplexs(idxs(tmpIdxs)) = true;
<a name="l02341"></a>02341             end
<a name="l02342"></a>02342             
<a name="l02343"></a>02343             releasedComplexs = zeros(numel(mainEffects_complexIndexs), 1);
<a name="l02344"></a>02344             if isempty(unbindingComplexs) || ~any(unbindingComplexs)
<a name="l02345"></a>02345                 gblIdxs = [];
<a name="l02346"></a>02346                 counts = [];
<a name="l02347"></a>02347             elseif isscalar(unbindingComplexs)
<a name="l02348"></a>02348                 gblIdxs = vals(unbindingComplexs);
<a name="l02349"></a>02349                 counts = 1;
<a name="l02350"></a>02350                 releasedComplexs(gblIdxs == mainEffects_complexIndexs, 1) = 1;
<a name="l02351"></a>02351             else
<a name="l02352"></a>02352                 [gblIdxs, counts] = countUnique(vals(unbindingComplexs, 1));
<a name="l02353"></a>02353                 [tfs, lclIdxs] = ismember(gblIdxs, mainEffects_complexIndexs);
<a name="l02354"></a>02354                 
<a name="l02355"></a>02355                 releasedComplexs(lclIdxs(tfs)) = counts(tfs);
<a name="l02356"></a>02356                 
<a name="l02357"></a>02357                 tfs = tfs | gblIdxs == 0;
<a name="l02358"></a>02358                 gblIdxs = gblIdxs(~tfs);
<a name="l02359"></a>02359                 counts = counts(~tfs);
<a name="l02360"></a>02360             end
<a name="l02361"></a>02361             
<a name="l02362"></a>02362             if isempty(gblIdxs)
<a name="l02363"></a>02363                 sideEffects_releasedComplexs = SimulationStateSideEffect.empty(0, 1);
<a name="l02364"></a>02364             else
<a name="l02365"></a>02365                 sideEffects_releasedComplexs = SimulationStateSideEffect.empty(numel(gblIdxs), 0);
<a name="l02366"></a>02366             end
<a name="l02367"></a>02367             for i = 1:numel(gblIdxs)
<a name="l02368"></a>02368                 sideEffects_releasedComplexs(i, 1) = SimulationStateSideEffect([...
<a name="l02369"></a>02369                     SimulationStateSideEffectItem(&#39;<a class="code" href="class_protein_complex.html">ProteinComplex</a>&#39;, &#39;counts&#39;, &#39;matureIndexs&#39;, gblIdxs(i), this.compartment.cytosolIndexs,  counts(i)); ...
<a name="l02370"></a>02370                     SimulationStateSideEffectItem(&#39;ProteinComplex&#39;, &#39;counts&#39;, &#39;boundIndexs&#39;,  gblIdxs(i), this.compartment.cytosolIndexs, -counts(i))]);
<a name="l02371"></a>02371             end
<a name="l02372"></a>02372             
<a name="l02373"></a>02373             unbindingComplexSubs = subs(unbindingComplexs, :);
<a name="l02374"></a>02374             unbindingComplexVals = vals(unbindingComplexs, :);
<a name="l02375"></a>02375             this.complexBoundSites = CircularSparseMat(subs(~unbindingComplexs, :), vals(~unbindingComplexs, 1), [this.sequenceLen this.nCompartments], 1);
<a name="l02376"></a>02376             
<a name="l02377"></a>02377             %effects on other states
<a name="l02378"></a>02378             if ~suspendExternalStateUpdating
<a name="l02379"></a>02379                 this.updateExternalState(unbindingMonomerSubs, unbindingMonomerVals, unbindingComplexSubs, unbindingComplexVals, proteinIsDegraded);
<a name="l02380"></a>02380             end
<a name="l02381"></a>02381             
<a name="l02382"></a>02382             %side effects
<a name="l02383"></a>02383             sideEffects = [
<a name="l02384"></a>02384                 sideEffects_releasedMonomers;
<a name="l02385"></a>02385                 sideEffects_releasedComplexs];
<a name="l02386"></a>02386         end
<a name="l02387"></a>02387         
<a name="l02388"></a>02388         function [positionsStrands, sideEffects] = stochasticallySetProteinUnbound(this, monomerIndex, complexIndex, ...
<a name="l02389"></a>02389                 rate, protectedPositionsStrands, protectedLengths, suspendExternalStateUpdating, proteinIsDegraded)
<a name="l02390"></a>02390             import edu.stanford.covert.cell.sim.SimulationStateSideEffect;
<a name="l02391"></a>02391             import edu.stanford.covert.util.CircularSparseMat;
<a name="l02392"></a>02392             
<a name="l02393"></a>02393             sideEffects = SimulationStateSideEffect.empty(0, 1);
<a name="l02394"></a>02394             
<a name="l02395"></a>02395             if ~isempty(monomerIndex)
<a name="l02396"></a>02396                 if ~isempty(complexIndex)
<a name="l02397"></a>02397                     throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:invalidInput&#39;, &#39;Can only unbind one protein at a time&#39;));
<a name="l02398"></a>02398                 end
<a name="l02399"></a>02399                 [positionsStrands, proteins] = find(this.monomerBoundSites);
<a name="l02400"></a>02400                 unbinding = proteins == monomerIndex;
<a name="l02401"></a>02401             elseif ~isempty(complexIndex)
<a name="l02402"></a>02402                 [positionsStrands, proteins] = find(this.complexBoundSites);
<a name="l02403"></a>02403                 unbinding = proteins == complexIndex;
<a name="l02404"></a>02404             else
<a name="l02405"></a>02405                 positionsStrands = zeros(0, 2);
<a name="l02406"></a>02406                 return;
<a name="l02407"></a>02407             end
<a name="l02408"></a>02408             if ~any(unbinding)
<a name="l02409"></a>02409                 positionsStrands = zeros(0, 2);
<a name="l02410"></a>02410                 return;
<a name="l02411"></a>02411             end
<a name="l02412"></a>02412             
<a name="l02413"></a>02413             %randomly select bound protein to release at specified rate
<a name="l02414"></a>02414             if isfinite(rate)
<a name="l02415"></a>02415                 unbinding(unbinding) = this.randStream.rand(sum(unbinding), 1) &lt; rate;
<a name="l02416"></a>02416                 if ~any(unbinding)
<a name="l02417"></a>02417                     positionsStrands = zeros(0, 2);
<a name="l02418"></a>02418                     return;
<a name="l02419"></a>02419                 end
<a name="l02420"></a>02420             end
<a name="l02421"></a>02421             
<a name="l02422"></a>02422             %exclude protected sites
<a name="l02423"></a>02423             if ~isempty(protectedPositionsStrands)
<a name="l02424"></a>02424                 footprint = this.getDNAFootprint(monomerIndex, complexIndex);
<a name="l02425"></a>02425                 for i = 1:size(protectedPositionsStrands, 1)
<a name="l02426"></a>02426                     unbndPosStrnds = positionsStrands(unbinding, :);
<a name="l02427"></a>02427                     
<a name="l02428"></a>02428                     tfs = ...
<a name="l02429"></a>02429                         (unbndPosStrnds(:, 1)                 &gt;= protectedPositionsStrands(i, 1) &amp; ...
<a name="l02430"></a>02430                          unbndPosStrnds(:, 1)                 &lt;= protectedPositionsStrands(i, 1) + protectedLengths(i) - 1) | ...
<a name="l02431"></a>02431                         (unbndPosStrnds(: ,1) + footprint - 1 &gt;= protectedPositionsStrands(i, 1) &amp; ...
<a name="l02432"></a>02432                          unbndPosStrnds(:, 1) + footprint - 1 &lt;= protectedPositionsStrands(i, 1) + protectedLengths(i) - 1) | ...
<a name="l02433"></a>02433                         (unbndPosStrnds(:, 1)                 &lt;= protectedPositionsStrands(i, 1) &amp; ...
<a name="l02434"></a>02434                          unbndPosStrnds(:, 1) + footprint - 1 &gt;= protectedPositionsStrands(i, 1) + protectedLengths(i) - 1);
<a name="l02435"></a>02435                     
<a name="l02436"></a>02436                     tfs(tfs) = unbndPosStrnds(tfs, 2) == protectedPositionsStrands(i, 2);
<a name="l02437"></a>02437                     
<a name="l02438"></a>02438                     unbinding(unbinding) = ~tfs;
<a name="l02439"></a>02439                     
<a name="l02440"></a>02440                     if all(tfs)
<a name="l02441"></a>02441                         positionsStrands = zeros(0, 2);
<a name="l02442"></a>02442                         return;
<a name="l02443"></a>02443                     end
<a name="l02444"></a>02444                 end
<a name="l02445"></a>02445             end
<a name="l02446"></a>02446             
<a name="l02447"></a>02447             %update bound proteins
<a name="l02448"></a>02448             if ~isempty(monomerIndex)
<a name="l02449"></a>02449                 unbindingMonomerSubs = positionsStrands(unbinding, :);
<a name="l02450"></a>02450                 unbindingMonomerVals = proteins(unbinding, 1);
<a name="l02451"></a>02451                 unbindingComplexSubs = zeros(0, 2);
<a name="l02452"></a>02452                 unbindingComplexVals = zeros(0, 1);
<a name="l02453"></a>02453                 this.monomerBoundSites = CircularSparseMat(positionsStrands(~unbinding, :), proteins(~unbinding, 1), [this.sequenceLen this.nCompartments], 1);
<a name="l02454"></a>02454             else
<a name="l02455"></a>02455                 unbindingMonomerSubs = zeros(0, 2);
<a name="l02456"></a>02456                 unbindingMonomerVals = zeros(0, 1);
<a name="l02457"></a>02457                 unbindingComplexSubs = positionsStrands(unbinding, :);
<a name="l02458"></a>02458                 unbindingComplexVals = proteins(unbinding, 1);
<a name="l02459"></a>02459                 this.complexBoundSites = CircularSparseMat(positionsStrands(~unbinding, :), proteins(~unbinding, 1), [this.sequenceLen this.nCompartments], 1);
<a name="l02460"></a>02460             end
<a name="l02461"></a>02461             positionsStrands = positionsStrands(unbinding, :);
<a name="l02462"></a>02462             
<a name="l02463"></a>02463             %effects on other states
<a name="l02464"></a>02464             if ~suspendExternalStateUpdating
<a name="l02465"></a>02465                 this.updateExternalState(unbindingMonomerSubs, unbindingMonomerVals, unbindingComplexSubs, unbindingComplexVals, proteinIsDegraded);
<a name="l02466"></a>02466             end
<a name="l02467"></a>02467         end
<a name="l02468"></a>02468         
<a name="l02469"></a>02469         function updateExternalState(this, ~, ~, unbindingComplexSubs, unbindingComplexVals, proteinIsDegraded)
<a name="l02470"></a>02470             posStrnds = unbindingComplexSubs(ismembc(unbindingComplexVals, this.complexIndexs_rnaPolymerase), :);
<a name="l02471"></a>02471             if ~isempty(posStrnds)
<a name="l02472"></a>02472                 [~, footprint3Prime, footprint5Prime] = this.getDNAFootprint([], this.complexIndexs_rnaPolymerase);
<a name="l02473"></a>02473                 posStrnds( isodd(posStrnds(:, 2)), 1) = posStrnds( isodd(posStrnds(:, 2)), 1) + footprint5Prime;
<a name="l02474"></a>02474                 posStrnds(iseven(posStrnds(:, 2)), 1) = posStrnds(iseven(posStrnds(:, 2)), 1) + footprint3Prime;
<a name="l02475"></a>02475                 this.rnaPolymerase.releasePolymerase(posStrnds, proteinIsDegraded);
<a name="l02476"></a>02476             end
<a name="l02477"></a>02477         end
<a name="l02478"></a>02478         
<a name="l02479"></a>02479         function [positionsStrands, sideEffects] = setSiteDamaged(this, ...
<a name="l02480"></a>02480                 damageType, damageSubType, probDamage, maxDamages, ...
<a name="l02481"></a>02481                 vulnerableMotif, vulnerableMotifType)
<a name="l02482"></a>02482             import edu.stanford.covert.cell.sim.SimulationStateSideEffect;
<a name="l02483"></a>02483             
<a name="l02484"></a>02484             %side effects
<a name="l02485"></a>02485             sideEffects = SimulationStateSideEffect.empty(0, 1);
<a name="l02486"></a>02486             positionsStrands = zeros(0, 2);
<a name="l02487"></a>02487             
<a name="l02488"></a>02488             %return if probability of damage is 0
<a name="l02489"></a>02489             if probDamage == 0 || maxDamages == 0
<a name="l02490"></a>02490                 return;
<a name="l02491"></a>02491             end
<a name="l02492"></a>02492             
<a name="l02493"></a>02493             %sample vulnerable sites
<a name="l02494"></a>02494             if ischar(vulnerableMotif)
<a name="l02495"></a>02495                 positionsStrands = this.sampleAccessibleSites(probDamage, maxDamages, vulnerableMotif);
<a name="l02496"></a>02496             else
<a name="l02497"></a>02497                 if nnz(this.(vulnerableMotifType)) == 0
<a name="l02498"></a>02498                     return;
<a name="l02499"></a>02499                 end
<a name="l02500"></a>02500                 positionsStrands = find( ...
<a name="l02501"></a>02501                     vulnerableMotif == this.(vulnerableMotifType) &amp; ...
<a name="l02502"></a>02502                     vulnerableMotif == this.damagedSites_nonRedundant);
<a name="l02503"></a>02503                 if isempty(positionsStrands)
<a name="l02504"></a>02504                     return;
<a name="l02505"></a>02505                 end
<a name="l02506"></a>02506                 maxDamages = min(maxDamages, ...
<a name="l02507"></a>02507                     this.randStream.stochasticRound(size(positionsStrands, 1) * probDamage));
<a name="l02508"></a>02508                 if maxDamages == 0
<a name="l02509"></a>02509                     return;
<a name="l02510"></a>02510                 end
<a name="l02511"></a>02511                 positionsStrands = this.randStream.randomlySelectNRows(positionsStrands, maxDamages);
<a name="l02512"></a>02512             end
<a name="l02513"></a>02513             if isempty(positionsStrands)
<a name="l02514"></a>02514                 return;
<a name="l02515"></a>02515             end
<a name="l02516"></a>02516             
<a name="l02517"></a>02517             %damage selected sites
<a name="l02518"></a>02518             this.(damageType)(positionsStrands) = damageSubType;
<a name="l02519"></a>02519         end
<a name="l02520"></a>02520     end
<a name="l02521"></a>02521     
<a name="l02522"></a>02522     %private methods which modify this class&#39; state, and possibly request
<a name="l02523"></a>02523     %changes that of other parts of the simulation&#39;s state
<a name="l02524"></a>02524     methods
<a name="l02525"></a>02525         function mergeOwnAdjacentRegions(this)
<a name="l02526"></a>02526             import edu.stanford.covert.util.CircularSparseMat;
<a name="l02527"></a>02527 
<a name="l02528"></a>02528             if nnz(this.polymerizedRegions) &lt;= 1
<a name="l02529"></a>02529                 return;
<a name="l02530"></a>02530             end
<a name="l02531"></a>02531             
<a name="l02532"></a>02532             %% add linking numbers for adjacent <span class="keywordtype">double</span>-stranded regions
<a name="l02533"></a>02533             
<a name="l02534"></a>02534             %convert from SparseMat to coordinates
<a name="l02535"></a>02535             [dsPosStrands, lengths] = find(this.doubleStrandedRegions);
<a name="l02536"></a>02536             [lkPosStrands, oldLKNums] = find(this.linkingNumbers);
<a name="l02537"></a>02537 
<a name="l02538"></a>02538             %combine linking numbers for adjacent <span class="keywordtype">double</span>-stranded regions
<a name="l02539"></a>02539             lkNums = zeros(size(lengths));
<a name="l02540"></a>02540             for i = 1:size(lkPosStrands,1)
<a name="l02541"></a>02541                 idx = find(...
<a name="l02542"></a>02542                     lkPosStrands(i, 1) &gt;= dsPosStrands(:, 1)           &amp; ...
<a name="l02543"></a>02543                     lkPosStrands(i, 1) &lt;= dsPosStrands(:, 1) + lengths &amp; ...
<a name="l02544"></a>02544                     lkPosStrands(i, 2) == dsPosStrands(:, 2));
<a name="l02545"></a>02545                 lkNums(idx) = lkNums(idx) + oldLKNums(i);
<a name="l02546"></a>02546             end
<a name="l02547"></a>02547             
<a name="l02548"></a>02548             %convert from coordinates to SparseMat
<a name="l02549"></a>02549             this.linkingNumbers = CircularSparseMat(...
<a name="l02550"></a>02550                 dsPosStrands, lkNums, size(this.linkingNumbers), 1);
<a name="l02551"></a>02551 
<a name="l02552"></a>02552             %% merge adjacent regions
<a name="l02553"></a>02553             this.polymerizedRegions = this.mergeAdjacentRegions(this.polymerizedRegions);            
<a name="l02554"></a>02554         end
<a name="l02555"></a>02555         
<a name="l02556"></a>02556         function polymerizedRegions = mergeAdjacentRegions(~, polymerizedRegions)
<a name="l02557"></a>02557             import edu.stanford.covert.util.CircularSparseMat;
<a name="l02558"></a>02558 
<a name="l02559"></a>02559             if nnz(polymerizedRegions) &lt;= 1
<a name="l02560"></a>02560                 return;
<a name="l02561"></a>02561             end
<a name="l02562"></a>02562 
<a name="l02563"></a>02563             %% merge adjacent regions
<a name="l02564"></a>02564             %convert from SparseMat to coordinates
<a name="l02565"></a>02565             [positionsStrands, lengths] = find(polymerizedRegions);
<a name="l02566"></a>02566             
<a name="l02567"></a>02567             %make sure that regions don&#39;t overlap
<a name="l02568"></a>02568             if any(lengths &lt; 0) || ...
<a name="l02569"></a>02569                any(diff(positionsStrands(:,1)) &lt; lengths(1:end-1) &amp; diff(positionsStrands(:,2)) == 0)
<a name="l02570"></a>02570                 throw(MException(&#39;<a class="code" href="class_chromosome.html">Chromosome</a>:error&#39;,&#39;polymerizedRegions is corrupt&#39;))
<a name="l02571"></a>02571             end
<a name="l02572"></a>02572             
<a name="l02573"></a>02573             %merge adjacent regions (except over OriC)
<a name="l02574"></a>02574             idxs = find(diff(positionsStrands(:,1)) == lengths(1:end-1) &amp; diff(positionsStrands(:,2)) == 0);
<a name="l02575"></a>02575             for i = numel(idxs):-1:1
<a name="l02576"></a>02576                 j = idxs(i);
<a name="l02577"></a>02577                 lengths(j, 1) = lengths(j, 1) + lengths(j+1, 1);
<a name="l02578"></a>02578             end
<a name="l02579"></a>02579             positionsStrands(idxs+1, :) = [];
<a name="l02580"></a>02580             lengths(idxs+1, :) = [];
<a name="l02581"></a>02581 
<a name="l02582"></a>02582             %% convert from coordinates to SparseMat
<a name="l02583"></a>02583             polymerizedRegions = CircularSparseMat(positionsStrands, lengths, size(polymerizedRegions), 1);
<a name="l02584"></a>02584         end
<a name="l02585"></a>02585 
<a name="l02586"></a>02586         function [rgnPosStrnds, rgnLens] = excludeRegions(this, incPosStrnds, incLens, excPosStrnds, excLens)
<a name="l02587"></a>02587             L = this.sequenceLen;
<a name="l02588"></a>02588             
<a name="l02589"></a>02589             %options
<a name="l02590"></a>02590             if isscalar(excLens)
<a name="l02591"></a>02591                 excLens = excLens(ones(size(excPosStrnds,1), 1), 1);
<a name="l02592"></a>02592             end
<a name="l02593"></a>02593             
<a name="l02594"></a>02594             %join included regions
<a name="l02595"></a>02595             [incPosStrnds, incLens] = this.joinSplitOverOriCRegions(incPosStrnds, incLens);
<a name="l02596"></a>02596             
<a name="l02597"></a>02597             %exclude excluded regions
<a name="l02598"></a>02598             [excPosStrnds, excLens] = this.joinSplitRegions(excPosStrnds, excLens);            
<a name="l02599"></a>02599             
<a name="l02600"></a>02600             excPos = [
<a name="l02601"></a>02601                 excPosStrnds(:, 1) - L;
<a name="l02602"></a>02602                 excPosStrnds(:, 1);
<a name="l02603"></a>02603                 excPosStrnds(:, 1) + L];
<a name="l02604"></a>02604             excStrnds = [excPosStrnds(:, 2); excPosStrnds(:, 2); excPosStrnds(:, 2)];
<a name="l02605"></a>02605             excLens = [excLens; excLens; excLens];
<a name="l02606"></a>02606             
<a name="l02607"></a>02607             rgnPos = zeros(0, 1);
<a name="l02608"></a>02608             rgnEnds = zeros(0, 1);
<a name="l02609"></a>02609             rgnStrnds = zeros(0, 1);
<a name="l02610"></a>02610             for j = 1:size(incPosStrnds, 1)
<a name="l02611"></a>02611                 startCoor = incPosStrnds(j, 1);
<a name="l02612"></a>02612                 endCoor = startCoor + incLens(j) - 1;
<a name="l02613"></a>02613                 strnd = incPosStrnds(j, 2);
<a name="l02614"></a>02614                 
<a name="l02615"></a>02615                 excIdxs = find(...
<a name="l02616"></a>02616                     ((excPos &lt;= startCoor &amp; excPos + excLens-1 &gt;= startCoor) | ...
<a name="l02617"></a>02617                     (excPos &lt;= endCoor &amp; excPos + excLens-1 &gt;= endCoor) | ...
<a name="l02618"></a>02618                     (excPos &gt;= startCoor &amp; excPos + excLens-1 &lt;= endCoor)) &amp; ...
<a name="l02619"></a>02619                     excStrnds == strnd);
<a name="l02620"></a>02620                 
<a name="l02621"></a>02621                 if isempty(excIdxs)
<a name="l02622"></a>02622                     addtlPos = startCoor;
<a name="l02623"></a>02623                     addtlEnds = endCoor;
<a name="l02624"></a>02624                 elseif excPos(excIdxs(1)) &lt;= startCoor
<a name="l02625"></a>02625                     if excPos(excIdxs(end)) + excLens(end) - 1 &gt;= endCoor
<a name="l02626"></a>02626                         addtlPos = excPos(excIdxs(1:end-1)) + excLens(excIdxs(1:end-1));
<a name="l02627"></a>02627                         addtlEnds = excPos(excIdxs(2:end))-1;
<a name="l02628"></a>02628                     else
<a name="l02629"></a>02629                         addtlPos = excPos(excIdxs) + excLens(excIdxs);
<a name="l02630"></a>02630                         addtlEnds = [excPos(excIdxs(2:end))-1; endCoor];
<a name="l02631"></a>02631                     end
<a name="l02632"></a>02632                 else
<a name="l02633"></a>02633                     if excPos(excIdxs(end)) + excLens(end) - 1 &gt;= endCoor
<a name="l02634"></a>02634                         addtlPos = [startCoor; excPos(excIdxs(1:end-1)) + excLens(excIdxs(1:end-1))];
<a name="l02635"></a>02635                         addtlEnds = excPos(excIdxs)-1;
<a name="l02636"></a>02636                     else
<a name="l02637"></a>02637                         addtlPos = [startCoor; excPos(excIdxs) + excLens(excIdxs)];
<a name="l02638"></a>02638                         addtlEnds = [excPos(excIdxs)-1; endCoor];
<a name="l02639"></a>02639                     end
<a name="l02640"></a>02640                 end
<a name="l02641"></a>02641                 
<a name="l02642"></a>02642                 rgnPos = [
<a name="l02643"></a>02643                     rgnPos;
<a name="l02644"></a>02644                     addtlPos];
<a name="l02645"></a>02645                 rgnEnds = [
<a name="l02646"></a>02646                     rgnEnds;
<a name="l02647"></a>02647                     addtlEnds];
<a name="l02648"></a>02648                 rgnStrnds = [
<a name="l02649"></a>02649                     rgnStrnds;
<a name="l02650"></a>02650                     strnd(ones(size(addtlPos)), 1)];
<a name="l02651"></a>02651             end
<a name="l02652"></a>02652             
<a name="l02653"></a>02653             idx = find(rgnPos &gt; L);
<a name="l02654"></a>02654             rgnPos(idx) = rgnPos(idx) - L;
<a name="l02655"></a>02655             rgnEnds(idx) = rgnEnds(idx) - L;
<a name="l02656"></a>02656             
<a name="l02657"></a>02657             idx = find(rgnPos &gt; rgnEnds);
<a name="l02658"></a>02658             rgnPos(idx,:) = [];
<a name="l02659"></a>02659             rgnEnds(idx,:) = [];
<a name="l02660"></a>02660             rgnStrnds(idx,:) = [];
<a name="l02661"></a>02661             
<a name="l02662"></a>02662             %join split regions
<a name="l02663"></a>02663             [rgnPosStrnds, rgnLens] = this.joinSplitOverOriCRegions([rgnPos rgnStrnds], rgnEnds - rgnPos + 1);
<a name="l02664"></a>02664             
<a name="l02665"></a>02665             %format output
<a name="l02666"></a>02666             rgnPosStrnds(:, 1) = mod(rgnPosStrnds(:, 1) - 1, L) + 1;
<a name="l02667"></a>02667             [rgnPosStrnds, order] = edu.stanford.covert.util.SparseMat.sort_subs(rgnPosStrnds, [L this.nCompartments]);
<a name="l02668"></a>02668             rgnLens = rgnLens(order, :);
<a name="l02669"></a>02669         end
<a name="l02670"></a>02670 
<a name="l02671"></a>02671         %finds the intersection of two lists of regions
<a name="l02672"></a>02672         function [posStrnds, lens] = intersectRegions(this, posStrndsA, lensA, posStrndsB, lensB)
<a name="l02673"></a>02673             [posStrndsA lensA] = this.splitOverOriC(posStrndsA, lensA);
<a name="l02674"></a>02674             posStrndsA(:, 1) = mod(posStrndsA(:, 1) - 1, this.sequenceLen) + 1;
<a name="l02675"></a>02675             [posStrndsA, idxs] = edu.stanford.covert.util.SparseMat.sort_subs(posStrndsA, [this.sequenceLen this.nCompartments]);
<a name="l02676"></a>02676             lensA = lensA(idxs);
<a name="l02677"></a>02677 
<a name="l02678"></a>02678             [posStrndsB lensB] = this.splitOverOriC(posStrndsB, lensB);            
<a name="l02679"></a>02679             posStrndsB(:, 1) = mod(posStrndsB(:, 1) - 1, this.sequenceLen) + 1;
<a name="l02680"></a>02680             [posStrndsB, idxs] = edu.stanford.covert.util.SparseMat.sort_subs(posStrndsB, [this.sequenceLen this.nCompartments]);
<a name="l02681"></a>02681             lensB = lensB(idxs);
<a name="l02682"></a>02682 
<a name="l02683"></a>02683             posStrnds = zeros(0, 2);
<a name="l02684"></a>02684             lens = zeros(0, 1);
<a name="l02685"></a>02685             for strand = 1:this.nCompartments
<a name="l02686"></a>02686                 rowsA = posStrndsA(:,2) == strand;
<a name="l02687"></a>02687                 rowsB = posStrndsB(:,2) == strand;
<a name="l02688"></a>02688                 posA = posStrndsA(rowsA, 1);
<a name="l02689"></a>02689                 posB = posStrndsB(rowsB, 1);
<a name="l02690"></a>02690                 lenA = lensA(rowsA, 1);
<a name="l02691"></a>02691                 lenB = lensB(rowsB, 1);
<a name="l02692"></a>02692                 iA = 1;
<a name="l02693"></a>02693                 iB = 1;
<a name="l02694"></a>02694                 <a class="code" href="json_parse_8m.html#ad2fc293e8080616c8c1e2ffbd7b86742">while</a> iA &lt;= length(posA) &amp;&amp; iB &lt;= length(posB)
<a name="l02695"></a>02695                     if posA(iA) &lt;= posB(iB)
<a name="l02696"></a>02696                         if posA(iA) + lenA(iA) &gt; posB(iB)
<a name="l02697"></a>02697                             posStrnds(end+1,:) = [posB(iB) strand];
<a name="l02698"></a>02698                             if posA(iA) + lenA(iA) &lt; posB(iB) + lenB(iB)
<a name="l02699"></a>02699                                 lens(end+1,:) = posA(iA) + lenA(iA) - posB(iB);
<a name="l02700"></a>02700                                 iA = iA + 1;
<a name="l02701"></a>02701                             else
<a name="l02702"></a>02702                                 lens(end+1,:) = lenB(iB);
<a name="l02703"></a>02703                                 iB = iB + 1;
<a name="l02704"></a>02704                             end
<a name="l02705"></a>02705                         else
<a name="l02706"></a>02706                             iA = iA + 1;
<a name="l02707"></a>02707                         end
<a name="l02708"></a>02708                     else
<a name="l02709"></a>02709                         if posB(iB) + lenB(iB) &gt; posA(iA)
<a name="l02710"></a>02710                             posStrnds(end+1,:) = [posA(iA) strand];
<a name="l02711"></a>02711                             if posB(iB) + lenB(iB) &lt; posA(iA) + lenA(iA)
<a name="l02712"></a>02712                                 lens(end+1,:) = posB(iB) + lenB(iB) - posA(iA);
<a name="l02713"></a>02713                                 iB = iB + 1;
<a name="l02714"></a>02714                             else
<a name="l02715"></a>02715                                 lens(end+1,:) = lenA(iA);
<a name="l02716"></a>02716                                 iA = iA + 1;
<a name="l02717"></a>02717                             end
<a name="l02718"></a>02718                         else
<a name="l02719"></a>02719                             iB = iB + 1;
<a name="l02720"></a>02720                         end
<a name="l02721"></a>02721                     end
<a name="l02722"></a>02722                 end
<a name="l02723"></a>02723             end
<a name="l02724"></a>02724 
<a name="l02725"></a>02725             [posStrnds, lens] = this.joinSplitOverOriCRegions(posStrnds, lens);
<a name="l02726"></a>02726         end
<a name="l02727"></a>02727 
<a name="l02728"></a>02728         %split regions into several splitLen sized pieces
<a name="l02729"></a>02729         function [posStrnds, lens] = splitRegions(~, rgnPosStrnds, rgnLens, splitLen)
<a name="l02730"></a>02730             nPos = sum(floor(abs(rgnLens)/splitLen));
<a name="l02731"></a>02731             posStrnds = zeros(nPos, 2);
<a name="l02732"></a>02732             lens = repmat(splitLen, nPos, 1);
<a name="l02733"></a>02733             
<a name="l02734"></a>02734             j = 0;
<a name="l02735"></a>02735             for i = 1:size(rgnPosStrnds, 1)
<a name="l02736"></a>02736                 nPos = floor(abs(rgnLens(i))/splitLen);
<a name="l02737"></a>02737                 
<a name="l02738"></a>02738                 posStrnds(j+(1:nPos), 1) = rgnPosStrnds(i, 1) + sign(rgnLens(i))*(0:nPos-1)*splitLen;
<a name="l02739"></a>02739                 posStrnds(j+(1:nPos), 2) = rgnPosStrnds(i, 2);
<a name="l02740"></a>02740                 
<a name="l02741"></a>02741                 j = j + nPos;
<a name="l02742"></a>02742             end
<a name="l02743"></a>02743         end
<a name="l02744"></a>02744 
<a name="l02745"></a>02745         function [posStrnds, lens] = splitOverOriC(this, posStrnds, lens)
<a name="l02746"></a>02746             idxs = find(posStrnds(:, 1) + lens - 1 &gt; this.sequenceLen);
<a name="l02747"></a>02747             if isempty(idxs)
<a name="l02748"></a>02748                 return;
<a name="l02749"></a>02749             end
<a name="l02750"></a>02750             posStrnds = [posStrnds; ones(numel(idxs), 1) posStrnds(idxs, 2)];
<a name="l02751"></a>02751             lens = [lens; posStrnds(idxs, 1) + reshape(lens(idxs), [], 1) - this.sequenceLen - 1];
<a name="l02752"></a>02752             lens(idxs) = this.sequenceLen - posStrnds(idxs,1) + 1;
<a name="l02753"></a>02753         end
<a name="l02754"></a>02754 
<a name="l02755"></a>02755         %join regions which have been split over the ORI
<a name="l02756"></a>02756         function [posStrnds, lens] = joinSplitOverOriCRegions(this, posStrnds, lens)
<a name="l02757"></a>02757             pos = posStrnds(:, 1);
<a name="l02758"></a>02758             strnds = posStrnds(:, 2);
<a name="l02759"></a>02759             ends = pos + lens - 1;
<a name="l02760"></a>02760             
<a name="l02761"></a>02761             for i = 1:max(strnds)
<a name="l02762"></a>02762                 idx1 = find(pos == 1 &amp; strnds == i, 1, &#39;first&#39;);
<a name="l02763"></a>02763                 idx2 = find(ends == this.sequenceLen &amp; strnds == i, 1, &#39;first&#39;);
<a name="l02764"></a>02764                 
<a name="l02765"></a>02765                 if isempty(idx1) || isempty(idx2) || idx1 == idx2
<a name="l02766"></a>02766                     continue;
<a name="l02767"></a>02767                 end
<a name="l02768"></a>02768                 
<a name="l02769"></a>02769                 ends(idx2) = ends(idx2) + (ends(idx1) - pos(idx1) + 1);
<a name="l02770"></a>02770                 pos(idx1, :) = [];
<a name="l02771"></a>02771                 strnds(idx1, :) = [];
<a name="l02772"></a>02772                 ends(idx1, :) = [];
<a name="l02773"></a>02773             end
<a name="l02774"></a>02774             
<a name="l02775"></a>02775             posStrnds = [pos strnds];
<a name="l02776"></a>02776             lens = ends - pos + 1;
<a name="l02777"></a>02777         end
<a name="l02778"></a>02778         
<a name="l02779"></a>02779         function [posStrnds, lens] = joinSplitRegions(this, posStrnds, lens)
<a name="l02780"></a>02780             %sort
<a name="l02781"></a>02781             posStrnds(:, 1) = mod(posStrnds(:, 1) - 1, this.sequenceLen) + 1;
<a name="l02782"></a>02782             [posStrnds, order] = edu.stanford.covert.util.SparseMat.sort_subs(posStrnds, [this.sequenceLen this.nCompartments]);
<a name="l02783"></a>02783             lens = lens(order);
<a name="l02784"></a>02784             
<a name="l02785"></a>02785             %join
<a name="l02786"></a>02786             starts = posStrnds(:, 1);
<a name="l02787"></a>02787             ends = starts + lens - 1;
<a name="l02788"></a>02788             strnds = posStrnds(:, 2);
<a name="l02789"></a>02789             
<a name="l02790"></a>02790             tfs = true(size(starts));
<a name="l02791"></a>02791             for i = 1:max(strnds)
<a name="l02792"></a>02792                 idxs = find(strnds == i);
<a name="l02793"></a>02793                 for j = 1:numel(idxs)-1
<a name="l02794"></a>02794                     if ends(idxs(j))+1 &gt;= starts(idxs(j+1))
<a name="l02795"></a>02795                         starts(idxs(j+1)) = starts(idxs(j));
<a name="l02796"></a>02796                         ends(idxs(j+1)) = max(ends(idxs(j)), ends(idxs(j+1)));
<a name="l02797"></a>02797                         tfs(idxs(j)) = false;
<a name="l02798"></a>02798                     end
<a name="l02799"></a>02799                 end
<a name="l02800"></a>02800                 if numel(idxs) &gt;= 2
<a name="l02801"></a>02801                     idx = idxs(find(tfs(idxs), 1, &#39;first&#39;));
<a name="l02802"></a>02802                     if ends(idxs(end))+1 &gt;= starts(idx)+this.sequenceLen
<a name="l02803"></a>02803                         ends(idxs(end)) = this.sequenceLen;
<a name="l02804"></a>02804                         starts(idx) = 1;
<a name="l02805"></a>02805                     end
<a name="l02806"></a>02806                 end
<a name="l02807"></a>02807             end
<a name="l02808"></a>02808             
<a name="l02809"></a>02809             %format output
<a name="l02810"></a>02810             posStrnds = [starts(tfs) strnds(tfs)];
<a name="l02811"></a>02811             lens = ends(tfs) - starts(tfs) + 1;
<a name="l02812"></a>02812         end
<a name="l02813"></a>02813         
<a name="l02814"></a>02814         function [idxs, newIdxs] = excludeOverlappingRegions(this, ...
<a name="l02815"></a>02815                 idxs, newIdxs, positionsStrands, lengths, ...
<a name="l02816"></a>02816                 footprint, footprint3Prime, footprint5Prime, isPositionsStrandFootprintCentroid, ...
<a name="l02817"></a>02817                 eitherStrand)
<a name="l02818"></a>02818             
<a name="l02819"></a>02819             tmpPositionsStrands = positionsStrands([idxs; newIdxs], :);
<a name="l02820"></a>02820             tmpLengths = lengths([idxs; newIdxs], 1);
<a name="l02821"></a>02821             
<a name="l02822"></a>02822             startCoors = tmpPositionsStrands(:, 1) + min(0, tmpLengths + 1);
<a name="l02823"></a>02823             if isPositionsStrandFootprintCentroid
<a name="l02824"></a>02824                 startCoors(mod(tmpPositionsStrands(:, 2), 2) == 1) = ...
<a name="l02825"></a>02825                     startCoors(mod(tmpPositionsStrands(:, 2), 2) == 1) - footprint5Prime;
<a name="l02826"></a>02826                 startCoors(mod(tmpPositionsStrands(:, 2), 2) == 0) = ...
<a name="l02827"></a>02827                     startCoors(mod(tmpPositionsStrands(:, 2), 2) == 0) - footprint3Prime;
<a name="l02828"></a>02828             end
<a name="l02829"></a>02829             endCoors = startCoors + (abs(tmpLengths) - 1) + (footprint - 1);
<a name="l02830"></a>02830             if eitherStrand
<a name="l02831"></a>02831                 strnds = ceil(tmpPositionsStrands(:, 2) / 2);
<a name="l02832"></a>02832             else
<a name="l02833"></a>02833                 strnds = tmpPositionsStrands(:, 2);
<a name="l02834"></a>02834             end
<a name="l02835"></a>02835             tmpIdxs = [zeros(size(idxs)); (1:numel(newIdxs))&#39;];
<a name="l02836"></a>02836             
<a name="l02837"></a>02837             tmp = find(startCoors &lt; 0);
<a name="l02838"></a>02838             startCoors = [startCoors; startCoors(tmp, :) + this.sequenceLen];
<a name="l02839"></a>02839             endCoors   = [endCoors; min(this.sequenceLen, endCoors(tmp, :) + this.sequenceLen)];
<a name="l02840"></a>02840             strnds       = [strnds; strnds(tmp, :)];
<a name="l02841"></a>02841             tmpIdxs    = [tmpIdxs; tmpIdxs(tmp, :)];
<a name="l02842"></a>02842             
<a name="l02843"></a>02843             tmp = find(endCoors &gt; this.sequenceLen);
<a name="l02844"></a>02844             startCoors = [startCoors; max(1, startCoors(tmp, :) - this.sequenceLen)];
<a name="l02845"></a>02845             endCoors   = [endCoors; endCoors(tmp, :) - this.sequenceLen];
<a name="l02846"></a>02846             strnds       = [strnds; strnds(tmp, :)];
<a name="l02847"></a>02847             tmpIdxs    = [tmpIdxs; tmpIdxs(tmp, :)];
<a name="l02848"></a>02848             
<a name="l02849"></a>02849             tmpTfs = true(size(newIdxs));
<a name="l02850"></a>02850             for i = numel(tmpIdxs):-1:2
<a name="l02851"></a>02851                 if tmpIdxs(i) &lt;= numel(idxs)
<a name="l02852"></a>02852                     continue; 
<a name="l02853"></a>02853                 end
<a name="l02854"></a>02854                 tmpTfs(tmpIdxs(i)) = tmpTfs(tmpIdxs(i)) &amp;&amp; ~any((...
<a name="l02855"></a>02855                     startCoors(1:i-1) &lt;= startCoors(i) &amp; startCoors(i) &lt;= endCoors(1:i-1) | ...
<a name="l02856"></a>02856                     startCoors(1:i-1) &lt;= endCoors(i)   &amp; endCoors(  i) &lt;= endCoors(1:i-1)) &amp; ...
<a name="l02857"></a>02857                     strnds(i) == strnds(1:i-1));
<a name="l02858"></a>02858             end
<a name="l02859"></a>02859             newIdxs = newIdxs(tmpTfs);
<a name="l02860"></a>02860         end
<a name="l02861"></a>02861     end
<a name="l02862"></a>02862     
<a name="l02863"></a>02863     %setters
<a name="l02864"></a>02864     methods        
<a name="l02865"></a>02865         %integers [positions x strands] indicating the start positions of
<a name="l02866"></a>02866         %polymerized regions of strands and their lengths
<a name="l02867"></a>02867         function set.polymerizedRegions(this, value)
<a name="l02868"></a>02868             if isequal(this.polymerizedRegions, value)
<a name="l02869"></a>02869                 return;
<a name="l02870"></a>02870             end
<a name="l02871"></a>02871             this.polymerizedRegions = value;
<a name="l02872"></a>02872             this.validated = this.validated  + 1;
<a name="l02873"></a>02873             this.validated_polymerizedRegions = this.validated; %<span class="preprocessor">#ok&lt;*MCSUP&gt;</span>
<a name="l02874"></a>02874 <span class="preprocessor"></span>        end
<a name="l02875"></a>02875         
<a name="l02876"></a>02876         %integers [positions x strands] indicating the current linking number of
<a name="l02877"></a>02877         %each <span class="keywordtype">double</span>-stranded region
<a name="l02878"></a>02878         function set.linkingNumbers(this, value)
<a name="l02879"></a>02879             %NOTE: performance likely better here without checking if new value
<a name="l02880"></a>02880             %is different than old
<a name="l02881"></a>02881             this.linkingNumbers = value;
<a name="l02882"></a>02882             this.validated = this.validated  + 1;
<a name="l02883"></a>02883             this.validated_linkingNumbers = this.validated;
<a name="l02884"></a>02884         end
<a name="l02885"></a>02885         
<a name="l02886"></a>02886         %indices [positions x strands] indicating start positions of protein
<a name="l02887"></a>02887         %monomers bound to DNA bases
<a name="l02888"></a>02888         <span class="keyword">function</span> <span class="keyword">set</span>.monomerBoundSites(<span class="keyword">this</span>, value)
<a name="l02889"></a>02889             %NOTE: performance likely better here without checking <span class="keywordflow">if</span> <span class="keyword">new</span> value
<a name="l02890"></a>02890             %is different than old
<a name="l02891"></a>02891             this.monomerBoundSites = value;
<a name="l02892"></a>02892             this.validated = this.validated  + 1;
<a name="l02893"></a>02893             this.validated_proteinBoundSites = this.validated;
<a name="l02894"></a>02894         end
<a name="l02895"></a>02895         
<a name="l02896"></a>02896         %indices [positions x strands] indicating start positions of
<a name="l02897"></a>02897         %macromolecular complexes bound to DNA bases
<a name="l02898"></a>02898         <span class="keyword">function</span> <span class="keyword">set</span>.complexBoundSites(<span class="keyword">this</span>, value)
<a name="l02899"></a>02899             %NOTE: performance likely better here without checking <span class="keywordflow">if</span> <span class="keyword">new</span> value
<a name="l02900"></a>02900             %is different than old
<a name="l02901"></a>02901             this.complexBoundSites = value;
<a name="l02902"></a>02902             this.validated = this.validated  + 1;
<a name="l02903"></a>02903             this.validated_proteinBoundSites = this.validated;
<a name="l02904"></a>02904         end
<a name="l02905"></a>02905         
<a name="l02906"></a>02906         %<span class="keywordtype">boolean</span> [positions x strands] indicating positions of gap sites
<a name="l02907"></a>02907         <span class="keyword">function</span> <span class="keyword">set</span>.gapSites(<span class="keyword">this</span>, value)
<a name="l02908"></a>02908             <span class="keywordflow">if</span> isequal(this.gapSites, value)
<a name="l02909"></a>02909                 return;
<a name="l02910"></a>02910             end
<a name="l02911"></a>02911             this.gapSites = value;
<a name="l02912"></a>02912             this.validated = this.validated  + 1;
<a name="l02913"></a>02913             this.validated_damaged = this.validated;
<a name="l02914"></a>02914             this.validated_gapSites = this.validated;
<a name="l02915"></a>02915         end
<a name="l02916"></a>02916         
<a name="l02917"></a>02917         %<span class="keywordtype">boolean</span> [positions x strands] indicating positions of abasic sites
<a name="l02918"></a>02918         function set.abasicSites(this, value)
<a name="l02919"></a>02919             if isequal(this.abasicSites, value)
<a name="l02920"></a>02920                 return;
<a name="l02921"></a>02921             end
<a name="l02922"></a>02922             this.abasicSites = value;
<a name="l02923"></a>02923             this.validated = this.validated  + 1;
<a name="l02924"></a>02924             this.validated_damaged = this.validated;
<a name="l02925"></a>02925             this.validated_abasicSites = this.validated;
<a name="l02926"></a>02926         end
<a name="l02927"></a>02927         
<a name="l02928"></a>02928         %indices [positions x strands] indicating metabolite identity of damaged
<a name="l02929"></a>02929         %sugar-phosphates
<a name="l02930"></a>02930         function set.damagedSugarPhosphates(this, value)
<a name="l02931"></a>02931             if isequal(this.damagedSugarPhosphates, value)
<a name="l02932"></a>02932                 return;
<a name="l02933"></a>02933             end
<a name="l02934"></a>02934             this.damagedSugarPhosphates = value;
<a name="l02935"></a>02935             this.validated = this.validated  + 1;
<a name="l02936"></a>02936             this.validated_damaged = this.validated;
<a name="l02937"></a>02937             this.validated_damagedSugarPhosphates = this.validated;
<a name="l02938"></a>02938         end
<a name="l02939"></a>02939         
<a name="l02940"></a>02940         %indices [positions x strands] indicating metabolite identity of damaged
<a name="l02941"></a>02941         %bases
<a name="l02942"></a>02942         function set.damagedBases(this, value)
<a name="l02943"></a>02943             if isequal(this.damagedBases, value)
<a name="l02944"></a>02944                 return;
<a name="l02945"></a>02945             end
<a name="l02946"></a>02946             this.damagedBases = value;
<a name="l02947"></a>02947             this.validated = this.validated  + 1;
<a name="l02948"></a>02948             this.validated_damaged = this.validated;
<a name="l02949"></a>02949             this.validated_damagedBases = this.validated;
<a name="l02950"></a>02950         end
<a name="l02951"></a>02951         
<a name="l02952"></a>02952         %<span class="keywordtype">boolean</span> [positions x strands] indicating metabolite identity of
<a name="l02953"></a>02953         %intrastrand cross links in DNA
<a name="l02954"></a>02954         function set.intrastrandCrossLinks(this, value)
<a name="l02955"></a>02955             if isequal(this.intrastrandCrossLinks, value)
<a name="l02956"></a>02956                 return;
<a name="l02957"></a>02957             end
<a name="l02958"></a>02958             this.intrastrandCrossLinks = value;
<a name="l02959"></a>02959             this.validated = this.validated  + 1;
<a name="l02960"></a>02960             this.validated_damaged = this.validated;
<a name="l02961"></a>02961             this.validated_intrastrandCrossLinks = this.validated;
<a name="l02962"></a>02962         end
<a name="l02963"></a>02963         
<a name="l02964"></a>02964         %<span class="keywordtype">boolean</span> [positions x strands] indicating positions of strand breaks in
<a name="l02965"></a>02965         %strands of DNA
<a name="l02966"></a>02966         function set.strandBreaks(this, value)
<a name="l02967"></a>02967             if isequal(this.strandBreaks, value)
<a name="l02968"></a>02968                 return;
<a name="l02969"></a>02969             end
<a name="l02970"></a>02970             this.strandBreaks = value;
<a name="l02971"></a>02971             this.validated = this.validated  + 1;
<a name="l02972"></a>02972             this.validated_damaged = this.validated;
<a name="l02973"></a>02973             this.validated_strandBreaks = this.validated;
<a name="l02974"></a>02974         end
<a name="l02975"></a>02975         
<a name="l02976"></a>02976         %<span class="keywordtype">boolean</span> [positions x strands] indicating positions of holliday
<a name="l02977"></a>02977         %junctions
<a name="l02978"></a>02978         function set.hollidayJunctions(this, value)
<a name="l02979"></a>02979             if isequal(this.hollidayJunctions, value)
<a name="l02980"></a>02980                 return;
<a name="l02981"></a>02981             end
<a name="l02982"></a>02982             this.hollidayJunctions = value;
<a name="l02983"></a>02983             this.validated = this.validated  + 1;
<a name="l02984"></a>02984             this.validated_damaged = this.validated;
<a name="l02985"></a>02985             this.validated_hollidayJunctions = this.validated;
<a name="l02986"></a>02986         end
<a name="l02987"></a>02987         
<a name="l02988"></a>02988         %<span class="keywordtype">boolean</span> indicating whether or not the chromsomes are segregated
<a name="l02989"></a>02989         function set.segregated(this, value)
<a name="l02990"></a>02990             if isequal(this.segregated, value)
<a name="l02991"></a>02991                 return;
<a name="l02992"></a>02992             end
<a name="l02993"></a>02993             this.segregated = value;
<a name="l02994"></a>02994             this.validated = this.validated  + 1;
<a name="l02995"></a>02995             this.validated_segregated = this.validated;
<a name="l02996"></a>02996         end
<a name="l02997"></a>02997     end
<a name="l02998"></a>02998     
<a name="l02999"></a>02999     %getters for alternative views of state
<a name="l03000"></a>03000     methods
<a name="l03001"></a>03001         function invalidate(this)
<a name="l03002"></a>03002             this.validated = uint32(1);
<a name="l03003"></a>03003             
<a name="l03004"></a>03004             this.validated_polymerizedRegions     = this.validated;
<a name="l03005"></a>03005             this.validated_linkingNumbers         = this.validated;
<a name="l03006"></a>03006             this.validated_proteinBoundSites      = this.validated;
<a name="l03007"></a>03007             this.validated_damaged                = this.validated;
<a name="l03008"></a>03008             this.validated_abasicSites            = this.validated;
<a name="l03009"></a>03009             this.validated_gapSites               = this.validated;
<a name="l03010"></a>03010             this.validated_damagedSugarPhosphates = this.validated;
<a name="l03011"></a>03011             this.validated_damagedBases           = this.validated;
<a name="l03012"></a>03012             this.validated_strandBreaks           = this.validated;
<a name="l03013"></a>03013             this.validated_intrastrandCrossLinks  = this.validated;
<a name="l03014"></a>03014             this.validated_hollidayJunctions      = this.validated;
<a name="l03015"></a>03015             this.validated_segregated             = this.validated;
<a name="l03016"></a>03016             
<a name="l03017"></a>03017             this.validated_unpolymerizedRegions          = uint32(0);
<a name="l03018"></a>03018             this.validated_singleStrandedRegions         = uint32(0);
<a name="l03019"></a>03019             this.validated_doubleStrandedRegions         = uint32(0);
<a name="l03020"></a>03020             this.validated_geneCopyNumbers               = uint32(0);
<a name="l03021"></a>03021             this.validated_ploidy                        = uint32(0);
<a name="l03022"></a>03022             this.validated_polymerizedGenes              = uint32(0);
<a name="l03023"></a>03023             this.validated_transcriptionUnitCopyNumbers  = uint32(0);
<a name="l03024"></a>03024             this.validated_polymerizedTranscriptionUnits = uint32(0);
<a name="l03025"></a>03025             this.validated_geneCopyNumbers_Accessible    = uint32(0);
<a name="l03026"></a>03026             this.validated_transcriptionUnitCopyNumbers_Accessible = uint32(0);
<a name="l03027"></a>03027             this.validated_accessibleGenes               = uint32(0);
<a name="l03028"></a>03028             this.validated_accessibleTranscriptionUnits  = uint32(0);            
<a name="l03029"></a>03029             this.validated_linkingNumbers_minFreeEnergy  = uint32(0);
<a name="l03030"></a>03030             this.validated_supercoils                    = uint32(0);
<a name="l03031"></a>03031             this.validated_superhelicalDensity           = uint32(0);
<a name="l03032"></a>03032             this.validated_supercoiled                   = uint32(0);
<a name="l03033"></a>03033             this.validated_damagedSites                  = uint32(0);
<a name="l03034"></a>03034             this.validated_damagedSites_shifted_incm6AD  = uint32(0);
<a name="l03035"></a>03035             this.validated_damagedSites_nonRedundant     = uint32(0);
<a name="l03036"></a>03036             this.validated_damagedSites_excm6AD          = uint32(0);
<a name="l03037"></a>03037             this.validated_gapSites3                     = uint32(0);
<a name="l03038"></a>03038             this.validated_gapSites5                     = uint32(0);
<a name="l03039"></a>03039             this.validated_abasicSites3                  = uint32(0);
<a name="l03040"></a>03040             this.validated_abasicSites5                  = uint32(0);
<a name="l03041"></a>03041             this.validated_damagedSugarPhosphates3       = uint32(0);
<a name="l03042"></a>03042             this.validated_damagedSugarPhosphates5       = uint32(0);
<a name="l03043"></a>03043             this.validated_damagedBases3                 = uint32(0);
<a name="l03044"></a>03044             this.validated_damagedBases5                 = uint32(0);
<a name="l03045"></a>03045             this.validated_strandBreaks3                 = uint32(0);
<a name="l03046"></a>03046             this.validated_strandBreaks5                 = uint32(0);
<a name="l03047"></a>03047             this.validated_intrastrandCrossLinks3        = uint32(0);
<a name="l03048"></a>03048             this.validated_intrastrandCrossLinks5        = uint32(0);
<a name="l03049"></a>03049             this.validated_hollidayJunctions3            = uint32(0);
<a name="l03050"></a>03050             this.validated_hollidayJunctions5            = uint32(0);
<a name="l03051"></a>03051             this.validated_singleStrandBreaks            = uint32(0);
<a name="l03052"></a>03052             this.validated_doubleStrandBreaks            = uint32(0);
<a name="l03053"></a>03053             this.validated_strandBreakClassification     = uint32(0);
<a name="l03054"></a>03054             this.validated_munIRMSiteMethylationStatus   = uint32(0);
<a name="l03055"></a>03055             this.validated_munIRMSiteRestrictionStatus   = uint32(0);
<a name="l03056"></a>03056             this.validated_dryWeight                     = uint32(0);
<a name="l03057"></a>03057         end
<a name="l03058"></a>03058         
<a name="l03059"></a>03059         %integers indicating the start positions of unpolymerized regions (ie.
<a name="l03060"></a>03060         %not yet replicated) of strands and their lengths
<a name="l03061"></a>03061         function value = get.unpolymerizedRegions(this)
<a name="l03062"></a>03062             if this.validated_polymerizedRegions &gt; this.validated_unpolymerizedRegions
<a name="l03063"></a>03063                 this.unpolymerizedRegions = this.calcUnpolymerizedRegions();
<a name="l03064"></a>03064                 this.validated_unpolymerizedRegions = this.validated;
<a name="l03065"></a>03065             end
<a name="l03066"></a>03066                 
<a name="l03067"></a>03067             value = this.unpolymerizedRegions;
<a name="l03068"></a>03068         end
<a name="l03069"></a>03069                 
<a name="l03070"></a>03070         function value = calcUnpolymerizedRegions(this)
<a name="l03071"></a>03071             import edu.stanford.covert.util.CircularSparseMat;
<a name="l03072"></a>03072             
<a name="l03073"></a>03073             [polPosStrndsTimes, polLens] = find(this.polymerizedRegions);
<a name="l03074"></a>03074             polPos = polPosStrndsTimes(:, 1);
<a name="l03075"></a>03075             polStrnd = polPosStrndsTimes(:, 2);
<a name="l03076"></a>03076             polTimes = polPosStrndsTimes(:, 3:end);
<a name="l03077"></a>03077             if isempty(polTimes)
<a name="l03078"></a>03078                 polTimes = ones(size(polPos));
<a name="l03079"></a>03079             end
<a name="l03080"></a>03080             
<a name="l03081"></a>03081             unpolPos = [];
<a name="l03082"></a>03082             unpolStrnds = [];
<a name="l03083"></a>03083             unpolTimes = [];
<a name="l03084"></a>03084             unpolLens = [];
<a name="l03085"></a>03085             
<a name="l03086"></a>03086             for i = 1:this.nCompartments
<a name="l03087"></a>03087                 idxs = find(polStrnd == i);
<a name="l03088"></a>03088                 
<a name="l03089"></a>03089                 for j = 1:size(this.polymerizedRegions, 3)
<a name="l03090"></a>03090                     idxs2 = idxs(polTimes(idxs) == j);
<a name="l03091"></a>03091                     if isempty(idxs2)
<a name="l03092"></a>03092                         unpolPos = [unpolPos; 1];
<a name="l03093"></a>03093                         unpolLens = [unpolLens; this.sequenceLen];
<a name="l03094"></a>03094                         unpolStrnds = [unpolStrnds; i];
<a name="l03095"></a>03095                         unpolTimes = [unpolTimes; j];
<a name="l03096"></a>03096                         continue;
<a name="l03097"></a>03097                     end
<a name="l03098"></a>03098                     
<a name="l03099"></a>03099                     unpolPos = [
<a name="l03100"></a>03100                         unpolPos;
<a name="l03101"></a>03101                         1;
<a name="l03102"></a>03102                         polPos(idxs2) + polLens(idxs2)]; %<span class="preprocessor">#ok&lt;*AGROW&gt;</span>
<a name="l03103"></a>03103 <span class="preprocessor"></span>                    unpolLens = [
<a name="l03104"></a>03104                         unpolLens;
<a name="l03105"></a>03105                         polPos(idxs2(1))-1;
<a name="l03106"></a>03106                         polPos(idxs2(2:end)) - (polPos(idxs2(1:end-1)) + polLens(idxs2(1:end-1)));
<a name="l03107"></a>03107                         this.sequenceLen - (polPos(idxs2(end)) + polLens(idxs2(end))) + 1;
<a name="l03108"></a>03108                         ]; %#ok&lt;*AGROW&gt;
<a name="l03109"></a>03109                     unpolStrnds = [
<a name="l03110"></a>03110                         unpolStrnds;
<a name="l03111"></a>03111                         i(ones(numel(idxs2) + 1, 1), 1)]; %#ok&lt;*AGROW&gt;
<a name="l03112"></a>03112                     unpolTimes = [
<a name="l03113"></a>03113                         unpolTimes;
<a name="l03114"></a>03114                         j(ones(numel(idxs2)+1, 1), 1)]; %#ok&lt;*AGROW&gt;
<a name="l03115"></a>03115                 end
<a name="l03116"></a>03116             end
<a name="l03117"></a>03117             
<a name="l03118"></a>03118             idxs = find(unpolLens &gt; 0);            
<a name="l03119"></a>03119             value = CircularSparseMat([unpolPos(idxs) unpolStrnds(idxs) unpolTimes(idxs)], unpolLens(idxs), size(this.polymerizedRegions), 1);            
<a name="l03120"></a>03120         end
<a name="l03121"></a>03121                 
<a name="l03122"></a>03122         <span class="keyword">function</span> value = <span class="keyword">get</span>.singleStrandedRegions(<span class="keyword">this</span>)
<a name="l03123"></a>03123             <span class="keywordflow">if</span> this.validated_polymerizedRegions &gt; this.validated_singleStrandedRegions
<a name="l03124"></a>03124                 this.singleStrandedRegions = this.calcSingleStrandedRegions();
<a name="l03125"></a>03125                 this.validated_singleStrandedRegions = this.validated;
<a name="l03126"></a>03126             end
<a name="l03127"></a>03127                 
<a name="l03128"></a>03128             value = this.singleStrandedRegions;
<a name="l03129"></a>03129         end
<a name="l03130"></a>03130         
<a name="l03131"></a>03131         <span class="keyword">function</span> value = calcSingleStrandedRegions(<span class="keyword">this</span>)
<a name="l03132"></a>03132             import edu.stanford.covert.util.CircularSparseMat;
<a name="l03133"></a>03133             
<a name="l03134"></a>03134             [positionsStrandsTimes, lengths] = find(this.polymerizedRegions);
<a name="l03135"></a>03135             strnd = positionsStrandsTimes(:, 2);
<a name="l03136"></a>03136             oppStrnd = strnd;
<a name="l03137"></a>03137             oppStrnd(mod(strnd, 2) == 0, 1) = strnd(mod(strnd, 2) == 0, 1) - 1;
<a name="l03138"></a>03138             oppStrnd(mod(strnd, 2) == 1, 1) = strnd(mod(strnd, 2) == 1, 1) + 1;
<a name="l03139"></a>03139             
<a name="l03140"></a>03140             starts = mod([
<a name="l03141"></a>03141                 positionsStrandsTimes(:,1);
<a name="l03142"></a>03142                 positionsStrandsTimes(:,1) + lengths] ...
<a name="l03143"></a>03143                 - 1, this.sequenceLen) + 1;
<a name="l03144"></a>03144             strandsTimes = [
<a name="l03145"></a>03145                 strnd positionsStrandsTimes(:, 3:end);
<a name="l03146"></a>03146                 oppStrnd positionsStrandsTimes(:, 3:end)];
<a name="l03147"></a>03147             oppStrandsTimes = [
<a name="l03148"></a>03148                 oppStrnd positionsStrandsTimes(:, 3:end);
<a name="l03149"></a>03149                 strnd positionsStrandsTimes(:, 3:end)];
<a name="l03150"></a>03150             lengths = [
<a name="l03151"></a>03151                 lengths;
<a name="l03152"></a>03152                 repmat(max(lengths), size(lengths))];
<a name="l03153"></a>03153             
<a name="l03154"></a>03154             [~, ~, ~, extents1] = this.isRegionPolymerized([starts strandsTimes], lengths, true);
<a name="l03155"></a>03155             [~, ~, ~, extents2] = this.isRegionNotPolymerized([starts oppStrandsTimes], lengths, true);
<a name="l03156"></a>03156             extents = min(abs(extents1), abs(extents2));
<a name="l03157"></a>03157             idxs = find(extents &gt; 0);
<a name="l03158"></a>03158             
<a name="l03159"></a>03159             if size(strandsTimes, 2) == 1
<a name="l03160"></a>03160                 tmp = edu.stanford.covert.util.SparseMat.unique_subs(...
<a name="l03161"></a>03161                     [starts(idxs, :) strandsTimes(idxs, :) extents(idxs)], ...
<a name="l03162"></a>03162                     [this.sequenceLen this.nCompartments this.sequenceLen]);
<a name="l03163"></a>03163             else
<a name="l03164"></a>03164                 tmp = edu.stanford.covert.util.SparseMat.unique_subs(...
<a name="l03165"></a>03165                     [starts(idxs, :) strandsTimes(idxs, :) extents(idxs)], ...
<a name="l03166"></a>03166                     [this.sequenceLen this.nCompartments size(this.polymerizedRegions, 3) this.sequenceLen]);
<a name="l03167"></a>03167             end
<a name="l03168"></a>03168             
<a name="l03169"></a>03169             for i = size(tmp, 1):-1:1
<a name="l03170"></a>03170                 if tmp(i, 1) == 1
<a name="l03171"></a>03171                     idx = find(tmp(:, 1) + tmp(:, 3) - 1 &gt; this.sequenceLen &amp; tmp(:, 2) == tmp(i, 2));                    
<a name="l03172"></a>03172                     if ~isempty(idx)
<a name="l03173"></a>03173                         tmp(idx, 3) = max(tmp(idx, 3), (this.sequenceLen - tmp(idx,1) + 1) + tmp(i, 3));
<a name="l03174"></a>03174                         tmp(i, :) = [];
<a name="l03175"></a>03175                     end
<a name="l03176"></a>03176                 end
<a name="l03177"></a>03177             end
<a name="l03178"></a>03178             
<a name="l03179"></a>03179             posStrnds = tmp(:, 1:end-1);
<a name="l03180"></a>03180             lens = tmp(:, end);
<a name="l03181"></a>03181             [posStrnds, lens] = this.splitOverOriC(posStrnds, lens);
<a name="l03182"></a>03182             value = this.mergeAdjacentRegions(CircularSparseMat(posStrnds, lens, size(this.polymerizedRegions), 1));
<a name="l03183"></a>03183         end
<a name="l03184"></a>03184                 
<a name="l03185"></a>03185         function value = get.doubleStrandedRegions(this)
<a name="l03186"></a>03186             if this.validated_polymerizedRegions &gt; this.validated_doubleStrandedRegions
<a name="l03187"></a>03187                 this.doubleStrandedRegions = this.calcDoubleStrandedRegions();
<a name="l03188"></a>03188                 this.validated_doubleStrandedRegions = this.validated;
<a name="l03189"></a>03189             end
<a name="l03190"></a>03190                 
<a name="l03191"></a>03191             value = this.doubleStrandedRegions;
<a name="l03192"></a>03192         end
<a name="l03193"></a>03193         
<a name="l03194"></a>03194         function value = calcDoubleStrandedRegions(this)
<a name="l03195"></a>03195             import edu.stanford.covert.util.CircularSparseMat;
<a name="l03196"></a>03196             
<a name="l03197"></a>03197             [positionsStrandsTimes, lengths] = find(this.polymerizedRegions);
<a name="l03198"></a>03198             
<a name="l03199"></a>03199                         
<a name="l03200"></a>03200             if size(positionsStrandsTimes, 2) == 2
<a name="l03201"></a>03201                 tmp = edu.stanford.covert.util.SparseMat.unique_subs([
<a name="l03202"></a>03202                     positionsStrandsTimes(:, 1) ceil(positionsStrandsTimes(:, 2)/2) lengths;
<a name="l03203"></a>03203                     ], [this.sequenceLen this.nCompartments this.sequenceLen]);
<a name="l03204"></a>03204                 
<a name="l03205"></a>03205                 [~, ~, ~, extents1] = this.isRegionPolymerized([tmp(:, 1) 2*tmp(:,2)-1], tmp(:, end), true);
<a name="l03206"></a>03206                 [~, ~, ~, extents2] = this.isRegionPolymerized([tmp(:, 1) 2*tmp(:,2)  ], tmp(:, end), true);
<a name="l03207"></a>03207                 extents = min(abs(extents1), abs(extents2));
<a name="l03208"></a>03208                 idxs = find(extents &gt; 0);
<a name="l03209"></a>03209                 
<a name="l03210"></a>03210                 tmp = edu.stanford.covert.util.SparseMat.unique_subs([
<a name="l03211"></a>03211                     tmp(idxs, 1) 2*tmp(idxs, 2)-1 extents(idxs)
<a name="l03212"></a>03212                     tmp(idxs, 1) 2*tmp(idxs, 2)   extents(idxs)
<a name="l03213"></a>03213                     ], [this.sequenceLen this.nCompartments this.sequenceLen]);
<a name="l03214"></a>03214             else
<a name="l03215"></a>03215                 tmp = edu.stanford.covert.util.SparseMat.unique_subs([
<a name="l03216"></a>03216                     positionsStrandsTimes(:, 1) ceil(positionsStrandsTimes(:, 2)/2) positionsStrandsTimes(:, 3:end) lengths;
<a name="l03217"></a>03217                     ], [this.sequenceLen this.nCompartments size(this.polymerizedRegions, 3) this.sequenceLen]);
<a name="l03218"></a>03218                 
<a name="l03219"></a>03219                 [~, ~, ~, extents1] = this.isRegionPolymerized([tmp(:, 1) 2*tmp(:,2)-1 tmp(:,3:end-1)], tmp(:, end), true);
<a name="l03220"></a>03220                 [~, ~, ~, extents2] = this.isRegionPolymerized([tmp(:, 1) 2*tmp(:,2)   tmp(:,3:end-1)], tmp(:, end), true);
<a name="l03221"></a>03221                 extents = min(abs(extents1), abs(extents2));
<a name="l03222"></a>03222                 idxs = find(extents &gt; 0);
<a name="l03223"></a>03223                 
<a name="l03224"></a>03224                 tmp = edu.stanford.covert.util.SparseMat.unique_subs([
<a name="l03225"></a>03225                     tmp(idxs, 1) 2*tmp(idxs, 2)-1 tmp(idxs, 3:end-1) extents(idxs)
<a name="l03226"></a>03226                     tmp(idxs, 1) 2*tmp(idxs, 2)   tmp(idxs, 3:end-1) extents(idxs)
<a name="l03227"></a>03227                     ], [this.sequenceLen this.nCompartments size(this.polymerizedRegions, 3) this.sequenceLen]);
<a name="l03228"></a>03228             end
<a name="l03229"></a>03229             
<a name="l03230"></a>03230             for i = size(tmp, 1):-1:1
<a name="l03231"></a>03231                 if tmp(i, 1) == 1
<a name="l03232"></a>03232                     idx = find(tmp(:, 1) + tmp(:, 3) - 1 &gt; this.sequenceLen &amp; tmp(:, 2) == tmp(i, 2));
<a name="l03233"></a>03233                     if ~isempty(idx)
<a name="l03234"></a>03234                         tmp(idx, 3) = max(tmp(idx, 3), (this.sequenceLen - tmp(idx,1) + 1) + tmp(i, 3));
<a name="l03235"></a>03235                         tmp(i, :) = [];
<a name="l03236"></a>03236                     end
<a name="l03237"></a>03237                 end
<a name="l03238"></a>03238             end
<a name="l03239"></a>03239             
<a name="l03240"></a>03240             posStrnds = tmp(:, 1:end-1);
<a name="l03241"></a>03241             lens = tmp(:, end);
<a name="l03242"></a>03242             [posStrnds, lens] = this.splitOverOriC(posStrnds, lens);
<a name="l03243"></a>03243             value = this.mergeAdjacentRegions(CircularSparseMat(posStrnds, lens, size(this.polymerizedRegions), 1));
<a name="l03244"></a>03244         end
<a name="l03245"></a>03245         
<a name="l03246"></a>03246         
<a name="l03247"></a>03247         function value = get.geneCopyNumbers(this)
<a name="l03248"></a>03248             if this.validated_polymerizedRegions &gt; this.validated_geneCopyNumbers
<a name="l03249"></a>03249                 this.geneCopyNumbers = this.calcGeneCopyNumbers();
<a name="l03250"></a>03250                 this.validated_geneCopyNumbers = this.validated;
<a name="l03251"></a>03251             end
<a name="l03252"></a>03252                 
<a name="l03253"></a>03253             value = this.geneCopyNumbers;
<a name="l03254"></a>03254         end
<a name="l03255"></a>03255         
<a name="l03256"></a>03256         %number of copies of each gene that have been polymerized (Nx1)
<a name="l03257"></a>03257         function value = calcGeneCopyNumbers(this)
<a name="l03258"></a>03258             value = sum(this.polymerizedGenes, 2);
<a name="l03259"></a>03259         end
<a name="l03260"></a>03260         
<a name="l03261"></a>03261         function value = get.ploidy(this)
<a name="l03262"></a>03262             if this.validated_polymerizedRegions &gt; this.validated_ploidy
<a name="l03263"></a>03263                 this.ploidy = this.calcPloidy();
<a name="l03264"></a>03264                 this.validated_ploidy = this.validated;
<a name="l03265"></a>03265             end
<a name="l03266"></a>03266             
<a name="l03267"></a>03267             value = this.ploidy;
<a name="l03268"></a>03268         end
<a name="l03269"></a>03269         
<a name="l03270"></a>03270         function value = calcPloidy(this)
<a name="l03271"></a>03271             value = collapse(this.polymerizedRegions)/(2*this.sequenceLen);
<a name="l03272"></a>03272         end
<a name="l03273"></a>03273         
<a name="l03274"></a>03274         function value = get.polymerizedGenes(this)
<a name="l03275"></a>03275             if this.validated_polymerizedRegions &gt; this.validated_polymerizedGenes
<a name="l03276"></a>03276                 this.polymerizedGenes = this.calcPolymerizedGenes();
<a name="l03277"></a>03277                 this.validated_polymerizedGenes = this.validated;
<a name="l03278"></a>03278             end
<a name="l03279"></a>03279                 
<a name="l03280"></a>03280             value = this.polymerizedGenes;
<a name="l03281"></a>03281         end
<a name="l03282"></a>03282 
<a name="l03283"></a>03283         %whether each copy of each gene has been polymerized (Nx2)
<a name="l03284"></a>03284         function value = calcPolymerizedGenes(this)
<a name="l03285"></a>03285             value = this.isRegionPolymerized(...
<a name="l03286"></a>03286                 [this.gene.startCoordinates this.gene.strands;
<a name="l03287"></a>03287                  this.gene.startCoordinates this.gene.strands+2],...
<a name="l03288"></a>03288                 [this.gene.lengths; this.gene.lengths], false);
<a name="l03289"></a>03289             value = reshape(value, [], 2);
<a name="l03290"></a>03290         end
<a name="l03291"></a>03291         
<a name="l03292"></a>03292         
<a name="l03293"></a>03293         function value = get.transcriptionUnitCopyNumbers(this)
<a name="l03294"></a>03294             if this.validated_polymerizedRegions &gt; this.validated_transcriptionUnitCopyNumbers
<a name="l03295"></a>03295                 this.transcriptionUnitCopyNumbers = this.getTranscriptionUnitCopyNumbers();
<a name="l03296"></a>03296                 this.validated_transcriptionUnitCopyNumbers = this.validated;
<a name="l03297"></a>03297             end
<a name="l03298"></a>03298                 
<a name="l03299"></a>03299             value = this.transcriptionUnitCopyNumbers;
<a name="l03300"></a>03300         end
<a name="l03301"></a>03301 
<a name="l03302"></a>03302         %number of copies of each transcription <a class="code" href="unit_8m.html#a94c091bed34da4edc337e42e23029000">unit</a> that have been polymerized (Nx1)
<a name="l03303"></a>03303         function value = getTranscriptionUnitCopyNumbers(this)
<a name="l03304"></a>03304             value = sum(this.polymerizedTranscriptionUnits, 2);
<a name="l03305"></a>03305         end
<a name="l03306"></a>03306 
<a name="l03307"></a>03307         
<a name="l03308"></a>03308         function value = get.polymerizedTranscriptionUnits(this)
<a name="l03309"></a>03309             if this.validated_polymerizedRegions &gt; this.validated_polymerizedTranscriptionUnits
<a name="l03310"></a>03310                 this.polymerizedTranscriptionUnits = this.calcPolymerizedTranscriptionUnits();
<a name="l03311"></a>03311                 this.validated_polymerizedTranscriptionUnits = this.validated;
<a name="l03312"></a>03312             end
<a name="l03313"></a>03313                 
<a name="l03314"></a>03314             value = this.polymerizedTranscriptionUnits;
<a name="l03315"></a>03315         end
<a name="l03316"></a>03316         
<a name="l03317"></a>03317         %whether each copy of each transcription <a class="code" href="unit_8m.html#a94c091bed34da4edc337e42e23029000">unit</a> has been polymerized (Nx2)
<a name="l03318"></a>03318         function value = calcPolymerizedTranscriptionUnits(this)
<a name="l03319"></a>03319             value = this.isRegionPolymerized(...
<a name="l03320"></a>03320                 [this.transcriptionUnitStartCoordinates this.transcriptionUnitStrands;
<a name="l03321"></a>03321                  this.transcriptionUnitStartCoordinates this.transcriptionUnitStrands+2],...
<a name="l03322"></a>03322                 [this.transcriptionUnitLengths; this.transcriptionUnitLengths], false);
<a name="l03323"></a>03323             value = reshape(value, [], 2);
<a name="l03324"></a>03324         end
<a name="l03325"></a>03325         
<a name="l03326"></a>03326         
<a name="l03327"></a>03327         function value = get.geneCopyNumbers_Accessible(this)
<a name="l03328"></a>03328             val = max([
<a name="l03329"></a>03329                 this.validated_polymerizedRegions; 
<a name="l03330"></a>03330                 this.validated_damaged;
<a name="l03331"></a>03331                 this.validated_proteinBoundSites]);
<a name="l03332"></a>03332             if val &gt; this.validated_geneCopyNumbers_Accessible
<a name="l03333"></a>03333                 this.geneCopyNumbers_Accessible = this.calcCopyNumbers_Accessible();
<a name="l03334"></a>03334                 this.validated_geneCopyNumbers_Accessible = this.validated;
<a name="l03335"></a>03335             end
<a name="l03336"></a>03336                 
<a name="l03337"></a>03337             value = this.geneCopyNumbers_Accessible;
<a name="l03338"></a>03338         end
<a name="l03339"></a>03339 
<a name="l03340"></a>03340         %number of copies of each gene that are accessible
<a name="l03341"></a>03341         function value = calcCopyNumbers_Accessible(this)
<a name="l03342"></a>03342             value = sum(this.accessibleGenes, 2);
<a name="l03343"></a>03343         end
<a name="l03344"></a>03344         
<a name="l03345"></a>03345         
<a name="l03346"></a>03346         function value = get.transcriptionUnitCopyNumbers_Accessible(this)
<a name="l03347"></a>03347             val = max([
<a name="l03348"></a>03348                 this.validated_polymerizedRegions; 
<a name="l03349"></a>03349                 this.validated_damaged;
<a name="l03350"></a>03350                 this.validated_proteinBoundSites]);
<a name="l03351"></a>03351             if val &gt; this.validated_transcriptionUnitCopyNumbers_Accessible
<a name="l03352"></a>03352                 this.transcriptionUnitCopyNumbers_Accessible = this.calcTranscriptionUnitCopyNumbers_Accessible();
<a name="l03353"></a>03353                 this.validated_transcriptionUnitCopyNumbers_Accessible = this.validated;
<a name="l03354"></a>03354             end
<a name="l03355"></a>03355                 
<a name="l03356"></a>03356             value = this.transcriptionUnitCopyNumbers_Accessible;
<a name="l03357"></a>03357         end
<a name="l03358"></a>03358                 
<a name="l03359"></a>03359         %number of copies of each transcription <a class="code" href="unit_8m.html#a94c091bed34da4edc337e42e23029000">unit</a> that are accessible
<a name="l03360"></a>03360         function value = calcTranscriptionUnitCopyNumbers_Accessible(this)
<a name="l03361"></a>03361             value = sum(this.accessibleTranscriptionUnits, 2);
<a name="l03362"></a>03362         end
<a name="l03363"></a>03363         
<a name="l03364"></a>03364         
<a name="l03365"></a>03365         function value = get.accessibleGenes(this)
<a name="l03366"></a>03366             val = max([
<a name="l03367"></a>03367                 this.validated_polymerizedRegions; 
<a name="l03368"></a>03368                 this.validated_damaged;
<a name="l03369"></a>03369                 this.validated_proteinBoundSites]);
<a name="l03370"></a>03370             if val &gt; this.validated_accessibleGenes
<a name="l03371"></a>03371                 this.accessibleGenes = this.calcAccessibleGenes();
<a name="l03372"></a>03372                 this.validated_accessibleGenes = this.validated;
<a name="l03373"></a>03373             end
<a name="l03374"></a>03374                 
<a name="l03375"></a>03375             value = this.accessibleGenes;
<a name="l03376"></a>03376         end
<a name="l03377"></a>03377         
<a name="l03378"></a>03378         %<span class="keywordtype">boolean</span> indicator of undamaged, unoccupied genes
<a name="l03379"></a>03379         %true  ==&gt; gene is accessible
<a name="l03380"></a>03380         %false ==&gt; gene is inaccessible
<a name="l03381"></a>03381         function value = calcAccessibleGenes(this)
<a name="l03382"></a>03382             value = reshape(this.isRegionAccessible([...
<a name="l03383"></a>03383                 this.gene.startCoordinates this.gene.strands
<a name="l03384"></a>03384                 this.gene.startCoordinates this.gene.strands+2], ...
<a name="l03385"></a>03385                 [this.gene.lengths; this.gene.lengths], [], [], true, [], false, true), [], this.nCompartments/2);
<a name="l03386"></a>03386         end
<a name="l03387"></a>03387         
<a name="l03388"></a>03388         
<a name="l03389"></a>03389         function value = get.accessibleTranscriptionUnits(this)
<a name="l03390"></a>03390             val = max([
<a name="l03391"></a>03391                 this.validated_polymerizedRegions; 
<a name="l03392"></a>03392                 this.validated_damaged;
<a name="l03393"></a>03393                 this.validated_proteinBoundSites]);
<a name="l03394"></a>03394             if val &gt; this.validated_accessibleTranscriptionUnits
<a name="l03395"></a>03395                 this.accessibleTranscriptionUnits = this.calcAccessibleTranscriptionUnits();
<a name="l03396"></a>03396                 this.validated_accessibleTranscriptionUnits = this.validated;
<a name="l03397"></a>03397             end
<a name="l03398"></a>03398                 
<a name="l03399"></a>03399             value = this.accessibleTranscriptionUnits;
<a name="l03400"></a>03400         end
<a name="l03401"></a>03401         
<a name="l03402"></a>03402         %<span class="keywordtype">boolean</span> indicator of undamaged, unoccupied transcription units
<a name="l03403"></a>03403         %true  ==&gt; transcription <a class="code" href="unit_8m.html#a94c091bed34da4edc337e42e23029000">unit</a> is accessible
<a name="l03404"></a>03404         %false ==&gt; transcription <a class="code" href="unit_8m.html#a94c091bed34da4edc337e42e23029000">unit</a> is inaccessible
<a name="l03405"></a>03405         function value = calcAccessibleTranscriptionUnits(this)
<a name="l03406"></a>03406             value = reshape(this.isRegionAccessible([...
<a name="l03407"></a>03407                 this.transcriptionUnitStartCoordinates this.transcriptionUnitStrands;
<a name="l03408"></a>03408                 this.transcriptionUnitStartCoordinates this.transcriptionUnitStrands+2], ...
<a name="l03409"></a>03409                 [this.transcriptionUnitLengths; this.transcriptionUnitLengths], [], [], true, [], false, true), ...
<a name="l03410"></a>03410                 [], this.nCompartments/2);
<a name="l03411"></a>03411         end
<a name="l03412"></a>03412         
<a name="l03413"></a>03413         function value = get.strandBreakClassification(this)
<a name="l03414"></a>03414             if max(this.validated_polymerizedRegions, this.validated_damaged) &gt; this.validated_strandBreakClassification
<a name="l03415"></a>03415                 this.strandBreakClassification = this.calcStrandBreakClassification();
<a name="l03416"></a>03416                 this.validated_strandBreakClassification = this.validated;
<a name="l03417"></a>03417             end
<a name="l03418"></a>03418                 
<a name="l03419"></a>03419             value = this.strandBreakClassification;
<a name="l03420"></a>03420         end
<a name="l03421"></a>03421         
<a name="l03422"></a>03422         %numbers of each class of strand break (SSB, SSB+, 2SSB, DSB, DSB+,
<a name="l03423"></a>03423         %DSB++) in DNA
<a name="l03424"></a>03424         function value = calcStrandBreakClassification(this)
<a name="l03425"></a>03425             import edu.stanford.covert.util.CircularSparseMat;
<a name="l03426"></a>03426             import edu.stanford.covert.util.countUnique;
<a name="l03427"></a>03427             
<a name="l03428"></a>03428             %parameters
<a name="l03429"></a>03429             segmentLength = this.strandBreakClassification_segmentLength;
<a name="l03430"></a>03430             dsbSep = this.strandBreakClassification_doubleStrandBreakSeparation;
<a name="l03431"></a>03431             genomeLength = this.sequenceLen;
<a name="l03432"></a>03432             numStrands = this.nCompartments;
<a name="l03433"></a>03433             numTime = size(this.strandBreaks, 3);
<a name="l03434"></a>03434             numSegments = ceil(genomeLength / segmentLength);
<a name="l03435"></a>03435             
<a name="l03436"></a>03436             %damaged Sites
<a name="l03437"></a>03437             [polymerizedPositionsStrands, polymerizedLengths] = find(this.polymerizedRegions);
<a name="l03438"></a>03438             idxs = find(polymerizedPositionsStrands(:,1) &lt;= segmentLength * numSegments - genomeLength);
<a name="l03439"></a>03439             polymerizedPositionsStrands = [polymerizedPositionsStrands; polymerizedPositionsStrands(idxs, 1) + this.sequenceLen polymerizedPositionsStrands(idxs, 2:end)];
<a name="l03440"></a>03440             polymerizedLengths = [polymerizedLengths; polymerizedLengths(idxs, :)];
<a name="l03441"></a>03441             idxs = find(polymerizedPositionsStrands(:,1) + polymerizedLengths - 1 &gt; segmentLength * numSegments);
<a name="l03442"></a>03442             polymerizedLengths(idxs,:) = segmentLength * numSegments - polymerizedPositionsStrands(idxs, 1) + 1;
<a name="l03443"></a>03443             [polymerizedPositionsStrands, polymerizedLengths] = find(this.mergeAdjacentRegions(...
<a name="l03444"></a>03444                 CircularSparseMat(polymerizedPositionsStrands, polymerizedLengths, [segmentLength * numSegments numStrands numTime], 1)));
<a name="l03445"></a>03445             
<a name="l03446"></a>03446             if numTime == 1
<a name="l03447"></a>03447                 polymerizedPositionsStrands = [polymerizedPositionsStrands ones(size(polymerizedPositionsStrands,1), 1)];
<a name="l03448"></a>03448             end
<a name="l03449"></a>03449             
<a name="l03450"></a>03450             polymerizedStrands = [];
<a name="l03451"></a>03451             for i = 1:size(polymerizedPositionsStrands, 1)
<a name="l03452"></a>03452                 regions = ceil((polymerizedPositionsStrands(i,1)-1) / segmentLength)+1 : floor((polymerizedPositionsStrands(i,1) + polymerizedLengths(i,1) -1) / segmentLength);
<a name="l03453"></a>03453                 polymerizedStrands = [polymerizedStrands;
<a name="l03454"></a>03454                     regions&#39; ...
<a name="l03455"></a>03455                     repmat(ceil(polymerizedPositionsStrands(i,2)/2), numel(regions), 1) ...
<a name="l03456"></a>03456                     repmat(polymerizedPositionsStrands(i,3), numel(regions), 1)];
<a name="l03457"></a>03457             end
<a name="l03458"></a>03458             [polymerizedRegions, ~, idxs]= unique(polymerizedStrands, &#39;rows&#39;); %<span class="preprocessor">#ok&lt;PROP&gt;</span>
<a name="l03459"></a>03459 <span class="preprocessor"></span>            [idxs, counts] = <a class="code" href="count_unique_8m.html#a410e08d5000569bcf7496572e8ce1729">countUnique</a>(idxs);
<a name="l03460"></a>03460             polymerizeTimes = polymerizedRegions(idxs(counts == 2), 3:end); %#ok&lt;PROP&gt;
<a name="l03461"></a>03461             
<a name="l03462"></a>03462             numPolymerizedSegments = zeros(1, 1, numTime);
<a name="l03463"></a>03463             [idxs, counts] = <a class="code" href="count_unique_8m.html#a410e08d5000569bcf7496572e8ce1729">countUnique</a>(polymerizeTimes);
<a name="l03464"></a>03464             numPolymerizedSegments(idxs) = counts;
<a name="l03465"></a>03465             
<a name="l03466"></a>03466             %initialize classification
<a name="l03467"></a>03467             dmgSites = [this.strandBreaks; this.strandBreaks(1:segmentLength * numSegments - genomeLength, :, :)];
<a name="l03468"></a>03468             
<a name="l03469"></a>03469             subs = find(permute(reshape(dmgSites, [], numSegments, numStrands, numTime), [3 1 2 4])); %[strands X positions X segments X time]
<a name="l03470"></a>03470             <span class="keywordflow">if</span> numTime == 1; subs = [subs ones(size(subs,1), 1)]; end
<a name="l03471"></a>03471             segmentTimeInds = sub2ind([numSegments numTime], subs(:, 3), subs(:, 4));
<a name="l03472"></a>03472             
<a name="l03473"></a>03473             value = zeros(this.strandBreakClassification_index_DSB__, 1, numTime);
<a name="l03474"></a>03474             
<a name="l03475"></a>03475             %classify segments
<a name="l03476"></a>03476             <span class="keywordflow">while</span> ~isempty(subs)
<a name="l03477"></a>03477                 %time
<a name="l03478"></a>03478                 time = subs(1, 4);
<a name="l03479"></a>03479                 
<a name="l03480"></a>03480                 %find extent of segment
<a name="l03481"></a>03481                 endIdx = find(...
<a name="l03482"></a>03482                     segmentTimeInds(1) ~= segmentTimeInds | ...
<a name="l03483"></a>03483                     ceil(subs(1,1)/2) ~= ceil(subs(:,1)/2), ...
<a name="l03484"></a>03484                     1, <span class="stringliteral">&#39;first&#39;</span>) - 1;
<a name="l03485"></a>03485                 <span class="keywordflow">if</span> isempty(endIdx)
<a name="l03486"></a>03486                     endIdx = size(subs, 1);
<a name="l03487"></a>03487                 end
<a name="l03488"></a>03488                 
<a name="l03489"></a>03489                 if ~this.isRegionDoubleStranded([(subs(:,3)-1)*segmentLength+1 subs(:,1) subs(:,4)], segmentLength, false);
<a name="l03490"></a>03490                     continue;
<a name="l03491"></a>03491                 end
<a name="l03492"></a>03492                 
<a name="l03493"></a>03493                 %classify damaged segment
<a name="l03494"></a>03494                 if endIdx == 1
<a name="l03495"></a>03495                     classification = this.strandBreakClassification_index_SSB;
<a name="l03496"></a>03496                 else
<a name="l03497"></a>03497                     strands   = subs(1:endIdx, 1);
<a name="l03498"></a>03498                     positions = subs(1:endIdx, 2);
<a name="l03499"></a>03499                     if ~isempty(strands) &amp;&amp; all(strands == strands(1))
<a name="l03500"></a>03500                         classification = this.strandBreakClassification_index_SSB_;
<a name="l03501"></a>03501                     else
<a name="l03502"></a>03502                         dsbIdx = find(diff(positions) &lt; dsbSep &amp; diff(strands));
<a name="l03503"></a>03503                         if isempty(dsbIdx)
<a name="l03504"></a>03504                             classification = this.strandBreakClassification_index_2SSB;
<a name="l03505"></a>03505                         else
<a name="l03506"></a>03506                             if numel(dsbIdx)&gt;1 &amp;&amp; diff(positions(dsbIdx([1 end]))) &gt;= dsbSep
<a name="l03507"></a>03507                                 classification = this.strandBreakClassification_index_DSB__;
<a name="l03508"></a>03508                             elseif numel(dsbIdx)&gt;1 || ...
<a name="l03509"></a>03509                                     (dsbIdx&gt;1 &amp;&amp; diff(positions([dsbIdx - 1 dsbIdx])) &lt; dsbSep) || ...
<a name="l03510"></a>03510                                     (dsbIdx&lt;numel(positions) - 1 &amp;&amp; diff(positions([dsbIdx + 1 dsbIdx + 2])) &lt; dsbSep)
<a name="l03511"></a>03511                                 classification = this.strandBreakClassification_index_DSB_;
<a name="l03512"></a>03512                             else
<a name="l03513"></a>03513                                 classification = this.strandBreakClassification_index_DSB;
<a name="l03514"></a>03514                             end
<a name="l03515"></a>03515                         end
<a name="l03516"></a>03516                     end
<a name="l03517"></a>03517                 end
<a name="l03518"></a>03518                 
<a name="l03519"></a>03519                 %update counts of classified segments
<a name="l03520"></a>03520                 value(classification, 1, time) = value(classification, 1, time) + 1;
<a name="l03521"></a>03521                 
<a name="l03522"></a>03522                 %shrink subs
<a name="l03523"></a>03523                 subs(1:endIdx, :) = [];
<a name="l03524"></a>03524                 segmentTimeInds(1:endIdx, :) = [];
<a name="l03525"></a>03525             end
<a name="l03526"></a>03526             
<a name="l03527"></a>03527             %compute numbers of segments without damage
<a name="l03528"></a>03528             value(this.strandBreakClassification_index_NB, 1, :) =  numPolymerizedSegments - sum(value,1);
<a name="l03529"></a>03529         end
<a name="l03530"></a>03530         
<a name="l03531"></a>03531         %
<a name="l03532"></a>03532         function value = get.linkingNumbers_minFreeEnergy(this)
<a name="l03533"></a>03533             if this.validated_polymerizedRegions &gt; this.validated_linkingNumbers_minFreeEnergy
<a name="l03534"></a>03534                 this.linkingNumbers_minFreeEnergy = this.calcLinkingNumbers_minFreeEnergy();
<a name="l03535"></a>03535                 this.validated_linkingNumbers_minFreeEnergy = this.validated;
<a name="l03536"></a>03536             end
<a name="l03537"></a>03537             
<a name="l03538"></a>03538             value = this.linkingNumbers_minFreeEnergy;
<a name="l03539"></a>03539         end
<a name="l03540"></a>03540         
<a name="l03541"></a>03541         function value = calcLinkingNumbers_minFreeEnergy(this)
<a name="l03542"></a>03542             import edu.stanford.covert.util.CircularSparseMat;
<a name="l03543"></a>03543             
<a name="l03544"></a>03544             [posStrands, lens] = find(this.doubleStrandedRegions);
<a name="l03545"></a>03545             
<a name="l03546"></a>03546             value = CircularSparseMat(posStrands, lens / this.relaxedBasesPerTurn, size(this.linkingNumbers), 1);
<a name="l03547"></a>03547         end
<a name="l03548"></a>03548         
<a name="l03549"></a>03549         %
<a name="l03550"></a>03550         function value = get.supercoils(this)
<a name="l03551"></a>03551             if any([this.validated_polymerizedRegions; this.validated_linkingNumbers] &gt; this.validated_supercoils)
<a name="l03552"></a>03552                 this.supercoils = this.calcSupercoils();
<a name="l03553"></a>03553                 this.validated_supercoils = this.validated;
<a name="l03554"></a>03554             end
<a name="l03555"></a>03555             
<a name="l03556"></a>03556             value = this.supercoils;
<a name="l03557"></a>03557         end
<a name="l03558"></a>03558         
<a name="l03559"></a>03559         function value = calcSupercoils(this)            
<a name="l03560"></a>03560             value = this.linkingNumbers - this.linkingNumbers_minFreeEnergy;
<a name="l03561"></a>03561         end
<a name="l03562"></a>03562         
<a name="l03563"></a>03563         %
<a name="l03564"></a>03564         function value = get.superhelicalDensity(this)
<a name="l03565"></a>03565             if any([this.validated_polymerizedRegions; this.validated_linkingNumbers] &gt; this.validated_superhelicalDensity)
<a name="l03566"></a>03566                 this.superhelicalDensity = this.calcSuperhelicalDensity();
<a name="l03567"></a>03567                 this.validated_superhelicalDensity = this.validated;
<a name="l03568"></a>03568             end
<a name="l03569"></a>03569             
<a name="l03570"></a>03570             value = this.superhelicalDensity;
<a name="l03571"></a>03571         end
<a name="l03572"></a>03572         
<a name="l03573"></a>03573         function value = calcSuperhelicalDensity(this)           
<a name="l03574"></a>03574             import edu.stanford.covert.util.CircularSparseMat;
<a name="l03575"></a>03575             
<a name="l03576"></a>03576             lkNums_min = this.linkingNumbers_minFreeEnergy;
<a name="l03577"></a>03577             [posStrnds, deltas] = find(this.linkingNumbers - lkNums_min);
<a name="l03578"></a>03578             value = CircularSparseMat(posStrnds, deltas ./ lkNums_min(posStrnds), size(this.linkingNumbers), 1);
<a name="l03579"></a>03579         end
<a name="l03580"></a>03580         
<a name="l03581"></a>03581         %check if superhelical density within tolerance of equilbrium value
<a name="l03582"></a>03582         function value = get.supercoiled(this)
<a name="l03583"></a>03583             if any([this.validated_polymerizedRegions; this.validated_linkingNumbers] &gt; this.validated_supercoiled)
<a name="l03584"></a>03584                 this.supercoiled = this.calcSupercoiled();
<a name="l03585"></a>03585                 this.validated_supercoiled = this.validated;
<a name="l03586"></a>03586             end
<a name="l03587"></a>03587             
<a name="l03588"></a>03588             value = this.supercoiled;
<a name="l03589"></a>03589         end
<a name="l03590"></a>03590         
<a name="l03591"></a>03591         function value = calcSupercoiled(this)
<a name="l03592"></a>03592             import edu.stanford.covert.util.CircularSparseMat;
<a name="l03593"></a>03593             
<a name="l03594"></a>03594             siz = [this.sequenceLen this.nCompartments];
<a name="l03595"></a>03595             
<a name="l03596"></a>03596             [posStrnds, lens] = find(this.doubleStrandedRegions);
<a name="l03597"></a>03597             lks = this.linkingNumbers(posStrnds);
<a name="l03598"></a>03598             
<a name="l03599"></a>03599             lk0s = lens / this.relaxedBasesPerTurn;
<a name="l03600"></a>03600             sigmas = (lks - lk0s) ./ lk0s;
<a name="l03601"></a>03601             tfs = abs(sigmas - this.equilibriumSuperhelicalDensity) &lt; this.supercoiledSuperhelicalDensityTolerance;
<a name="l03602"></a>03602             
<a name="l03603"></a>03603             value = CircularSparseMat(posStrnds, tfs, siz, 1);
<a name="l03604"></a>03604         end
<a name="l03605"></a>03605         
<a name="l03606"></a>03606         function value = get.damagedSites(this)
<a name="l03607"></a>03607             if this.validated_damaged &gt; this.validated_damagedSites
<a name="l03608"></a>03608                 this.damagedSites = this.calcDamagedSites();
<a name="l03609"></a>03609                 this.validated_damagedSites = this.validated;
<a name="l03610"></a>03610             end
<a name="l03611"></a>03611             
<a name="l03612"></a>03612             value = this.damagedSites;
<a name="l03613"></a>03613         end
<a name="l03614"></a>03614         
<a name="l03615"></a>03615         function value = calcDamagedSites(this)
<a name="l03616"></a>03616             value = this.getDamagedSites(true, true, true, true, false, true, false);
<a name="l03617"></a>03617         end
<a name="l03618"></a>03618         
<a name="l03619"></a>03619         function value = get.damagedSites_shifted_incm6AD(this)
<a name="l03620"></a>03620             if this.validated_damaged &gt; this.validated_damagedSites_shifted_incm6AD
<a name="l03621"></a>03621                 this.damagedSites_shifted_incm6AD = this.calcDamagedSites_shifted_incm6AD();
<a name="l03622"></a>03622                 this.validated_damagedSites_shifted_incm6AD = this.validated;
<a name="l03623"></a>03623             end
<a name="l03624"></a>03624             
<a name="l03625"></a>03625             value = this.damagedSites_shifted_incm6AD;
<a name="l03626"></a>03626         end
<a name="l03627"></a>03627         
<a name="l03628"></a>03628         function value = calcDamagedSites_shifted_incm6AD(this)
<a name="l03629"></a>03629             value = this.getDamagedSites(true, true, true, true, false, true, true);
<a name="l03630"></a>03630         end
<a name="l03631"></a>03631         
<a name="l03632"></a>03632         function value = get.damagedSites_nonRedundant(this)
<a name="l03633"></a>03633             if this.validated_damaged &gt; this.validated_damagedSites_nonRedundant
<a name="l03634"></a>03634                 this.damagedSites_nonRedundant = this.calcDamagedSites_nonRedundant();
<a name="l03635"></a>03635                 this.validated_damagedSites_nonRedundant = this.validated;
<a name="l03636"></a>03636             end
<a name="l03637"></a>03637             
<a name="l03638"></a>03638             value = this.damagedSites_nonRedundant;
<a name="l03639"></a>03639         end
<a name="l03640"></a>03640         
<a name="l03641"></a>03641         function value = calcDamagedSites_nonRedundant(this)
<a name="l03642"></a>03642             value = this.getDamagedSites(true, true, false, false, false, false, true);
<a name="l03643"></a>03643         end
<a name="l03644"></a>03644         
<a name="l03645"></a>03645         function value = get.damagedSites_excm6AD(this)
<a name="l03646"></a>03646             if this.validated_damaged &gt; this.validated_damagedSites_excm6AD
<a name="l03647"></a>03647                 this.damagedSites_excm6AD = this.calcDamagedSites_excm6AD();
<a name="l03648"></a>03648                 this.validated_damagedSites_excm6AD = this.validated;
<a name="l03649"></a>03649             end
<a name="l03650"></a>03650             
<a name="l03651"></a>03651             value = this.damagedSites_excm6AD;
<a name="l03652"></a>03652         end
<a name="l03653"></a>03653         
<a name="l03654"></a>03654         function value = calcDamagedSites_excm6AD(this)
<a name="l03655"></a>03655             value = this.getDamagedSites(true, true, false, false, false, false, false);
<a name="l03656"></a>03656         end
<a name="l03657"></a>03657         
<a name="l03658"></a>03658         %<span class="keywordtype">boolean</span> (genome length x 2) indicating positions of gap sites 3&#39;
<a name="l03659"></a>03659         %to bases
<a name="l03660"></a>03660         function value = get.gapSites3(this)
<a name="l03661"></a>03661             if this.validated_gapSites &gt; this.validated_gapSites3
<a name="l03662"></a>03662                 this.gapSites3 = this.calcGapSites3();
<a name="l03663"></a>03663                 this.validated_gapSites3 = this.validated;
<a name="l03664"></a>03664             end
<a name="l03665"></a>03665             
<a name="l03666"></a>03666             value = this.gapSites3;
<a name="l03667"></a>03667         end
<a name="l03668"></a>03668         
<a name="l03669"></a>03669         function value = calcGapSites3(this)
<a name="l03670"></a>03670             value = this.shiftCircularSparseMatBase5Prime(this.gapSites);
<a name="l03671"></a>03671         end
<a name="l03672"></a>03672         
<a name="l03673"></a>03673         %<span class="keywordtype">boolean</span> (genome length x 2) indicating positions of gap sites 5&#39;
<a name="l03674"></a>03674         %to bases
<a name="l03675"></a>03675         function value = get.gapSites5(this)
<a name="l03676"></a>03676             if this.validated_gapSites &gt; this.validated_gapSites5
<a name="l03677"></a>03677                 this.gapSites5 = this.calcGapSites5();
<a name="l03678"></a>03678                 this.validated_gapSites5 = this.validated;
<a name="l03679"></a>03679             end
<a name="l03680"></a>03680             
<a name="l03681"></a>03681             value = this.gapSites5;
<a name="l03682"></a>03682         end
<a name="l03683"></a>03683         
<a name="l03684"></a>03684         function value = calcGapSites5(this)
<a name="l03685"></a>03685             value = this.shiftCircularSparseMatBase3Prime(this.gapSites);
<a name="l03686"></a>03686         end
<a name="l03687"></a>03687         
<a name="l03688"></a>03688         %<span class="keywordtype">boolean</span> (genome length x 2) indicating positions of abasic sites 3&#39;
<a name="l03689"></a>03689         %to bases
<a name="l03690"></a>03690         function value = get.abasicSites3(this)
<a name="l03691"></a>03691             if this.validated_abasicSites &gt; this.validated_abasicSites3
<a name="l03692"></a>03692                 this.abasicSites3 = this.calcAbasicSites3();
<a name="l03693"></a>03693                 this.validated_abasicSites3 = this.validated;
<a name="l03694"></a>03694             end
<a name="l03695"></a>03695             
<a name="l03696"></a>03696             value = this.abasicSites3;
<a name="l03697"></a>03697         end
<a name="l03698"></a>03698         
<a name="l03699"></a>03699         function value = calcAbasicSites3(this)
<a name="l03700"></a>03700             value = this.shiftCircularSparseMatBase5Prime(this.abasicSites);
<a name="l03701"></a>03701         end
<a name="l03702"></a>03702         
<a name="l03703"></a>03703         %<span class="keywordtype">boolean</span> (genome length x 2) indicating positions of abasic sites 5&#39;
<a name="l03704"></a>03704         %to bases
<a name="l03705"></a>03705         function value = get.abasicSites5(this)
<a name="l03706"></a>03706             if this.validated_abasicSites &gt; this.validated_abasicSites5
<a name="l03707"></a>03707                 this.abasicSites5 = this.calcAbasicSites5();
<a name="l03708"></a>03708                 this.validated_abasicSites5 = this.validated;
<a name="l03709"></a>03709             end
<a name="l03710"></a>03710             
<a name="l03711"></a>03711             value = this.abasicSites5;
<a name="l03712"></a>03712         end
<a name="l03713"></a>03713         
<a name="l03714"></a>03714         function value = calcAbasicSites5(this)
<a name="l03715"></a>03715             value = this.shiftCircularSparseMatBase3Prime(this.abasicSites);
<a name="l03716"></a>03716         end
<a name="l03717"></a>03717         
<a name="l03718"></a>03718         %integer (genome length x 2) indicating indices of damaged sugar
<a name="l03719"></a>03719         %phosphates 3&#39; to bases
<a name="l03720"></a>03720         function value = get.damagedSugarPhosphates3(this)
<a name="l03721"></a>03721             if this.validated_damagedSugarPhosphates &gt; this.validated_damagedSugarPhosphates3
<a name="l03722"></a>03722                 this.damagedSugarPhosphates3 = this.calcDamagedSugarPhosphates3();
<a name="l03723"></a>03723                 this.validated_damagedSugarPhosphates3 = this.validated;
<a name="l03724"></a>03724             end
<a name="l03725"></a>03725             
<a name="l03726"></a>03726             value = this.damagedSugarPhosphates3;
<a name="l03727"></a>03727         end
<a name="l03728"></a>03728         
<a name="l03729"></a>03729         function value = calcDamagedSugarPhosphates3(this)
<a name="l03730"></a>03730             value = this.shiftCircularSparseMatBase5Prime(this.damagedSugarPhosphates);
<a name="l03731"></a>03731         end
<a name="l03732"></a>03732         
<a name="l03733"></a>03733         %integer (genome length x 2) indicating indices of damaged sugar
<a name="l03734"></a>03734         %phosphates 5&#39; to bases
<a name="l03735"></a>03735         function value = get.damagedSugarPhosphates5(this)
<a name="l03736"></a>03736             if this.validated_damagedSugarPhosphates &gt; this.validated_damagedSugarPhosphates5
<a name="l03737"></a>03737                 this.damagedSugarPhosphates5 = this.calcDamagedSugarPhosphates5();
<a name="l03738"></a>03738                 this.validated_damagedSugarPhosphates5 = this.validated;
<a name="l03739"></a>03739             end
<a name="l03740"></a>03740             
<a name="l03741"></a>03741             value = this.damagedSugarPhosphates5;
<a name="l03742"></a>03742         end
<a name="l03743"></a>03743         
<a name="l03744"></a>03744         function value = calcDamagedSugarPhosphates5(this)
<a name="l03745"></a>03745             value = this.shiftCircularSparseMatBase3Prime(this.damagedSugarPhosphates);
<a name="l03746"></a>03746         end
<a name="l03747"></a>03747         
<a name="l03748"></a>03748         %integer (genome length x 2) indicating indices of damaged bases 3&#39; to bases
<a name="l03749"></a>03749         function value = get.damagedBases3(this)
<a name="l03750"></a>03750             if this.validated_damagedBases &gt; this.validated_damagedBases3
<a name="l03751"></a>03751                 this.damagedBases3 = this.calcDamagedBases3();
<a name="l03752"></a>03752                 this.validated_damagedBases3 = this.validated;
<a name="l03753"></a>03753             end
<a name="l03754"></a>03754             
<a name="l03755"></a>03755             value = this.damagedBases3;
<a name="l03756"></a>03756         end
<a name="l03757"></a>03757         
<a name="l03758"></a>03758         function value = calcDamagedBases3(this)
<a name="l03759"></a>03759             value = this.shiftCircularSparseMatBase5Prime(this.damagedBases);
<a name="l03760"></a>03760         end
<a name="l03761"></a>03761         
<a name="l03762"></a>03762         %integer (genome length x 2) indicating indices of damaged bases 5&#39; to bases
<a name="l03763"></a>03763         function value = get.damagedBases5(this)
<a name="l03764"></a>03764             if this.validated_damagedBases &gt; this.validated_damagedBases5
<a name="l03765"></a>03765                 this.damagedBases5 = this.calcDamagedBases5();
<a name="l03766"></a>03766                 this.validated_damagedBases5 = this.validated;
<a name="l03767"></a>03767             end
<a name="l03768"></a>03768             
<a name="l03769"></a>03769             value = this.damagedBases5;
<a name="l03770"></a>03770         end
<a name="l03771"></a>03771         
<a name="l03772"></a>03772         function value = calcDamagedBases5(this)
<a name="l03773"></a>03773             value = this.shiftCircularSparseMatBase3Prime(this.damagedBases);
<a name="l03774"></a>03774         end
<a name="l03775"></a>03775         
<a name="l03776"></a>03776         %<span class="keywordtype">boolean</span> (genome length x 2) indicating positions of intrastrand cross
<a name="l03777"></a>03777         %links 3&#39; to bases
<a name="l03778"></a>03778         function value = get.intrastrandCrossLinks3(this)
<a name="l03779"></a>03779             if this.validated_intrastrandCrossLinks &gt; this.validated_intrastrandCrossLinks3
<a name="l03780"></a>03780                 this.intrastrandCrossLinks3 = this.calcIntrastrandCrossLinks3();
<a name="l03781"></a>03781                 this.validated_intrastrandCrossLinks3 = this.validated;
<a name="l03782"></a>03782             end
<a name="l03783"></a>03783             
<a name="l03784"></a>03784             value = this.intrastrandCrossLinks3;
<a name="l03785"></a>03785         end
<a name="l03786"></a>03786         
<a name="l03787"></a>03787         function value = calcIntrastrandCrossLinks3(this)
<a name="l03788"></a>03788             value = this.shiftCircularSparseMatBase5Prime(this.intrastrandCrossLinks);
<a name="l03789"></a>03789         end
<a name="l03790"></a>03790         
<a name="l03791"></a>03791         %<span class="keywordtype">boolean</span> (genome length x 2) indicating positions of intrastrand cross
<a name="l03792"></a>03792         %links 5&#39; to bases
<a name="l03793"></a>03793         function value = get.intrastrandCrossLinks5(this)
<a name="l03794"></a>03794             if this.validated_intrastrandCrossLinks &gt; this.validated_intrastrandCrossLinks5
<a name="l03795"></a>03795                 this.intrastrandCrossLinks5 = this.calcIntrastrandCrossLinks5();
<a name="l03796"></a>03796                 this.validated_intrastrandCrossLinks5 = this.validated;
<a name="l03797"></a>03797             end
<a name="l03798"></a>03798             
<a name="l03799"></a>03799             value = this.intrastrandCrossLinks5;
<a name="l03800"></a>03800         end
<a name="l03801"></a>03801         
<a name="l03802"></a>03802         function value = calcIntrastrandCrossLinks5(this)
<a name="l03803"></a>03803             value = this.shiftCircularSparseMatBase3Prime(this.intrastrandCrossLinks);
<a name="l03804"></a>03804         end
<a name="l03805"></a>03805         
<a name="l03806"></a>03806         %<span class="keywordtype">boolean</span> (genome length x 2) indicating positions of strand breaks
<a name="l03807"></a>03807         %3&#39; to bases
<a name="l03808"></a>03808         function value = get.strandBreaks3(this)
<a name="l03809"></a>03809             if this.validated_strandBreaks &gt; this.validated_strandBreaks3
<a name="l03810"></a>03810                 this.strandBreaks3 = this.calcStrandBreaks3();
<a name="l03811"></a>03811                 this.validated_strandBreaks3 = this.validated;
<a name="l03812"></a>03812             end
<a name="l03813"></a>03813             
<a name="l03814"></a>03814             value = this.strandBreaks3;
<a name="l03815"></a>03815         end
<a name="l03816"></a>03816         
<a name="l03817"></a>03817         function value = calcStrandBreaks3(this)
<a name="l03818"></a>03818             value = this.unshiftCircularSparseMatBond3Prime(this.strandBreaks);
<a name="l03819"></a>03819         end
<a name="l03820"></a>03820         
<a name="l03821"></a>03821         %<span class="keywordtype">boolean</span> (genome length x 2) indicating positions of strand breaks
<a name="l03822"></a>03822         %5&#39; to bases
<a name="l03823"></a>03823         function value = get.strandBreaks5(this)
<a name="l03824"></a>03824             if this.validated_strandBreaks &gt; this.validated_strandBreaks5
<a name="l03825"></a>03825                 this.strandBreaks5 = this.calcStrandBreaks5();
<a name="l03826"></a>03826                 this.validated_strandBreaks5 = this.validated;
<a name="l03827"></a>03827             end
<a name="l03828"></a>03828             
<a name="l03829"></a>03829             value = this.strandBreaks5;
<a name="l03830"></a>03830         end
<a name="l03831"></a>03831         
<a name="l03832"></a>03832         function value = calcStrandBreaks5(this)
<a name="l03833"></a>03833             value = this.unshiftCircularSparseMatBond5Prime(this.strandBreaks);
<a name="l03834"></a>03834         end
<a name="l03835"></a>03835         
<a name="l03836"></a>03836         %<span class="keywordtype">boolean</span> (genome length x 2) indicating positions of holliday junctions
<a name="l03837"></a>03837         %3&#39; to bases
<a name="l03838"></a>03838         function value = get.hollidayJunctions3(this)
<a name="l03839"></a>03839             if this.validated_hollidayJunctions &gt; this.validated_hollidayJunctions3
<a name="l03840"></a>03840                 this.hollidayJunctions3 = this.calcHollidayJunctions3();
<a name="l03841"></a>03841                 this.validated_hollidayJunctions3 = this.validated;
<a name="l03842"></a>03842             end
<a name="l03843"></a>03843             
<a name="l03844"></a>03844             value = this.hollidayJunctions3;
<a name="l03845"></a>03845         end
<a name="l03846"></a>03846         
<a name="l03847"></a>03847         function value = calcHollidayJunctions3(this)
<a name="l03848"></a>03848             value = this.shiftCircularSparseMatBond5Prime(this.hollidayJunctions);
<a name="l03849"></a>03849         end
<a name="l03850"></a>03850         
<a name="l03851"></a>03851         %<span class="keywordtype">boolean</span> (genome length x 2) indicating positions of holliday junctions
<a name="l03852"></a>03852         %5&#39; to bases
<a name="l03853"></a>03853         function value = get.hollidayJunctions5(this)
<a name="l03854"></a>03854             if this.validated_hollidayJunctions &gt; this.validated_hollidayJunctions5
<a name="l03855"></a>03855                 this.hollidayJunctions5 = this.calcHollidayJunctions5();
<a name="l03856"></a>03856                 this.validated_hollidayJunctions5 = this.validated;
<a name="l03857"></a>03857             end
<a name="l03858"></a>03858             
<a name="l03859"></a>03859             value = this.hollidayJunctions5;
<a name="l03860"></a>03860         end
<a name="l03861"></a>03861         
<a name="l03862"></a>03862         function value = calcHollidayJunctions5(this)
<a name="l03863"></a>03863             value = this.shiftCircularSparseMatBond3Prime(this.hollidayJunctions);
<a name="l03864"></a>03864         end
<a name="l03865"></a>03865         
<a name="l03866"></a>03866         %<span class="keywordtype">boolean</span> (genome length x 2) indicating positions of single
<a name="l03867"></a>03867         %strand breaks -- strand breaks excluding
<a name="l03868"></a>03868         %- <span class="keywordtype">double</span> strand breaks that are part of <span class="keywordtype">double</span> strand breaks
<a name="l03869"></a>03869         %- strand breaks adjacent to gap sites
<a name="l03870"></a>03870         function value = get.singleStrandBreaks(this)
<a name="l03871"></a>03871             if this.validated_damaged &gt; this.validated_singleStrandBreaks
<a name="l03872"></a>03872                 this.singleStrandBreaks = this.calcSingleStrandBreaks();
<a name="l03873"></a>03873                 this.validated_singleStrandBreaks = this.validated;
<a name="l03874"></a>03874             end
<a name="l03875"></a>03875             
<a name="l03876"></a>03876             value = this.singleStrandBreaks;
<a name="l03877"></a>03877         end
<a name="l03878"></a>03878         
<a name="l03879"></a>03879         function value = calcSingleStrandBreaks(this)           
<a name="l03880"></a>03880             value = this.strandBreaks;
<a name="l03881"></a>03881             
<a name="l03882"></a>03882             %exclude strand breaks that are part of <span class="keywordtype">double</span> strand breaks
<a name="l03883"></a>03883             value(find(this.doubleStrandBreaks)) = 0; %<span class="preprocessor">#ok&lt;FNDSB&gt;</span>
<a name="l03884"></a>03884 <span class="preprocessor"></span>            
<a name="l03885"></a>03885             %exclude strand breaks adjacent to other damage (except holliday
<a name="l03886"></a>03886             %junctions)
<a name="l03887"></a>03887             otherDamages = this.getDamagedSites(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);
<a name="l03888"></a>03888             value(find( ...
<a name="l03889"></a>03889                 this.shiftCircularSparseMatBond3Prime(otherDamages) | ...
<a name="l03890"></a>03890                 this.shiftCircularSparseMatBond5Prime(otherDamages) ...
<a name="l03891"></a>03891                 )) = 0; %#ok&lt;FNDSB&gt;
<a name="l03892"></a>03892             
<a name="l03893"></a>03893             %cast to logical sparse mat
<a name="l03894"></a>03894             value = valueCast(value, <span class="stringliteral">&#39;logical&#39;</span>);
<a name="l03895"></a>03895         end
<a name="l03896"></a>03896         
<a name="l03897"></a>03897         <span class="keyword">function</span> value = <span class="keyword">get</span>.doubleStrandBreaks(<span class="keyword">this</span>)
<a name="l03898"></a>03898             <span class="keywordflow">if</span> this.validated_strandBreaks &gt; this.validated_doubleStrandBreaks
<a name="l03899"></a>03899                 this.doubleStrandBreaks = this.calcDoubleStrandBreaks();
<a name="l03900"></a>03900                 this.validated_doubleStrandBreaks = this.validated;
<a name="l03901"></a>03901             end
<a name="l03902"></a>03902             
<a name="l03903"></a>03903             value = this.doubleStrandBreaks;
<a name="l03904"></a>03904         end
<a name="l03905"></a>03905         
<a name="l03906"></a>03906         <span class="keyword">function</span> value = calcDoubleStrandBreaks(<span class="keyword">this</span>)
<a name="l03907"></a>03907             import edu.stanford.covert.util.CircularSparseMat;
<a name="l03908"></a>03908             
<a name="l03909"></a>03909             if this.doubleStrandBreakSeparation ~= 1
<a name="l03910"></a>03910                 throw(MException(&#39;DNARepair:error&#39;,&#39;Simulation only valid for doubleStrandBreakSeparation equal 1&#39;));
<a name="l03911"></a>03911             end
<a name="l03912"></a>03912             
<a name="l03913"></a>03913             value = this.strandBreaks(:, 1:2:end, :) &amp; this.strandBreaks(:, 2:2:end, :);
<a name="l03914"></a>03914             value = [value(:,1) value(:,1) value(:,2) value(:,2)];
<a name="l03915"></a>03915         end
<a name="l03916"></a>03916                 
<a name="l03917"></a>03917         function value = get.restrictableMunIRMSites(this)
<a name="l03918"></a>03918             if ...
<a name="l03919"></a>03919                     this.validated_damagedBases &gt; this.validated_munIRMSiteRestrictionStatus || ...
<a name="l03920"></a>03920                     this.validated_strandBreaks &gt; this.validated_munIRMSiteRestrictionStatus
<a name="l03921"></a>03921                 this.restrictableMunIRMSites = this.calcRestrictableMunIRMSites();
<a name="l03922"></a>03922                 this.validated_munIRMSiteRestrictionStatus = this.validated;
<a name="l03923"></a>03923             end
<a name="l03924"></a>03924             
<a name="l03925"></a>03925             value = this.restrictableMunIRMSites;
<a name="l03926"></a>03926         end
<a name="l03927"></a>03927         
<a name="l03928"></a>03928         function value = get.hemiunmethylatedMunIRMSites(this)
<a name="l03929"></a>03929             if this.validated_damagedBases &gt; this.validated_munIRMSiteMethylationStatus
<a name="l03930"></a>03930                 this.hemiunmethylatedMunIRMSites = this.calcHemiunmethylatedMunIRMSites();
<a name="l03931"></a>03931                 this.validated_munIRMSiteMethylationStatus = this.validated;
<a name="l03932"></a>03932             end
<a name="l03933"></a>03933             
<a name="l03934"></a>03934             value = this.hemiunmethylatedMunIRMSites;
<a name="l03935"></a>03935         end
<a name="l03936"></a>03936         
<a name="l03937"></a>03937         function value = calcRestrictableMunIRMSites(this)
<a name="l03938"></a>03938             import edu.stanford.covert.util.CircularSparseMat;
<a name="l03939"></a>03939             
<a name="l03940"></a>03940             dr = this.dnaRepair;
<a name="l03941"></a>03941             nSites = size(dr.RM_MunI_RecognitionSites, 1);
<a name="l03942"></a>03942             methylationPosStrnds = [
<a name="l03943"></a>03943                 dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_MethylatedPositions(1))   ones(nSites, 1);
<a name="l03944"></a>03944                 dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_MethylatedPositions(1)) 3*ones(nSites, 1);
<a name="l03945"></a>03945                 dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_MethylatedPositions(2)) 2*ones(nSites, 1);
<a name="l03946"></a>03946                 dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_MethylatedPositions(2)) 4*ones(nSites, 1)];
<a name="l03947"></a>03947             restrictionPosStrnds = [
<a name="l03948"></a>03948                 dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_RestrictionPositions(1))   ones(nSites, 1);
<a name="l03949"></a>03949                 dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_RestrictionPositions(1)) 3*ones(nSites, 1);
<a name="l03950"></a>03950                 dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_RestrictionPositions(2)) 2*ones(nSites, 1);
<a name="l03951"></a>03951                 dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_RestrictionPositions(2)) 4*ones(nSites, 1)];
<a name="l03952"></a>03952             
<a name="l03953"></a>03953             isPositionMethylated = reshape(this.damagedBases(methylationPosStrnds), [], 2) == this.metabolite.m6ADIndexs;
<a name="l03954"></a>03954             isPositionDamaged = [
<a name="l03955"></a>03955                 cat(3, ...
<a name="l03956"></a>03956                     reshape(this.damagedSites_shifted_incm6AD([dr.RM_MunI_RecognitionSites(:)   ones(6*nSites, 1)]), [], 6), ...
<a name="l03957"></a>03957                     reshape(this.damagedSites_shifted_incm6AD([dr.RM_MunI_RecognitionSites(:) 2*ones(6*nSites, 1)]), [], 6))
<a name="l03958"></a>03958                 cat(3, ...
<a name="l03959"></a>03959                     reshape(this.damagedSites_shifted_incm6AD([dr.RM_MunI_RecognitionSites(:) 3*ones(6*nSites, 1)]), [], 6), ...
<a name="l03960"></a>03960                     reshape(this.damagedSites_shifted_incm6AD([dr.RM_MunI_RecognitionSites(:) 4*ones(6*nSites, 1)]), [], 6))];
<a name="l03961"></a>03961             isPositionStrandBreaks = [
<a name="l03962"></a>03962                 cat(3, ...
<a name="l03963"></a>03963                     this.strandBreaks([reshape(dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_RestrictionPositions(1)), [], 1),   ones(nSites, 1)]),...
<a name="l03964"></a>03964                     this.strandBreaks([reshape(dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_RestrictionPositions(2)), [], 1), 2*ones(nSites, 1)])), ...
<a name="l03965"></a>03965                 cat(3, ...
<a name="l03966"></a>03966                     this.strandBreaks([reshape(dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_RestrictionPositions(1)), [], 1), 3*ones(nSites, 1)]),...
<a name="l03967"></a>03967                     this.strandBreaks([reshape(dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_RestrictionPositions(2)), [], 1), 4*ones(nSites, 1)]))];
<a name="l03968"></a>03968             isPositionDamaged(isPositionStrandBreaks) = 0;
<a name="l03969"></a>03969             isSiteUndamaged = ~any(any(isPositionDamaged, 2), 3);
<a name="l03970"></a>03970             
<a name="l03971"></a>03971             isSiteUnmethylated = ~any(isPositionMethylated, 2);
<a name="l03972"></a>03972             isSitePolymerized = this.isRegionPolymerized(restrictionPosStrnds, 1, false, false, false);
<a name="l03973"></a>03973             
<a name="l03974"></a>03974             value = CircularSparseMat(...
<a name="l03975"></a>03975                 restrictionPosStrnds([isSiteUnmethylated; isSiteUnmethylated] &amp; [isSiteUndamaged; isSiteUndamaged] &amp; isSitePolymerized, :), ...
<a name="l03976"></a>03976                 true, [this.sequenceLen this.nCompartments], 1);
<a name="l03977"></a>03977         end
<a name="l03978"></a>03978         
<a name="l03979"></a>03979         function value = calcHemiunmethylatedMunIRMSites(this)
<a name="l03980"></a>03980             import edu.stanford.covert.util.CircularSparseMat;
<a name="l03981"></a>03981             
<a name="l03982"></a>03982             dr = this.dnaRepair;
<a name="l03983"></a>03983             nSites = size(dr.RM_MunI_RecognitionSites, 1);
<a name="l03984"></a>03984             methylationPosStrnds = [
<a name="l03985"></a>03985                 dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_MethylatedPositions(1))   ones(nSites, 1);
<a name="l03986"></a>03986                 dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_MethylatedPositions(1)) 3*ones(nSites, 1);
<a name="l03987"></a>03987                 dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_MethylatedPositions(2)) 2*ones(nSites, 1);
<a name="l03988"></a>03988                 dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_MethylatedPositions(2)) 4*ones(nSites, 1)];
<a name="l03989"></a>03989             
<a name="l03990"></a>03990             isPositionMethylated = reshape(this.damagedBases(methylationPosStrnds), [], 2) == this.metabolite.m6ADIndexs;
<a name="l03991"></a>03991             
<a name="l03992"></a>03992             isSiteMethylated = all(isPositionMethylated, 2);
<a name="l03993"></a>03993             isSiteUnmethylated = ~any(isPositionMethylated, 2);
<a name="l03994"></a>03994             isSiteHemimethylated = ~isSiteMethylated &amp; ~isSiteUnmethylated;
<a name="l03995"></a>03995             
<a name="l03996"></a>03996             value = CircularSparseMat(...
<a name="l03997"></a>03997                 methylationPosStrnds([isSiteHemimethylated; isSiteHemimethylated] &amp; ~isPositionMethylated(:), :),  ...
<a name="l03998"></a>03998                 1, [this.sequenceLen this.nCompartments], 1);
<a name="l03999"></a>03999         end
<a name="l04000"></a>04000                 
<a name="l04001"></a>04001         function value = get.dryWeight(this)
<a name="l04002"></a>04002             if max(this.validated_polymerizedRegions, this.validated_damaged) &gt; this.validated_dryWeight
<a name="l04003"></a>04003                 this.dryWeight = this.calcDryWeight();
<a name="l04004"></a>04004                 this.validated_dryWeight = this.validated;
<a name="l04005"></a>04005             end
<a name="l04006"></a>04006            
<a name="l04007"></a>04007             value = this.dryWeight;
<a name="l04008"></a>04008         end
<a name="l04009"></a>04009         
<a name="l04010"></a>04010         function value = calcDryWeight(this)
<a name="l04011"></a>04011             import edu.stanford.covert.util.<a class="code" href="class_constant_util.html">ConstantUtil</a>;
<a name="l04012"></a>04012             
<a name="l04013"></a>04013             %time
<a name="l04014"></a>04014             numTime = size(this.abasicSites, 3);
<a name="l04015"></a>04015             
<a name="l04016"></a>04016             %mass of undamaged DNA
<a name="l04017"></a>04017             baseCounts = zeros(4, numTime);
<a name="l04018"></a>04018             bonds = zeros(1, numTime);
<a name="l04019"></a>04019             [positionsStrandTimes, lengths] = find(this.getStrandView(&#39;polymerizedRegions&#39;));
<a name="l04020"></a>04020             positionsStrandTimes = [positionsStrandTimes ones(size(positionsStrandTimes, 1), 3 - size(positionsStrandTimes, 2))];
<a name="l04021"></a>04021             
<a name="l04022"></a>04022             for i = 1:size(positionsStrandTimes, 1)
<a name="l04023"></a>04023                 if lengths(i) == this.sequenceLen
<a name="l04024"></a>04024                     baseCounts(:, positionsStrandTimes(i, 3)) = ...
<a name="l04025"></a>04025                         baseCounts(:, positionsStrandTimes(i, 3)) + ...
<a name="l04026"></a>04026                         getBaseCounts(this.sequence, positionsStrandTimes(i, 2));
<a name="l04027"></a>04027                 else
<a name="l04028"></a>04028                     baseCounts(:, positionsStrandTimes(i, 3)) = ...
<a name="l04029"></a>04029                         baseCounts(:, positionsStrandTimes(i, 3)) + ...
<a name="l04030"></a>04030                         this.sequence.subsequenceBaseCounts(positionsStrandTimes(i,1) + (0:lengths(i)-1)&#39;, positionsStrandTimes(i, 2));
<a name="l04031"></a>04031                 end
<a name="l04032"></a>04032                 bonds(1, positionsStrandTimes(i,3)) = ...
<a name="l04033"></a>04033                     bonds(1, positionsStrandTimes(i,3)) + lengths(i) - 1;
<a name="l04034"></a>04034                 
<a name="l04035"></a>04035                 if ...
<a name="l04036"></a>04036                         lengths(i) == this.sequenceLen || ...
<a name="l04037"></a>04037                         (positionsStrandTimes(i, 1) + lengths(i) - 1 == this.sequenceLen &amp;&amp; ...
<a name="l04038"></a>04038                         ismember([1 positionsStrandTimes(i, 2:end)], positionsStrandTimes, &#39;rows&#39;))
<a name="l04039"></a>04039                     bonds(1, positionsStrandTimes(i,3)) = ...
<a name="l04040"></a>04040                         bonds(1, positionsStrandTimes(i,3)) + 1;
<a name="l04041"></a>04041                 end
<a name="l04042"></a>04042             end
<a name="l04043"></a>04043             
<a name="l04044"></a>04044             value = this.metabolite.molecularWeights(this.metabolite.dnmpIndexs)&#39; * baseCounts ...
<a name="l04045"></a>04045                 - (ConstantUtil.elements.H + ConstantUtil.elements.O) * bonds;
<a name="l04046"></a>04046             
<a name="l04047"></a>04047             %mass represented by damage
<a name="l04048"></a>04048             for k = 1:numTime
<a name="l04049"></a>04049                 %gap sites
<a name="l04050"></a>04050                 value(:,k) = value(:,k) - ...
<a name="l04051"></a>04051                     (this.metabolite.molecularWeights(this.metabolite.dr5pIndexs) - ...
<a name="l04052"></a>04052                     2 * ConstantUtil.elements.H) * collapse(this.gapSites(:,:,k));
<a name="l04053"></a>04053                 
<a name="l04054"></a>04054                 %abasic sites
<a name="l04055"></a>04055                 [position, index] = find(this.abasicSites(:,:,k));
<a name="l04056"></a>04056                 value(:,k) = value(:,k) - ...
<a name="l04057"></a>04057                     length(index) * this.metabolite.molecularWeights(this.metabolite.waterIndexs) - ...
<a name="l04058"></a>04058                     this.sequence.subsequenceBaseCounts(position)&#39; * ...
<a name="l04059"></a>04059                     this.metabolite.molecularWeights(this.metabolite.dnmpIndexs);
<a name="l04060"></a>04060                 
<a name="l04061"></a>04061                 %damaged sugar-phosphates
<a name="l04062"></a>04062                 [~, index] = find(this.damagedSugarPhosphates(:,:,k));
<a name="l04063"></a>04063                 value(:,k) = value(:,k) + ...
<a name="l04064"></a>04064                     sum(this.metabolite.molecularWeights(index)) - ...
<a name="l04065"></a>04065                     length(index) * this.metabolite.molecularWeights(this.metabolite.dr5pIndexs);
<a name="l04066"></a>04066                 
<a name="l04067"></a>04067                 %damaged bases
<a name="l04068"></a>04068                 [position, index] = find(this.damagedBases(:,:,k));
<a name="l04069"></a>04069                 value(:,k) = value(:,k) + ...
<a name="l04070"></a>04070                     sum(this.metabolite.molecularWeights(index)) - ...
<a name="l04071"></a>04071                     this.sequence.subsequenceBaseCounts(position)&#39; * ...
<a name="l04072"></a>04072                     this.metabolite.molecularWeights(this.metabolite.unmodifiedBaseIndexs);
<a name="l04073"></a>04073                 
<a name="l04074"></a>04074                 %intrastrand cross links
<a name="l04075"></a>04075                 [position, index] = find(this.intrastrandCrossLinks(:,:,k));
<a name="l04076"></a>04076                 value(:,k) = value(:,k) + ...
<a name="l04077"></a>04077                     sum(this.metabolite.molecularWeights(index)) - ...
<a name="l04078"></a>04078                     this.sequence.subsequenceBaseCounts([position(:,1) position(:,1) + 1], position(:,2))&#39; * ...
<a name="l04079"></a>04079                     this.metabolite.molecularWeights(this.metabolite.dnmpIndexs);
<a name="l04080"></a>04080                 
<a name="l04081"></a>04081                 %strand breaks
<a name="l04082"></a>04082                 value(:,k) = value(:,k) + ...
<a name="l04083"></a>04083                     (ConstantUtil.elements.H + ConstantUtil.elements.O)*...
<a name="l04084"></a>04084                     collapse(this.strandBreaks(:,:,k));
<a name="l04085"></a>04085             end
<a name="l04086"></a>04086             
<a name="l04087"></a>04087             value = permute(value, [1 3 2]);
<a name="l04088"></a>04088             value = value / ConstantUtil.nAvogadro;
<a name="l04089"></a>04089         end
<a name="l04090"></a>04090     end
<a name="l04091"></a>04091     
<a name="l04092"></a>04092     %helper methods
<a name="l04093"></a>04093     methods (Static)
<a name="l04094"></a>04094         function value = shiftCircularSparseMatBase3Prime(sparseMat, varargin)
<a name="l04095"></a>04095             import edu.stanford.covert.cell.sim.state.<a class="code" href="class_chromosome.html">Chromosome</a>;
<a name="l04096"></a>04096             import edu.stanford.covert.util.CircularSparseMat;
<a name="l04097"></a>04097             
<a name="l04098"></a>04098             if ~isa(sparseMat,&#39;CircularSparseMat&#39;) || ~isDimCircular(sparseMat, 1)
<a name="l04099"></a>04099                 throw(MException(&#39;Chromosome:error&#39;,&#39;sparseMat must be a circular sparse mat with a circular first dimension&#39;));
<a name="l04100"></a>04100             end
<a name="l04101"></a>04101             
<a name="l04102"></a>04102             [subs, vals] = find(sparseMat);
<a name="l04103"></a>04103             subs = Chromosome.shiftPositionsStrandsBase3Prime(subs, varargin{:});
<a name="l04104"></a>04104             value = CircularSparseMat(subs, vals, size(sparseMat), 1);
<a name="l04105"></a>04105         end
<a name="l04106"></a>04106         
<a name="l04107"></a>04107         <span class="keyword">function</span> value = shiftCircularSparseMatBase5Prime(sparseMat, varargin)
<a name="l04108"></a>04108             import edu.stanford.covert.cell.sim.state.<a class="code" href="class_chromosome.html">Chromosome</a>;
<a name="l04109"></a>04109             import edu.stanford.covert.util.CircularSparseMat;
<a name="l04110"></a>04110             
<a name="l04111"></a>04111             if ~isa(sparseMat,&#39;CircularSparseMat&#39;) || ~isDimCircular(sparseMat, 1)
<a name="l04112"></a>04112                 throw(MException(&#39;Chromosome:error&#39;,&#39;sparseMat must be a circular sparse mat with a circular first dimension&#39;));
<a name="l04113"></a>04113             end
<a name="l04114"></a>04114             
<a name="l04115"></a>04115             [subs, vals] = find(sparseMat);
<a name="l04116"></a>04116             subs = Chromosome.shiftPositionsStrandsBase5Prime(subs, varargin{:});
<a name="l04117"></a>04117             value = CircularSparseMat(subs, vals, size(sparseMat), 1);
<a name="l04118"></a>04118         end
<a name="l04119"></a>04119         
<a name="l04120"></a>04120         <span class="keyword">function</span> value = shiftCircularSparseMatBond3Prime(sparseMat, varargin)
<a name="l04121"></a>04121             import edu.stanford.covert.cell.sim.state.<a class="code" href="class_chromosome.html">Chromosome</a>;
<a name="l04122"></a>04122             import edu.stanford.covert.util.CircularSparseMat;
<a name="l04123"></a>04123             
<a name="l04124"></a>04124             if ~isa(sparseMat,&#39;CircularSparseMat&#39;) || ~isDimCircular(sparseMat, 1)
<a name="l04125"></a>04125                 throw(MException(&#39;Chromosome:error&#39;,&#39;sparseMat must be a circular sparse mat with a circular first dimension&#39;));
<a name="l04126"></a>04126             end
<a name="l04127"></a>04127             
<a name="l04128"></a>04128             [subs, vals] = find(sparseMat);
<a name="l04129"></a>04129             subs = Chromosome.shiftPositionsStrandsBond3Prime(subs, varargin{:});
<a name="l04130"></a>04130             value = CircularSparseMat(subs, vals, size(sparseMat), 1);
<a name="l04131"></a>04131         end
<a name="l04132"></a>04132         
<a name="l04133"></a>04133         <span class="keyword">function</span> value = unshiftCircularSparseMatBond3Prime(sparseMat, varargin)
<a name="l04134"></a>04134             import edu.stanford.covert.cell.sim.state.<a class="code" href="class_chromosome.html">Chromosome</a>;
<a name="l04135"></a>04135             import edu.stanford.covert.util.CircularSparseMat;
<a name="l04136"></a>04136             
<a name="l04137"></a>04137             if ~isa(sparseMat,&#39;CircularSparseMat&#39;) || ~isDimCircular(sparseMat, 1)
<a name="l04138"></a>04138                 throw(MException(&#39;Chromosome:error&#39;,&#39;sparseMat must be a circular sparse mat with a circular first dimension&#39;));
<a name="l04139"></a>04139             end
<a name="l04140"></a>04140             
<a name="l04141"></a>04141             [subs, vals] = find(sparseMat);
<a name="l04142"></a>04142             subs = Chromosome.unshiftPositionsStrandsBond3Prime(subs, varargin{:});
<a name="l04143"></a>04143             value = CircularSparseMat(subs, vals, size(sparseMat), 1);
<a name="l04144"></a>04144         end
<a name="l04145"></a>04145         
<a name="l04146"></a>04146         <span class="keyword">function</span> value = shiftCircularSparseMatBond5Prime(sparseMat, varargin)
<a name="l04147"></a>04147             import edu.stanford.covert.cell.sim.state.<a class="code" href="class_chromosome.html">Chromosome</a>;
<a name="l04148"></a>04148             import edu.stanford.covert.util.CircularSparseMat;
<a name="l04149"></a>04149             
<a name="l04150"></a>04150             if ~isa(sparseMat,&#39;CircularSparseMat&#39;) || ~isDimCircular(sparseMat, 1)
<a name="l04151"></a>04151                 throw(MException(&#39;Chromosome:error&#39;,&#39;sparseMat must be a circular sparse mat with a circular first dimension&#39;));
<a name="l04152"></a>04152             end
<a name="l04153"></a>04153             
<a name="l04154"></a>04154             [subs, vals] = find(sparseMat);
<a name="l04155"></a>04155             subs = Chromosome.shiftPositionsStrandsBond5Prime(subs, varargin{:});
<a name="l04156"></a>04156             value = CircularSparseMat(subs, vals, size(sparseMat), 1);
<a name="l04157"></a>04157         end
<a name="l04158"></a>04158         
<a name="l04159"></a>04159         <span class="keyword">function</span> value = unshiftCircularSparseMatBond5Prime(sparseMat, varargin)
<a name="l04160"></a>04160             import edu.stanford.covert.cell.sim.state.<a class="code" href="class_chromosome.html">Chromosome</a>;
<a name="l04161"></a>04161             import edu.stanford.covert.util.CircularSparseMat;
<a name="l04162"></a>04162             
<a name="l04163"></a>04163             if ~isa(sparseMat,&#39;CircularSparseMat&#39;) || ~isDimCircular(sparseMat, 1)
<a name="l04164"></a>04164                 throw(MException(&#39;Chromosome:error&#39;,&#39;sparseMat must be a circular sparse mat with a circular first dimension&#39;));
<a name="l04165"></a>04165             end
<a name="l04166"></a>04166             
<a name="l04167"></a>04167             [subs, vals] = find(sparseMat);
<a name="l04168"></a>04168             subs = Chromosome.unshiftPositionsStrandsBond5Prime(subs, varargin{:});
<a name="l04169"></a>04169             value = CircularSparseMat(subs, vals, size(sparseMat), 1);
<a name="l04170"></a>04170         end
<a name="l04171"></a>04171         
<a name="l04172"></a>04172         <span class="keyword">function</span> positionsStrands = shiftPositionsStrandsBase3Prime(positionsStrands, lengths)
<a name="l04173"></a>04173             if nargin &lt; 2
<a name="l04174"></a>04174                 lengths = 1; 
<a name="l04175"></a>04175             end
<a name="l04176"></a>04176             
<a name="l04177"></a>04177             positionsStrands(mod(positionsStrands(:,2),2)==1, 1) = ...
<a name="l04178"></a>04178                 positionsStrands(mod(positionsStrands(:,2),2)==1, 1) + lengths;
<a name="l04179"></a>04179             positionsStrands(mod(positionsStrands(:,2),2)==0, 1) = ...
<a name="l04180"></a>04180                 positionsStrands(mod(positionsStrands(:,2),2)==0, 1) - lengths;
<a name="l04181"></a>04181         end
<a name="l04182"></a>04182         
<a name="l04183"></a>04183         function positionsStrands = shiftPositionsStrandsBase5Prime(positionsStrands, lengths)
<a name="l04184"></a>04184             if nargin &lt; 2
<a name="l04185"></a>04185                 lengths = 1; 
<a name="l04186"></a>04186             end
<a name="l04187"></a>04187             
<a name="l04188"></a>04188             positionsStrands(mod(positionsStrands(:,2),2)==1, 1) = ...
<a name="l04189"></a>04189                 positionsStrands(mod(positionsStrands(:,2),2)==1, 1) - lengths;
<a name="l04190"></a>04190             positionsStrands(mod(positionsStrands(:,2),2)==0, 1) = ...
<a name="l04191"></a>04191                 positionsStrands(mod(positionsStrands(:,2),2)==0, 1) + lengths;
<a name="l04192"></a>04192         end
<a name="l04193"></a>04193         
<a name="l04194"></a>04194         function positionsStrands = shiftPositionsStrandsBond3Prime(positionsStrands, lengths)
<a name="l04195"></a>04195             if nargin &lt; 2
<a name="l04196"></a>04196                 lengths = 1; 
<a name="l04197"></a>04197             end
<a name="l04198"></a>04198             
<a name="l04199"></a>04199             positionsStrands(mod(positionsStrands(:,2),2)==0, 1) = ...
<a name="l04200"></a>04200                 positionsStrands(mod(positionsStrands(:,2),2)==0, 1) - lengths;
<a name="l04201"></a>04201         end
<a name="l04202"></a>04202         
<a name="l04203"></a>04203         function positionsStrands = unshiftPositionsStrandsBond3Prime(positionsStrands, lengths)
<a name="l04204"></a>04204             if nargin &lt; 2
<a name="l04205"></a>04205                 lengths = 1; 
<a name="l04206"></a>04206             end
<a name="l04207"></a>04207             
<a name="l04208"></a>04208             positionsStrands(mod(positionsStrands(:,2),2)==0, 1) = ...
<a name="l04209"></a>04209                 positionsStrands(mod(positionsStrands(:,2),2)==0, 1) + lengths;
<a name="l04210"></a>04210         end
<a name="l04211"></a>04211         
<a name="l04212"></a>04212         function positionsStrands = shiftPositionsStrandsBond5Prime(positionsStrands, lengths)
<a name="l04213"></a>04213             if nargin &lt; 2
<a name="l04214"></a>04214                 lengths = 1;
<a name="l04215"></a>04215             end
<a name="l04216"></a>04216             
<a name="l04217"></a>04217             positionsStrands(mod(positionsStrands(:,2),2)==1, 1) = ...
<a name="l04218"></a>04218                 positionsStrands(mod(positionsStrands(:,2),2)==1, 1) - lengths;
<a name="l04219"></a>04219         end
<a name="l04220"></a>04220         
<a name="l04221"></a>04221         function positionsStrands = unshiftPositionsStrandsBond5Prime(positionsStrands, lengths)
<a name="l04222"></a>04222             if nargin &lt; 2
<a name="l04223"></a>04223                 lengths = 1;
<a name="l04224"></a>04224             end
<a name="l04225"></a>04225             
<a name="l04226"></a>04226             positionsStrands(mod(positionsStrands(:,2),2)==1, 1) = ...
<a name="l04227"></a>04227                 positionsStrands(mod(positionsStrands(:,2),2)==1, 1) + lengths;
<a name="l04228"></a>04228         end
<a name="l04229"></a>04229         
<a name="l04230"></a>04230         function [footprint3Prime, footprint5Prime] = calculateFootprintOverhangs(footprint)
<a name="l04231"></a>04231             footprint5Prime = ceil((footprint-1)/2);
<a name="l04232"></a>04232             footprint3Prime = footprint - 1 - footprint5Prime;
<a name="l04233"></a>04233         end
<a name="l04234"></a>04234     end
<a name="l04235"></a>04235     
<a name="l04236"></a>04236     %printing
<a name="l04237"></a>04237     methods
<a name="l04238"></a>04238         %print state
<a name="l04239"></a>04239         function disp(this)
<a name="l04240"></a>04240             %superclass method
<a name="l04241"></a>04241             this.disp@edu.stanford.covert.cell.sim.<a class="code" href="class_cell_state.html">CellState</a>();
<a name="l04242"></a>04242 
<a name="l04243"></a>04243             %numbers of DNA damages
<a name="l04244"></a>04244             fprintf(&#39;%24s\t%4s\n&#39;,&#39;Damage Type&#39;,&#39;No.&#39;);
<a name="l04245"></a>04245             fprintf(&#39;%24s\t%4s\n&#39;,repmat(&#39;=&#39;,1,24), repmat(&#39;=&#39;,1,4));
<a name="l04246"></a>04246             fprintf(&#39;%24s\t%4d\n&#39;,&#39;Gap Sites&#39;,               collapse(this.gapSites));
<a name="l04247"></a>04247             fprintf(&#39;%24s\t%4d\n&#39;,&#39;Abasic Sites&#39;,            collapse(this.abasicSites));
<a name="l04248"></a>04248             fprintf(&#39;%24s\t%4d\n&#39;,&#39;Damaged sugar phosphates&#39;,collapse(this.damagedSugarPhosphates));
<a name="l04249"></a>04249             fprintf(&#39;%24s\t%4d\n&#39;,&#39;Damaged bases&#39;,           collapse(this.damagedBases));
<a name="l04250"></a>04250             fprintf(&#39;%24s\t%4d\n&#39;,&#39;Intrastrand cross links&#39;, collapse(this.intrastrandCrossLinks));
<a name="l04251"></a>04251             fprintf(&#39;%24s\t%4d\n&#39;,&#39;Strand breaks&#39;,           collapse(this.strandBreaks));
<a name="l04252"></a>04252             fprintf(&#39;%24s\t%4d\n&#39;,&#39;Holliday junctions&#39;,      collapse(this.hollidayJunctions));
<a name="l04253"></a>04253             fprintf(&#39;\n&#39;);
<a name="l04254"></a>04254             
<a name="l04255"></a>04255             %strand break classification used in track structure models
<a name="l04256"></a>04256             sbc = this.strandBreakClassification();
<a name="l04257"></a>04257             fprintf(&#39;%24s\t%4s\n&#39;,&#39;Strand Break&#39;,&#39;No.&#39;)
<a name="l04258"></a>04258             fprintf(&#39;%24s\t%4s\n&#39;,repmat(&#39;=&#39;,1,24), repmat(&#39;=&#39;,1,4))
<a name="l04259"></a>04259             fprintf(&#39;%24s\t%4d\n&#39;,&#39;NB&#39;,    sbc(this.strandBreakClassification_index_NB));
<a name="l04260"></a>04260             fprintf(&#39;%24s\t%4d\n&#39;,&#39;SSB&#39;,   sbc(this.strandBreakClassification_index_SSB));
<a name="l04261"></a>04261             fprintf(&#39;%24s\t%4d\n&#39;,&#39;SSB+&#39;,  sbc(this.strandBreakClassification_index_SSB_));
<a name="l04262"></a>04262             fprintf(&#39;%24s\t%4d\n&#39;,&#39;2SSB&#39;,  sbc(this.strandBreakClassification_index_2SSB));
<a name="l04263"></a>04263             fprintf(&#39;%24s\t%4d\n&#39;,&#39;DSB&#39;,   sbc(this.strandBreakClassification_index_DSB));
<a name="l04264"></a>04264             fprintf(&#39;%24s\t%4d\n&#39;,&#39;DSB+&#39;,  sbc(this.strandBreakClassification_index_DSB_));
<a name="l04265"></a>04265             fprintf(&#39;%24s\t%4d\n&#39;,&#39;DSB++&#39;, sbc(this.strandBreakClassification_index_DSB__));
<a name="l04266"></a>04266             fprintf(&#39;\n&#39;);
<a name="l04267"></a>04267             
<a name="l04268"></a>04268             %list of damaged genes
<a name="l04269"></a>04269             fprintf(&#39;%13s\n&#39;,&#39;Damaged Genes&#39;);
<a name="l04270"></a>04270             fprintf(&#39;%13s\n&#39;,repmat(&#39;=&#39;,1,13));
<a name="l04271"></a>04271             damagedGeneWholeCellModelIDs = this.gene.wholeCellModelIDs(~all(this.accessibleGenes,2));
<a name="l04272"></a>04272             damagedGeneWholeCellNames    = this.gene.names(~all(this.accessibleGenes,2));
<a name="l04273"></a>04273             for i=1:length(damagedGeneWholeCellModelIDs);
<a name="l04274"></a>04274                 damagedGeneWholeCellModelID = damagedGeneWholeCellModelIDs{i};
<a name="l04275"></a>04275                 damagedGeneWholeCellName    = damagedGeneWholeCellNames{i};
<a name="l04276"></a>04276                 <span class="keywordflow">if</span> length(damagedGeneWholeCellModelID)&gt;12; damagedGeneWholeCellModelID=[damagedGeneWholeCellModelID(1:8) &#39; ...&#39;]; end;
<a name="l04277"></a>04277                 <span class="keywordflow">if</span> length(damagedGeneWholeCellName)&gt;32; damagedGeneWholeCellName=[damagedGeneWholeCellName(1:28) &#39; ...&#39;]; end;
<a name="l04278"></a>04278                 fprintf(<span class="stringliteral">&#39;%12s\t%32s\n&#39;</span>,damagedGeneWholeCellModelID,damagedGeneWholeCellName);
<a name="l04279"></a>04279             end
<a name="l04280"></a>04280             fprintf(<span class="charliteral">&#39;\n&#39;</span>);
<a name="l04281"></a>04281             
<a name="l04282"></a>04282             %list of damaged transcription units
<a name="l04283"></a>04283             fprintf(<span class="stringliteral">&#39;%27s\n&#39;</span>,<span class="stringliteral">&#39;Damaged Transcription Units&#39;</span>);
<a name="l04284"></a>04284             fprintf(<span class="stringliteral">&#39;%27s\n&#39;</span>,repmat(<span class="charliteral">&#39;=&#39;</span>,1,27));
<a name="l04285"></a>04285             damagedTranscriptionUnitWholeCellModelIDs = this.transcriptionUnitWholeCellModelIDs(~all(this.accessibleTranscriptionUnits,2));
<a name="l04286"></a>04286             damagedTranscriptionUnitWholeCellNames    = this.transcriptionUnitNames(~all(this.accessibleTranscriptionUnits,2));
<a name="l04287"></a>04287             <span class="keywordflow">for</span> i=1:length(damagedTranscriptionUnitWholeCellModelIDs);
<a name="l04288"></a>04288                 damagedTranscriptionUnitWholeCellModelID = damagedTranscriptionUnitWholeCellModelIDs{i};
<a name="l04289"></a>04289                 damagedTranscriptionUnitWholeCellName    = damagedTranscriptionUnitWholeCellNames{i};
<a name="l04290"></a>04290                 <span class="keywordflow">if</span> length(damagedTranscriptionUnitWholeCellModelID)&gt;12; damagedTranscriptionUnitWholeCellModelID=[damagedTranscriptionUnitWholeCellModelID(1:8) &#39; ...&#39;]; end;
<a name="l04291"></a>04291                 <span class="keywordflow">if</span> length(damagedTranscriptionUnitWholeCellName)&gt;32; damagedTranscriptionUnitWholeCellName=[damagedTranscriptionUnitWholeCellName(1:28) &#39; ...&#39;]; end;
<a name="l04292"></a>04292                 fprintf(<span class="stringliteral">&#39;%12s\t%32s\n&#39;</span>,damagedTranscriptionUnitWholeCellModelID,damagedTranscriptionUnitWholeCellName);
<a name="l04293"></a>04293             end
<a name="l04294"></a>04294             fprintf(<span class="charliteral">&#39;\n&#39;</span>);
<a name="l04295"></a>04295         end
<a name="l04296"></a>04296     end
<a name="l04297"></a>04297 end
</pre></div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="_09state_2_chromosome_8m.html">Chromosome.m</a>      </li>

    <li class="footer">Generated on Wed Feb 8 2012 21:42:31 for Whole Cell Simulation by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
