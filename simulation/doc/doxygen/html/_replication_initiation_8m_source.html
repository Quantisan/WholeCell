<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Whole Cell Simulation: src/+edu/+stanford/+covert/+cell/+sim/+process/ReplicationInitiation.m Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Whole Cell Simulation
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('_replication_initiation_8m.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">src/+edu/+stanford/+covert/+cell/+sim/+process/ReplicationInitiation.m</div>  </div>
</div><!--header-->
<div class="contents">
<a href="_replication_initiation_8m.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 %ReplicationInitiation
<a name="l00002"></a>00002 %
<a name="l00003"></a>00003 % @wholeCellModelID Process_ReplicationInitiation
<a name="l00004"></a>00004 % @name             ReplicationInitiation
<a name="l00005"></a>00005 % @description
<a name="l00006"></a>00006 %   Biology
<a name="l00007"></a>00007 %   =======================================
<a name="l00008"></a>00008 %   Chromosomal replication begins with the formation of large DnaA-ATP
<a name="l00009"></a>00009 %   polymers, totaling approximately 30 DnaA molecues, at several sites denoted
<a name="l00010"></a>00010 %   R1-5 near the OriC. This process simulates the binding and unbinding of
<a name="l00011"></a>00011 %   DnaA-ATP and DnaA-ADP to these and 2000 additional sites throughout the
<a name="l00012"></a>00012 %   chromosome throughout the cell cycle. Although binding occurs throughout the
<a name="l00013"></a>00013 %   cell cycle, due to the cell&#39;s limited amount of DnaA, the titration affects
<a name="l00014"></a>00014 %   of the additional 2000 sites, and the cooperativity of DnaA polymerization
<a name="l00015"></a>00015 %   at the OriC sites, DnaA complexation formation at the OriC only occurs
<a name="l00016"></a>00016 %   approximately 2/3 through the cell cycle, providing robust control of
<a name="l00017"></a>00017 %   replication initiation.
<a name="l00018"></a>00018 %
<a name="l00019"></a>00019 %   DnaA Boxes (Mycoplasma genitalium)
<a name="l00020"></a>00020 %   =======================================
<a name="l00021"></a>00021 %   All the DnaA box positions based on the M. genitalium motif described in
<a name="l00022"></a>00022 %   Cordova 2002. 
<a name="l00023"></a>00023 %   - 9mer sites (high affinity) are the exact matches of the motif (and reverse
<a name="l00024"></a>00024 %     complement). 
<a name="l00025"></a>00025 %   - 8mer sites (medium affinity) are matches of the motif (and reverse
<a name="l00026"></a>00026 %     complement) with 1 incorrect base. 
<a name="l00027"></a>00027 %
<a name="l00028"></a>00028 %   We assume that in the oriC, 5 boxes are present: one 9mer, three
<a name="l00029"></a>00029 %   8mers, and one 7mer, to mimic E. coli&#39;s R1-R4, R5. These boxes should reside
<a name="l00030"></a>00030 %   between MG_469 and MG_470 (bases: 578581-579224). There are 9 (8-9mer) boxes
<a name="l00031"></a>00031 %   in this region, but we only recognize 4, so we ignore the boxes at positions
<a name="l00032"></a>00032 %   578837, 578855, 578881, 578966, and 579139.
<a name="l00033"></a>00033 %
<a name="l00034"></a>00034 %   R5 is a 7mer, so it is a very weak binder of DnaA. Essentially it is only
<a name="l00035"></a>00035 %   bound by cooperativity given the presence of the initiator complex. Since we
<a name="l00036"></a>00036 %   do not know its exact mechanism/purpose we say it just binds after the
<a name="l00037"></a>00037 %   complex is formed, and its binding triggers initiation.
<a name="l00038"></a>00038 %
<a name="l00039"></a>00039 %   Knowledge Base
<a name="l00040"></a>00040 %   =======================================
<a name="l00041"></a>00041 %   The DnaA boxes are represented in the knowledge base as genomic features and
<a name="l00042"></a>00042 %   loaded into this class by the initializeConstants method. The knowledge base
<a name="l00043"></a>00043 %   also contains the footprint sizes of the DnaA complexes; these are used by
<a name="l00044"></a>00044 %   the chromosomes <span class="keywordtype">object</span> to determine whether DnaA complexes can bind to
<a name="l00045"></a>00045 %   specific chromosomal regions.
<a name="l00046"></a>00046 %
<a name="l00047"></a>00047 %   Representation
<a name="l00048"></a>00048 %   =======================================
<a name="l00049"></a>00049 %   The substrates, enzymes, and boundEnzymes <a class="code" href="json_parse_8m.html#a6e4256f69b751d3d7ec4ea52ff5a8dee">properties</a> represent the counts of
<a name="l00050"></a>00050 %   free metabolites, free DnaA, and DnaA bound to the chromosome. The
<a name="l00051"></a>00051 %   complexBoundSites <span class="keyword">property</span> of the chromosomes <span class="keywordtype">object</span> represent the specific
<a name="l00052"></a>00052 %   chromosomal locations of bound DnaA. The ATP/ADP bound and polymerization
<a name="l00053"></a>00053 %   status of each bound DnaA molecule is indicated by the specific identity of
<a name="l00054"></a>00054 %   the bound DnaA complex (DnaA-ATP 1-7 mer; DnaA-ADP + DnaA-ATP 0-6 mer).   
<a name="l00055"></a>00055 %
<a name="l00056"></a>00056 %   Initialization
<a name="l00057"></a>00057 %   =======================================
<a name="l00058"></a>00058 %   The process is initialized to a steady state by the initializeState method.
<a name="l00059"></a>00059 %   The steady state (amounts of free, 8mer/9mer bound DnaA-AxP) is found using
<a name="l00060"></a>00060 %   non-linear constrained optimization where we try to identify a state which
<a name="l00061"></a>00061 %   is a stable point and which maximizes the amount of 9-mer bound ATP. In the
<a name="l00062"></a>00062 %   initializeState method we make the simplifications that there is no free
<a name="l00063"></a>00063 %   DnaA (all DnaA is ATP or ADP bound) and that there are no DnaA polymers at
<a name="l00064"></a>00064 %   the functional R1-4 OriC boxes.
<a name="l00065"></a>00065 %
<a name="l00066"></a>00066 %   Simulation
<a name="l00067"></a>00067 %   =======================================
<a name="l00068"></a>00068 %   This process follows the general ideas in Atlas et al. 2008. The process
<a name="l00069"></a>00069 %   consists of several subfunctions executed in a deterministic order:
<a name="l00070"></a>00070 %   - Activate free DnaA to DnaA-ATP (activateFreeDnaA)
<a name="l00071"></a>00071 %     Deterministically form DnaA-ATP complexes upto the limit of available DnaA
<a name="l00072"></a>00072 %     monomers and ATP. The kinetics of DnaA activation are not known, and are
<a name="l00073"></a>00073 %     not modeled.
<a name="l00074"></a>00074 %   - Dissociate free DnaA-ATP polymers into monomers and hydrolyze ATPs (inactivateFreeDnaAATP)
<a name="l00075"></a>00075 %   - polymerized DnaA-ATP (polymerizeDnaAATP)
<a name="l00076"></a>00076 %     If chromosomes are supercoiled, stochastically polymerize R1-4 DnaA boxes
<a name="l00077"></a>00077 %     (which are bound by DnaA-ATP monomers/polymers (of up to length 6)) by 1
<a name="l00078"></a>00078 %     additional DnaA-ATP molecule at rate
<a name="l00079"></a>00079 %       kbATP * numFreeDnaAATP / V * C
<a name="l00080"></a>00080 %     where C is a cooperativity constant which depends on the polymerization
<a name="l00081"></a>00081 %     status of the other R1-4 boxes
<a name="l00082"></a>00082 %   - polymerized DnaA-ADP (polymerizeDnaAADP)
<a name="l00083"></a>00083 %     Similar to DnaA-ATP polymerization, but with slower kinetic rate, kbADP
<a name="l00084"></a>00084 %   - Bind DnaA-ATP (bindDnaAATP)
<a name="l00085"></a>00085 %     Stochastically bind DnaA-ATP to free DnaA boxes at rate
<a name="l00086"></a>00086 %       kbATP * numFreeDnaAATP / V
<a name="l00087"></a>00087 %   - Bind DnaA-ADP (bindDnaAADP)
<a name="l00088"></a>00088 %     Similar to DnaA-ATP binding, but with slower kinetic rate, kbADP
<a name="l00089"></a>00089 %   - Stochastically release bound DnaA-ATP with uniform probability (releaseDnaAAxP)
<a name="l00090"></a>00090 %     Stochastically release bound DnaA-ATP monomers, and stochastically
<a name="l00091"></a>00091 %     depolymerize R1-4 boxes (except those which have polymer lengths equal to
<a name="l00092"></a>00092 %     the minimum of that over the R1-4 boxes) at rate kd1ATP.
<a name="l00093"></a>00093 %   - Stochastically release bound DnaA-ADP with uniform probability (releaseDnaAAxP)
<a name="l00094"></a>00094 %     Stochastically release bound DnaA-ADP monomers, and stochastically
<a name="l00095"></a>00095 %     depolymerize R1-4 boxes at rate kd1ADP.
<a name="l00096"></a>00096 %   - Reactivate free DnaA from free DnaA-ADPs (reactivateFreeDnaAADP)
<a name="l00097"></a>00097 %     Deterministically reactivate free DnaA-ATP from free DnaA-ATP a rate
<a name="l00098"></a>00098 %        numFreeDnaAADP * (k_Regen * membraneConc) /
<a name="l00099"></a>00099 %                       (K_Regen_P4 + membraneConc)
<a name="l00100"></a>00100 %
<a name="l00101"></a>00101 %   Replication-dependent bound DnaA-ATP inactivation is modeled differently
<a name="l00102"></a>00102 %   here than by Atlas et al 2008. Atlas et, 2008 included a global term for the
<a name="l00103"></a>00103 %   effect of active beta-clamps on bound DnaA-ATP inactivation. Because this
<a name="l00104"></a>00104 %   model is evaluated as part of a larger model and in particular the exact
<a name="l00105"></a>00105 %   position of active beta-clamps are known, we are able to model the local
<a name="l00106"></a>00106 %   affects of beta-clamps on bound DnaA-ATP, which is to release the bound
<a name="l00107"></a>00107 %   protein from DNA. However, because we cannot distinguish free DnaA-ATP from
<a name="l00108"></a>00108 %   DnaA-ATP released by beta-clamps we only model the release of these proteins
<a name="l00109"></a>00109 %   from the DNA, and not their hydrolysis to DnaA-ADP.
<a name="l00110"></a>00110 %
<a name="l00111"></a>00111 %   References
<a name="l00112"></a>00112 %   =======================================
<a name="l00113"></a>00113 %   1. Atlas, J.C., Nikolaev, E.V., Browning, S.T., Shuler, M.L. (2008).
<a name="l00114"></a>00114 %      Incorporating genome-wide DNA sequence information into a dynamic
<a name="l00115"></a>00115 %      whole-cell model of E. coli: application to DNA replication. Systems
<a name="l00116"></a>00116 %      Biology, IET 2: 369-382.
<a name="l00117"></a>00117 %   2. Browning, S.T., Castellanos, M., Shuler, M.L. (2004). Robust control of
<a name="l00118"></a>00118 %      Initiation of prokaryotic chromosome replication: essential considerations
<a name="l00119"></a>00119 %      for a minimal cell. Biotechnology and Bioengineering 88: 575-584.
<a name="l00120"></a>00120 %      All rate constants are from Browning (2004).
<a name="l00121"></a>00121 %   3. Cordova, C.M.M., Lartigue, C., Sirand-Pugnet, P., Renaudin, J., Cunha,
<a name="l00122"></a>00122 %      R.A.F., Blanchard, A. (2002). Identification of the origin of replication
<a name="l00123"></a>00123 %      of the Mycoplasma pulmonis chromosome and its use in oriC replicative
<a name="l00124"></a>00124 %      plasmids. Journal of Bacteriology 184: 5426-5435.
<a name="l00125"></a>00125 %   4. Margulies, C., Kaguni, J.M. (1996). Ordered and sequential binding of DnaA
<a name="l00126"></a>00126 %      protein to oriC, the chromosomal origin of escherichia coli. Journal of
<a name="l00127"></a>00127 %      biological chemistry 271: 17035-17040.
<a name="l00128"></a>00128 %
<a name="l00129"></a>00129 % Author: Jayodita Sanghvi, jayodita@stanford.edu
<a name="l00130"></a>00130 % Author: Jonathan Karr, jkarr@stanford.edu
<a name="l00131"></a>00131 % Author: Jared Jacobs, jmjacobs@stanford.edu
<a name="l00132"></a>00132 % Affilitation: Covert Lab, Department of Bioengineering, Stanford University
<a name="l00133"></a>00133 % Last updated: 8/10/2010
<a name="l00134"></a>00134 classdef ReplicationInitiation &lt; edu.stanford.covert.cell.sim.Process &amp; edu.stanford.covert.cell.sim.ChromosomeProcessAspect
<a name="l00135"></a>00135     %property annotations
<a name="l00136"></a>00136     properties (Constant)
<a name="l00137"></a>00137         optionNames__              = {}; %names of option <a class="code" href="json_parse_8m.html#a6e4256f69b751d3d7ec4ea52ff5a8dee">properties</a>
<a name="l00138"></a>00138         fixedConstantNames__       = {   %names of fixed constant <a class="code" href="json_parse_8m.html#a6e4256f69b751d3d7ec4ea52ff5a8dee">properties</a>
<a name="l00139"></a>00139                     <span class="stringliteral">&#39;dnaABoxStartPositions&#39;</span>;
<a name="l00140"></a>00140             <span class="stringliteral">&#39;siteCooperativity&#39;</span>;
<a name="l00141"></a>00141             <span class="stringliteral">&#39;stateCooperativity&#39;</span>;
<a name="l00142"></a>00142             <span class="stringliteral">&#39;kb1ATP&#39;</span>;
<a name="l00143"></a>00143             <span class="stringliteral">&#39;kb2ATP&#39;</span>;
<a name="l00144"></a>00144             <span class="stringliteral">&#39;kd1ATP&#39;</span>;
<a name="l00145"></a>00145             <span class="stringliteral">&#39;kb1ADP&#39;</span>;
<a name="l00146"></a>00146             <span class="stringliteral">&#39;kb2ADP&#39;</span>;
<a name="l00147"></a>00147             <span class="stringliteral">&#39;kd1ADP&#39;</span>;
<a name="l00148"></a>00148             <span class="stringliteral">&#39;k_Regen&#39;</span>;
<a name="l00149"></a>00149             <span class="stringliteral">&#39;K_Regen_P4&#39;</span>;
<a name="l00150"></a>00150             <span class="stringliteral">&#39;k_inact&#39;</span>;
<a name="l00151"></a>00151                     };
<a name="l00152"></a>00152         fittedConstantNames__      = {}; %names of fitted constant <a class="code" href="json_parse_8m.html#a6e4256f69b751d3d7ec4ea52ff5a8dee">properties</a>
<a name="l00153"></a>00153         localStateNames__          = {}; %names of simulation state <a class="code" href="json_parse_8m.html#a6e4256f69b751d3d7ec4ea52ff5a8dee">properties</a> redundant with timecourses in <span class="keyword">this</span> or other processes or the simulation
<a name="l00154"></a>00154     end
<a name="l00155"></a>00155 
<a name="l00156"></a>00156     %enumerations
<a name="l00157"></a>00157     <a class="code" href="json_parse_8m.html#a6e4256f69b751d3d7ec4ea52ff5a8dee">properties</a> (Constant)
<a name="l00158"></a>00158         dnaABoxStatus_NotExist     = -1; %site on the second chromosome that has not yet been replicated
<a name="l00159"></a>00159         dnaABoxStatus_NotBound     =  0; %site not bound by DnaA-ATP or DnaA-ADP
<a name="l00160"></a>00160         dnaABoxStatus_DnaAATPBound =  1; %site bound by DnaA-ATP
<a name="l00161"></a>00161         dnaABoxStatus_DnaAADPBound =  2; %site bound by DnaA-ADP
<a name="l00162"></a>00162     end
<a name="l00163"></a>00163 
<a name="l00164"></a>00164     %IDs, names, and local indices
<a name="l00165"></a>00165     <a class="code" href="json_parse_8m.html#a6e4256f69b751d3d7ec4ea52ff5a8dee">properties</a>
<a name="l00166"></a>00166         stimuliWholeCellModelIDs = {}; %whole cell model IDs of stimuli
<a name="l00167"></a>00167         
<a name="l00168"></a>00168         substrateWholeCellModelIDs = { %whole cell model IDs of substrates
<a name="l00169"></a>00169             <span class="stringliteral">&#39;ATP&#39;</span>;<span class="stringliteral">&#39;ADP&#39;</span>;<span class="stringliteral">&#39;PI&#39;</span>;<span class="stringliteral">&#39;H2O&#39;</span>;<span class="charliteral">&#39;H&#39;</span>};
<a name="l00170"></a>00170         substrateIndexs_atp        = 1;
<a name="l00171"></a>00171         substrateIndexs_adp        = 2;
<a name="l00172"></a>00172         substrateIndexs_phosphate  = 3;
<a name="l00173"></a>00173         substrateIndexs_water      = 4;
<a name="l00174"></a>00174         substrateIndexs_hydrogen   = 5;
<a name="l00175"></a>00175         
<a name="l00176"></a>00176         enzymeWholeCellModelIDs = {    %whole cell model IDs of enzymes
<a name="l00177"></a>00177             <span class="stringliteral">&#39;MG_469_1MER_ADP&#39;</span>      %DnaA-ADP 1mer
<a name="l00178"></a>00178             &#39;MG_469_1MER_ATP&#39;      %DnaA-ATP 1mer
<a name="l00179"></a>00179             &#39;MG_469_2MER_1ATP_ADP&#39; %DnaA 2mer-(1)ATP-(1)ADP
<a name="l00180"></a>00180             &#39;MG_469_2MER_ATP&#39;      %DnaA-ATP 2mer
<a name="l00181"></a>00181             &#39;MG_469_3MER_2ATP_ADP&#39; %DnaA 3mer-(2)ATP-(1)ADP
<a name="l00182"></a>00182             &#39;MG_469_3MER_ATP&#39;      %DnaA-ATP 3mer
<a name="l00183"></a>00183             &#39;MG_469_4MER_3ATP_ADP&#39; %DnaA 4mer-(3)ATP-(1)ADP
<a name="l00184"></a>00184             &#39;MG_469_4MER_ATP&#39;      %DnaA-ATP 4mer
<a name="l00185"></a>00185             &#39;MG_469_5MER_4ATP_ADP&#39; %DnaA 5mer-(4)ATP-(1)ADP
<a name="l00186"></a>00186             &#39;MG_469_5MER_ATP&#39;      %DnaA-ATP 5mer
<a name="l00187"></a>00187             &#39;MG_469_6MER_5ATP_ADP&#39; %DnaA 6mer-(5)ATP-(1)ADP
<a name="l00188"></a>00188             &#39;MG_469_6MER_ATP&#39;      %DnaA-ATP 6mer
<a name="l00189"></a>00189             &#39;MG_469_7MER_6ATP_ADP&#39; %DnaA 7mer-(6)ATP-(1)ADP
<a name="l00190"></a>00190             &#39;MG_469_7MER_ATP&#39;      %DnaA-ATP 7mer
<a name="l00191"></a>00191             &#39;MG_469_MONOMER&#39;       %chromosomal replication initiator protein DnaA
<a name="l00192"></a>00192             };
<a name="l00193"></a>00193         enzymeIndexs_DnaA             = 15;
<a name="l00194"></a>00194         enzymeIndexs_DnaA_1mer_ADP    = 1;
<a name="l00195"></a>00195         enzymeIndexs_DnaA_1mer_ATP    = 2;
<a name="l00196"></a>00196         enzymeIndexs_DnaA_Nmer_ATP    = (2:2:14)<span class="stringliteral">&#39;;</span>
<a name="l00197"></a>00197 <span class="stringliteral">        enzymeIndexs_DnaA_Nmer_ADP    = (1:2:13)&#39;</span>;
<a name="l00198"></a>00198         enzymeIndexs_DnaA_polymer_ATP = (4:2:14)<span class="stringliteral">&#39;;</span>
<a name="l00199"></a>00199 <span class="stringliteral">        enzymeIndexs_DnaA_polymer_ADP = (3:2:13)&#39;</span>;
<a name="l00200"></a>00200         
<a name="l00201"></a>00201         dnaABoxIndexs_7mer   %indices of 7mer binding sites within dnaABindingSites
<a name="l00202"></a>00202         dnaABoxIndexs_8mer   %indices of 8mer binding sites within dnaABindingSites
<a name="l00203"></a>00203         dnaABoxIndexs_9mer   %indices of 9mer binding sites within dnaABindingSites
<a name="l00204"></a>00204         dnaABoxIndexs_R12345 %indices of R1-5 functional binding sites within dnaABindingSites
<a name="l00205"></a>00205         dnaABoxIndexs_R1234  %indices of R1-4 functional binding sites within dnaABindingSites
<a name="l00206"></a>00206         dnaABoxIndexs_R5     %indices of R5 functional binding sites within dnaABindingSites
<a name="l00207"></a>00207     end
<a name="l00208"></a>00208 
<a name="l00209"></a>00209     %fixed biological constants
<a name="l00210"></a>00210     <a class="code" href="json_parse_8m.html#a6e4256f69b751d3d7ec4ea52ff5a8dee">properties</a>
<a name="l00211"></a>00211         dnaABoxStartPositions%positions of all DnaA binding sites on chromosome
<a name="l00212"></a>00212         
<a name="l00213"></a>00213         siteCooperativity    %factor by which DnaAATP to oriC site binding probability increases when other sites are bound (70)
<a name="l00214"></a>00214         stateCooperativity   %factor by which DnaAATP to oriC site binding probability increases when x*4 sized DnaA complex has formed at oriC (20)
<a name="l00215"></a>00215         
<a name="l00216"></a>00216         kb1ATP               %rate for DnaA-ATP binding high affinity DnaA boxes (25 nM/h) --ASSUME THESE ARE ACTUALLY 1/(nM*h) %Browning (2004)[PUB_0448]
<a name="l00217"></a>00217         kb2ATP               %rate for DnaA-ATP binding medium affinity DnaA boxes (0.6 nM/h) --ASSUME THESE ARE ACTUALLY 1/(nM*h) %Browning (2004)[PUB_0448]
<a name="l00218"></a>00218         kd1ATP               %rate for DnaA-ATP dissociating from dna (20 1/h) %Browning (2004)[PUB_0448]
<a name="l00219"></a>00219         kb1ADP               %rate for DnaA-ADP binding high affinity DnaA boxes (2.5 nM/h) --ASSUME THESE ARE ACTUALLY 1/(nM*h) %Browning (2004)[PUB_0448]
<a name="l00220"></a>00220         kb2ADP               %rate for DnaA-ADP binding medium affinity DnaA boxes (0.61 nM/h) --ASSUME THESE ARE ACTUALLY 1/(nM*h) %Browning (2004)[PUB_0448]
<a name="l00221"></a>00221         kd1ADP               %rate for DnaA-ADP dissociating from dna (20 1/h) %Browning (2004)[PUB_0448]
<a name="l00222"></a>00222         k_Regen              %rate for DnaA-ADP to DnaA-ATP regeneration (2.3026 1/h)
<a name="l00223"></a>00223         K_Regen_P4           %rate for DnaA-ADP to DnaA-ATP regeneration catalyzed by membrane lipids (0.018 g/L) (Atlas 2008 xml file)[PUB_0447]
<a name="l00224"></a>00224         k_inact              %rate for DnaA-ATP to DnaA-ADP inactivation (4.24e14 1/s) (Browning 2004) %units unknown, likely 1/g [PUB_0448]
<a name="l00225"></a>00225         
<a name="l00226"></a>00226         dnaARelease_remainingDnaAIndexs %local indices of DnaA-AxP complexes remaining after bound DnaA-AxP complex release
<a name="l00227"></a>00227         dnaARelease_remainingDnaAMatrix %DnaA-AxP complexes remaining after bound DnaA-AxP complex release [remaining X bound]
<a name="l00228"></a>00228         dnaARelease_releasedDnaAIndexs  %local indices of DnaA-AxP complexes released by DnaA-AxP complex release
<a name="l00229"></a>00229         dnaARelease_releasedDnaAMatrix  %DnaA-AxP complexes released by bound DnaA-AxP complex release [released X bound]
<a name="l00230"></a>00230     end
<a name="l00231"></a>00231     
<a name="l00232"></a>00232     %state references
<a name="l00233"></a>00233     <a class="code" href="json_parse_8m.html#a6e4256f69b751d3d7ec4ea52ff5a8dee">properties</a>
<a name="l00234"></a>00234         mass
<a name="l00235"></a>00235     end
<a name="l00236"></a>00236 
<a name="l00237"></a>00237     methods
<a name="l00238"></a>00238         %constructor
<a name="l00239"></a>00239         function this = ReplicationInitiation(wholeCellModelID, name)
<a name="l00240"></a>00240             this = this@edu.stanford.covert.cell.sim.<a class="code" href="class_process.html">Process</a>(wholeCellModelID, name);
<a name="l00241"></a>00241         end
<a name="l00242"></a>00242     end
<a name="l00243"></a>00243 
<a name="l00244"></a>00244     %communication between process/simulation
<a name="l00245"></a>00245     methods
<a name="l00246"></a>00246         <span class="keyword">function</span> storeObjectReferences(<span class="keyword">this</span>, simulation)
<a name="l00247"></a>00247             this.storeObjectReferences@edu.stanford.covert.cell.sim.<a class="code" href="class_process.html">Process</a>(simulation);
<a name="l00248"></a>00248             this.storeObjectReferences@edu.stanford.covert.cell.sim.<a class="code" href="class_chromosome_process_aspect.html">ChromosomeProcessAspect</a>(simulation);
<a name="l00249"></a>00249             
<a name="l00250"></a>00250             this.mass = simulation.state(&#39;Mass&#39;);
<a name="l00251"></a>00251             this.states = [this.states; {this.mass}];
<a name="l00252"></a>00252         end
<a name="l00253"></a>00253         
<a name="l00254"></a>00254         %initialize constants
<a name="l00255"></a>00255         <span class="keyword">function</span> initializeConstants(<span class="keyword">this</span>, knowledgeBase, simulation, varargin)
<a name="l00256"></a>00256             this.initializeConstants@edu.stanford.covert.cell.sim.<a class="code" href="class_process.html">Process</a>(...
<a name="l00257"></a>00257                 knowledgeBase, simulation, varargin{:});
<a name="l00258"></a>00258             this.initializeConstants@edu.stanford.covert.cell.sim.ChromosomeProcessAspect(...
<a name="l00259"></a>00259                 knowledgeBase, simulation, varargin{:});
<a name="l00260"></a>00260             
<a name="l00261"></a>00261             %DnaA binding sites
<a name="l00262"></a>00262             dnaABoxes = findobj(knowledgeBase.genomeFeatures, <span class="stringliteral">&#39;type&#39;</span>, <span class="stringliteral">&#39;DnaA box&#39;</span>);
<a name="l00263"></a>00263             dnaABoxSubtypes = {dnaABoxes.subtype}<span class="stringliteral">&#39;;</span>
<a name="l00264"></a>00264 <span class="stringliteral">            dnaABoxNames = {dnaABoxes.name}&#39;</span>;
<a name="l00265"></a>00265             
<a name="l00266"></a>00266             this.dnaABoxStartPositions = ...
<a name="l00267"></a>00267                 ceil([dnaABoxes.startCoordinate]<span class="stringliteral">&#39; + [dnaABoxes.sequenceLength]&#39;</span>/2 - <span class="keyword">this</span>.enzymeDNAFootprints(<span class="keyword">this</span>.enzymeIndexs_DnaA_1mer_ATP)/2);
<a name="l00268"></a>00268             
<a name="l00269"></a>00269             this.dnaABoxIndexs_7mer = find(strcmp(dnaABoxSubtypes, <span class="stringliteral">&#39;7mer&#39;</span>));
<a name="l00270"></a>00270             this.dnaABoxIndexs_8mer = find(strcmp(dnaABoxSubtypes, <span class="stringliteral">&#39;8mer&#39;</span>));
<a name="l00271"></a>00271             this.dnaABoxIndexs_9mer = find(strcmp(dnaABoxSubtypes, <span class="stringliteral">&#39;9mer&#39;</span>));
<a name="l00272"></a>00272             
<a name="l00273"></a>00273             [~, this.dnaABoxIndexs_R12345] = ismember({
<a name="l00274"></a>00274                 <span class="stringliteral">&#39;Functional box R1&#39;</span>;
<a name="l00275"></a>00275                 <span class="stringliteral">&#39;Functional box R2&#39;</span>;
<a name="l00276"></a>00276                 <span class="stringliteral">&#39;Functional box R3&#39;</span>;
<a name="l00277"></a>00277                 <span class="stringliteral">&#39;Functional box R4&#39;</span>;
<a name="l00278"></a>00278                 <span class="stringliteral">&#39;Functional box R5&#39;</span>;
<a name="l00279"></a>00279                 }, dnaABoxNames);
<a name="l00280"></a>00280             this.dnaABoxIndexs_R1234 = this.dnaABoxIndexs_R12345(1:4);
<a name="l00281"></a>00281             this.dnaABoxIndexs_R5 = this.dnaABoxIndexs_R12345(5);
<a name="l00282"></a>00282             
<a name="l00283"></a>00283             %DnaA-AxP release reactions
<a name="l00284"></a>00284             this.calcDnaAxpReleaseReactions();
<a name="l00285"></a>00285         end
<a name="l00286"></a>00286         
<a name="l00287"></a>00287         <span class="keyword">function</span> sampleDnaABoxes(<span class="keyword">this</span>, nBoxes)
<a name="l00288"></a>00288             validateattributes(nBoxes, {<span class="stringliteral">&#39;numeric&#39;</span>}, {...
<a name="l00289"></a>00289                 <span class="stringliteral">&#39;integer&#39;</span>, ...
<a name="l00290"></a>00290                 <span class="stringliteral">&#39;&gt;=&#39;</span>, numel(this.dnaABoxIndexs_R12345), ...
<a name="l00291"></a>00291                 <span class="stringliteral">&#39;&lt;=&#39;</span>, numel(this.dnaABoxStartPositions)});
<a name="l00292"></a>00292             
<a name="l00293"></a>00293             idxs = sort([this.randStream.randomlySelectNRows(...
<a name="l00294"></a>00294                 setdiff((1:numel(this.dnaABoxStartPositions))<span class="stringliteral">&#39;, this.dnaABoxIndexs_R12345), ...</span>
<a name="l00295"></a>00295 <span class="stringliteral">                nBoxes - numel(this.dnaABoxIndexs_R12345))</span>
<a name="l00296"></a>00296 <span class="stringliteral">                this.dnaABoxIndexs_R12345]);</span>
<a name="l00297"></a>00297 <span class="stringliteral">            </span>
<a name="l00298"></a>00298 <span class="stringliteral">            this.dnaABoxStartPositions(idxs);</span>
<a name="l00299"></a>00299 <span class="stringliteral">            </span>
<a name="l00300"></a>00300 <span class="stringliteral">            [tfs, tmpIdxs] = ismember(this.dnaABoxIndexs_7mer, idxs);</span>
<a name="l00301"></a>00301 <span class="stringliteral">            this.dnaABoxIndexs_7mer = tmpIdxs(tfs);            </span>
<a name="l00302"></a>00302 <span class="stringliteral">            [tfs, tmpIdxs] = ismember(this.dnaABoxIndexs_8mer, idxs);</span>
<a name="l00303"></a>00303 <span class="stringliteral">            this.dnaABoxIndexs_8mer = tmpIdxs(tfs);            </span>
<a name="l00304"></a>00304 <span class="stringliteral">            [tfs, tmpIdxs] = ismember(this.dnaABoxIndexs_9mer, idxs);</span>
<a name="l00305"></a>00305 <span class="stringliteral">            this.dnaABoxIndexs_9mer = tmpIdxs(tfs);</span>
<a name="l00306"></a>00306 <span class="stringliteral">            [tfs, tmpIdxs] = ismember(this.dnaABoxIndexs_R12345, idxs);</span>
<a name="l00307"></a>00307 <span class="stringliteral">            this.dnaABoxIndexs_R12345 = tmpIdxs(tfs);</span>
<a name="l00308"></a>00308 <span class="stringliteral">            [tfs, tmpIdxs] = ismember(this.dnaABoxIndexs_R1234, idxs);</span>
<a name="l00309"></a>00309 <span class="stringliteral">            this.dnaABoxIndexs_R1234 = tmpIdxs(tfs);</span>
<a name="l00310"></a>00310 <span class="stringliteral">            [tfs, tmpIdxs] = ismember(this.dnaABoxIndexs_R5, idxs);</span>
<a name="l00311"></a>00311 <span class="stringliteral">            this.dnaABoxIndexs_R5 = tmpIdxs(tfs);</span>
<a name="l00312"></a>00312 <span class="stringliteral">        end</span>
<a name="l00313"></a>00313 <span class="stringliteral">        </span>
<a name="l00314"></a>00314 <span class="stringliteral">        function calcDnaAxpReleaseReactions(this)</span>
<a name="l00315"></a>00315 <span class="stringliteral">            this.dnaARelease_remainingDnaAIndexs = zeros(size(this.enzymeComplexGlobalIndexs));</span>
<a name="l00316"></a>00316 <span class="stringliteral">            this.dnaARelease_remainingDnaAIndexs(this.enzymeIndexs_DnaA_1mer_ATP) = 0;</span>
<a name="l00317"></a>00317 <span class="stringliteral">            this.dnaARelease_remainingDnaAIndexs(this.enzymeIndexs_DnaA_1mer_ADP) = 0;</span>
<a name="l00318"></a>00318 <span class="stringliteral">            this.dnaARelease_remainingDnaAIndexs(this.enzymeIndexs_DnaA_Nmer_ATP(2:end)) = this.enzymeIndexs_DnaA_Nmer_ATP(1:end-1);</span>
<a name="l00319"></a>00319 <span class="stringliteral">            this.dnaARelease_remainingDnaAIndexs(this.enzymeIndexs_DnaA_Nmer_ADP(2:end)) = this.enzymeIndexs_DnaA_Nmer_ATP(1:end-1);</span>
<a name="l00320"></a>00320 <span class="stringliteral">            </span>
<a name="l00321"></a>00321 <span class="stringliteral">            this.dnaARelease_remainingDnaAMatrix = zeros(numel(this.enzymeWholeCellModelIDs)); %remaining bound X original bound</span>
<a name="l00322"></a>00322 <span class="stringliteral">            this.dnaARelease_remainingDnaAMatrix(sub2ind(size(this.dnaARelease_remainingDnaAMatrix), this.enzymeIndexs_DnaA_Nmer_ATP(1:end-1), this.enzymeIndexs_DnaA_Nmer_ATP(2:end))) = 1;</span>
<a name="l00323"></a>00323 <span class="stringliteral">            this.dnaARelease_remainingDnaAMatrix(sub2ind(size(this.dnaARelease_remainingDnaAMatrix), this.enzymeIndexs_DnaA_Nmer_ATP(1:end-1), this.enzymeIndexs_DnaA_Nmer_ADP(2:end))) = 1;</span>
<a name="l00324"></a>00324 <span class="stringliteral">            </span>
<a name="l00325"></a>00325 <span class="stringliteral">            this.dnaARelease_releasedDnaAIndexs = zeros(size(this.enzymeComplexGlobalIndexs));</span>
<a name="l00326"></a>00326 <span class="stringliteral">            this.dnaARelease_releasedDnaAIndexs(this.enzymeIndexs_DnaA_1mer_ATP) = this.enzymeIndexs_DnaA_1mer_ATP;</span>
<a name="l00327"></a>00327 <span class="stringliteral">            this.dnaARelease_releasedDnaAIndexs(this.enzymeIndexs_DnaA_1mer_ADP) = this.enzymeIndexs_DnaA_1mer_ADP;</span>
<a name="l00328"></a>00328 <span class="stringliteral">            this.dnaARelease_releasedDnaAIndexs(this.enzymeIndexs_DnaA_Nmer_ATP(2:end)) = this.enzymeIndexs_DnaA_1mer_ATP;</span>
<a name="l00329"></a>00329 <span class="stringliteral">            this.dnaARelease_releasedDnaAIndexs(this.enzymeIndexs_DnaA_Nmer_ADP(2:end)) = this.enzymeIndexs_DnaA_1mer_ADP;</span>
<a name="l00330"></a>00330 <span class="stringliteral">            </span>
<a name="l00331"></a>00331 <span class="stringliteral">            this.dnaARelease_releasedDnaAMatrix = zeros(numel(this.enzymeWholeCellModelIDs)); %released X original bound</span>
<a name="l00332"></a>00332 <span class="stringliteral">            this.dnaARelease_releasedDnaAMatrix(this.enzymeIndexs_DnaA_1mer_ATP, this.enzymeIndexs_DnaA_1mer_ATP) = 1;</span>
<a name="l00333"></a>00333 <span class="stringliteral">            this.dnaARelease_releasedDnaAMatrix(this.enzymeIndexs_DnaA_1mer_ADP, this.enzymeIndexs_DnaA_1mer_ADP) = 1;</span>
<a name="l00334"></a>00334 <span class="stringliteral">            this.dnaARelease_releasedDnaAMatrix(this.enzymeIndexs_DnaA_1mer_ATP, this.enzymeIndexs_DnaA_Nmer_ATP(2:end)) = 1;</span>
<a name="l00335"></a>00335 <span class="stringliteral">            this.dnaARelease_releasedDnaAMatrix(this.enzymeIndexs_DnaA_1mer_ADP, this.enzymeIndexs_DnaA_Nmer_ADP(2:end)) = 1;</span>
<a name="l00336"></a>00336 <span class="stringliteral">        end</span>
<a name="l00337"></a>00337 <span class="stringliteral">    end</span>
<a name="l00338"></a>00338 <span class="stringliteral"></span>
<a name="l00339"></a>00339 <span class="stringliteral">    %model</span>
<a name="l00340"></a>00340 <span class="stringliteral">    methods</span>
<a name="l00341"></a>00341 <span class="stringliteral">        %Calculate</span>
<a name="l00342"></a>00342 <span class="stringliteral">        %- contribution to FBA objective</span>
<a name="l00343"></a>00343 <span class="stringliteral">        %- minimum expression consistent with cell cycle length</span>
<a name="l00344"></a>00344 <span class="stringliteral">        function [bmProd, byProd, minEnzExp, maxEnzExp] = calcResourceRequirements_LifeCycle(this, ~, states)</span>
<a name="l00345"></a>00345 <span class="stringliteral">            %substrate and byproducts</span>
<a name="l00346"></a>00346 <span class="stringliteral">            bmProd = zeros(size(this.substrateWholeCellModelIDs));</span>
<a name="l00347"></a>00347 <span class="stringliteral">            byProd = zeros(size(this.substrateWholeCellModelIDs));</span>
<a name="l00348"></a>00348 <span class="stringliteral">            </span>
<a name="l00349"></a>00349 <span class="stringliteral">            nATPInc = (1:7) * states.complexProductions(this.enzymeGlobalIndexs(this.enzymeIndexs_DnaA_Nmer_ATP)); %activated newly produced DnaA</span>
<a name="l00350"></a>00350 <span class="stringliteral">            nADPInc = (1:7) * states.complexProductions(this.enzymeGlobalIndexs(this.enzymeIndexs_DnaA_Nmer_ADP)); %activated newly produced DnaA</span>
<a name="l00351"></a>00351 <span class="stringliteral">            nATPHyd = 4 * numel(this.enzymeIndexs_DnaA_Nmer_ATP);                                                  %regenerate polymerized DnaA-ADP released by replisome from OriC DnaA boxes (Note: the model makes the simplification that only polymerized DnaA-ATP is deactivated)</span>
<a name="l00352"></a>00352 <span class="stringliteral">            bmProd(this.substrateIndexs_atp)       = nATPHyd + nATPInc;</span>
<a name="l00353"></a>00353 <span class="stringliteral">            bmProd(this.substrateIndexs_water)     = nATPHyd;</span>
<a name="l00354"></a>00354 <span class="stringliteral">            byProd(this.substrateIndexs_adp)       = nATPHyd - nADPInc;</span>
<a name="l00355"></a>00355 <span class="stringliteral">            byProd(this.substrateIndexs_phosphate) = nATPHyd;</span>
<a name="l00356"></a>00356 <span class="stringliteral">            byProd(this.substrateIndexs_hydrogen)  = nATPHyd;</span>
<a name="l00357"></a>00357 <span class="stringliteral">            </span>
<a name="l00358"></a>00358 <span class="stringliteral">            %current level of enzymes, so that parameters don&#39;</span>t need to be refit
<a name="l00359"></a>00359             %to be consistent with replication initiation duration
<a name="l00360"></a>00360             minEnzExp = this.enzymes;
<a name="l00361"></a>00361             maxEnzExp = Inf(size(this.enzymeWholeCellModelIDs));
<a name="l00362"></a>00362         end
<a name="l00363"></a>00363         
<a name="l00364"></a>00364         %initialization
<a name="l00365"></a>00365         <span class="keyword">function</span> initializeState(<span class="keyword">this</span>)
<a name="l00366"></a>00366             import edu.stanford.covert.util.<a class="code" href="class_computation_util.html">ComputationUtil</a>;
<a name="l00367"></a>00367             
<a name="l00368"></a>00368             %break down any DnaA-AxP
<a name="l00369"></a>00369             this.enzymes(this.enzymeIndexs_DnaA_Nmer_ATP) = this.enzymes(this.enzymeIndexs_DnaA_Nmer_ATP) + this.boundEnzymes(this.enzymeIndexs_DnaA_Nmer_ATP);
<a name="l00370"></a>00370             this.enzymes(this.enzymeIndexs_DnaA_Nmer_ADP) = this.enzymes(this.enzymeIndexs_DnaA_Nmer_ADP) + this.boundEnzymes(this.enzymeIndexs_DnaA_Nmer_ADP);
<a name="l00371"></a>00371             this.boundEnzymes(this.enzymeIndexs_DnaA_Nmer_ATP) = 0;
<a name="l00372"></a>00372             this.boundEnzymes(this.enzymeIndexs_DnaA_Nmer_ADP) = 0;
<a name="l00373"></a>00373             this.substrates(this.substrateIndexs_atp) = ...
<a name="l00374"></a>00374                 + this.substrates(this.substrateIndexs_atp) ...
<a name="l00375"></a>00375                 + (1:7) * this.enzymes(this.enzymeIndexs_DnaA_Nmer_ATP);
<a name="l00376"></a>00376             this.substrates(this.substrateIndexs_adp) = ...
<a name="l00377"></a>00377                 + this.substrates(this.substrateIndexs_adp) ...
<a name="l00378"></a>00378                 + (1:7) * this.enzymes(this.enzymeIndexs_DnaA_Nmer_ADP);
<a name="l00379"></a>00379             this.enzymes(this.enzymeIndexs_DnaA) = ...
<a name="l00380"></a>00380                 + this.enzymes(this.enzymeIndexs_DnaA) ...
<a name="l00381"></a>00381                 + (1:7) * this.enzymes(this.enzymeIndexs_DnaA_Nmer_ATP) ...
<a name="l00382"></a>00382                 + (1:7) * this.enzymes(this.enzymeIndexs_DnaA_Nmer_ADP);
<a name="l00383"></a>00383             this.enzymes(this.enzymeIndexs_DnaA_Nmer_ATP) = 0;
<a name="l00384"></a>00384             this.enzymes(this.enzymeIndexs_DnaA_Nmer_ADP) = 0;                        
<a name="l00385"></a>00385             
<a name="l00386"></a>00386             %compute steady state
<a name="l00387"></a>00387             DnaA_total = this.enzymes(this.enzymeIndexs_DnaA);
<a name="l00388"></a>00388             x0 = [
<a name="l00389"></a>00389                 DnaA_total; %free DnaA-ATP
<a name="l00390"></a>00390                 0;          %9mer DnaA-ATP
<a name="l00391"></a>00391                 0];         %8mer DnaA-ATP
<a name="l00392"></a>00392             if any(x0)
<a name="l00393"></a>00393                 x = this.initializeState_cubicRoot(x0);
<a name="l00394"></a>00394             else
<a name="l00395"></a>00395                 x = x0;
<a name="l00396"></a>00396             end
<a name="l00397"></a>00397             
<a name="l00398"></a>00398             %round to nearest integer-value solution
<a name="l00399"></a>00399             x(2) = ComputationUtil.roundHalfUp(x(2)); 
<a name="l00400"></a>00400             x(3) = ComputationUtil.roundHalfDown(x(3));
<a name="l00401"></a>00401             x(3) = floor(x(3)) + (rem(x(3),1) &gt;  0.5); %round half down
<a name="l00402"></a>00402             x(1) = DnaA_total - sum(x(2:end));
<a name="l00403"></a>00403             if any(x &lt; 0)
<a name="l00404"></a>00404                 throw(MException(&#39;ReplicationInitiation:error&#39;, &#39;all values must be positive&#39;));
<a name="l00405"></a>00405             end            
<a name="l00406"></a>00406             DnaA_ATP_total = sum(x([1 2 3]));
<a name="l00407"></a>00407             DnaA_ADP_total = 0;
<a name="l00408"></a>00408             
<a name="l00409"></a>00409             %update DnaA
<a name="l00410"></a>00410             this.enzymes(this.enzymeIndexs_DnaA) =  DnaA_total - DnaA_ATP_total - DnaA_ADP_total;
<a name="l00411"></a>00411             this.enzymes(this.enzymeIndexs_DnaA_1mer_ATP) = DnaA_ATP_total;
<a name="l00412"></a>00412             this.enzymes(this.enzymeIndexs_DnaA_1mer_ADP) = DnaA_ADP_total;
<a name="l00413"></a>00413             
<a name="l00414"></a>00414             %bind DnaA to chromosome
<a name="l00415"></a>00415             positionsStrands_9mer = [this.dnaABoxStartPositions(this.dnaABoxIndexs_9mer) ones(size(this.dnaABoxIndexs_9mer))];
<a name="l00416"></a>00416             positionsStrands_8mer = [this.dnaABoxStartPositions(this.dnaABoxIndexs_8mer) ones(size(this.dnaABoxIndexs_8mer))];
<a name="l00417"></a>00417             tfs9 = this.bindProteinToChromosome(positionsStrands_9mer, this.enzymeIndexs_DnaA_1mer_ATP, x(2), [], true, false, 1, false, [], true);
<a name="l00418"></a>00418             tfs8 = this.bindProteinToChromosome(positionsStrands_8mer, this.enzymeIndexs_DnaA_1mer_ATP, x(3), [], true, false, 1, false, [], true);
<a name="l00419"></a>00419             if sum(tfs9) ~= x(2) || sum(tfs8) ~= x(3)
<a name="l00420"></a>00420                 throw(MException(&#39;ReplicationInitiation:error&#39;, &#39;DnaA-ATP should be bound to 8- and 9-mer sites&#39;));
<a name="l00421"></a>00421             end
<a name="l00422"></a>00422             
<a name="l00423"></a>00423             this.bindProteinToChromosome(positionsStrands_9mer(~tfs9, :), this.enzymeIndexs_DnaA_1mer_ADP, 0, true, false, 1, false, [], true);
<a name="l00424"></a>00424             this.bindProteinToChromosome(positionsStrands_8mer(~tfs8, :), this.enzymeIndexs_DnaA_1mer_ADP, 0, true, false, 1, false, [], true);
<a name="l00425"></a>00425         end
<a name="l00426"></a>00426         
<a name="l00427"></a>00427         function x = initializeState_cubicRoot(this, x)            
<a name="l00428"></a>00428             Navo = edu.stanford.covert.util.<a class="code" href="class_constant_util.html">ConstantUtil</a>.nAvogadro;
<a name="l00429"></a>00429             V = this.geometry.volume;
<a name="l00430"></a>00430             
<a name="l00431"></a>00431             k8 = this.kb2ATP * 1e9 / 3600 / Navo / V;
<a name="l00432"></a>00432             k9 = this.kb1ATP * 1e9 / 3600 / Navo / V;
<a name="l00433"></a>00433             kd = this.kd1ATP / 3600;
<a name="l00434"></a>00434             N8 = numel(this.dnaABoxIndexs_8mer);
<a name="l00435"></a>00435             N9 = numel(this.dnaABoxIndexs_9mer);
<a name="l00436"></a>00436             
<a name="l00437"></a>00437             Xt = sum(x);
<a name="l00438"></a>00438                         
<a name="l00439"></a>00439             a = -k8*k9;
<a name="l00440"></a>00440             b = Xt*k8*k9 - kd*(k8+k9) - k8*k9*(N8+N9);
<a name="l00441"></a>00441             c = Xt*kd*(k8+k9) - kd^2 - kd*(k9*N9+k8*N8);
<a name="l00442"></a>00442             d = Xt*kd^2; 
<a name="l00443"></a>00443             
<a name="l00444"></a>00444             X0 = edu.stanford.covert.util.ComputationUtil.cubicfcn(a, b, c, d);
<a name="l00445"></a>00445             
<a name="l00446"></a>00446             X0 = X0(1);
<a name="l00447"></a>00447             X8 = k8*N8*X0 / (k8*X0 + kd);
<a name="l00448"></a>00448             X9 = k9*N9*X0 / (k9*X0 + kd);
<a name="l00449"></a>00449             
<a name="l00450"></a>00450             x = [X0; X9; X8];
<a name="l00451"></a>00451         end
<a name="l00452"></a>00452         
<a name="l00453"></a>00453         %resource requirements
<a name="l00454"></a>00454         function result = calcResourceRequirements_Current(this)
<a name="l00455"></a>00455             result = zeros(size(this.substrates));
<a name="l00456"></a>00456             result(this.substrateIndexs_atp) = ...
<a name="l00457"></a>00457                 + this.enzymes(this.enzymeIndexs_DnaA) ...          %number of free DnaA
<a name="l00458"></a>00458                 + this.enzymes(this.enzymeIndexs_DnaA_1mer_ADP) ... %number of DnaA-ADP to be regenerated
<a name="l00459"></a>00459                 + this.boundEnzymes(this.enzymeIndexs_DnaA_1mer_ADP);
<a name="l00460"></a>00460             result(this.substrateIndexs_water) = ...
<a name="l00461"></a>00461                 (2:7) * this.enzymes(this.enzymeIndexs_DnaA_polymer_ATP);
<a name="l00462"></a>00462         end
<a name="l00463"></a>00463 
<a name="l00464"></a>00464         %simulation
<a name="l00465"></a>00465         function evolveState(this)
<a name="l00466"></a>00466             [polATPs, polADPs] = this.calculateDnaAR1234Polymerization();
<a name="l00467"></a>00467             
<a name="l00468"></a>00468             %Activate free DnaA to DnaA-ATP
<a name="l00469"></a>00469             this.activateFreeDnaA();
<a name="l00470"></a>00470             
<a name="l00471"></a>00471             %Dissociate free DnaA-ATP polymers into monomers and hydrolyze ATPs
<a name="l00472"></a>00472             this.inactivateFreeDnaAATP();
<a name="l00473"></a>00473             
<a name="l00474"></a>00474             %DnaA binding is reduced when DNA isn&#39;t supercoiled (Margulies et
<a name="l00475"></a>00475             %al, 1996)
<a name="l00476"></a>00476             if collapse(this.chromosome.supercoiled)
<a name="l00477"></a>00477                 %bind and polymerized DnaA-ATP
<a name="l00478"></a>00478                 [polATPs, polADPs] = this.bindAndPolymerizeDnaAATP(polATPs, polADPs);
<a name="l00479"></a>00479                 
<a name="l00480"></a>00480                 %bind polymerized DnaA-ADP
<a name="l00481"></a>00481                 [polATPs, polADPs] = this.bindAndPolymerizeDnaAADP(polATPs, polADPs);
<a name="l00482"></a>00482             end
<a name="l00483"></a>00483             
<a name="l00484"></a>00484             %Stochastically release bound DnaA-AxP with uniform probability
<a name="l00485"></a>00485             this.releaseDnaAAxP(polATPs, polADPs);
<a name="l00486"></a>00486             
<a name="l00487"></a>00487             %Reactivate free DnaA from free DnaA-ADPs
<a name="l00488"></a>00488             this.reactivateFreeDnaAADP();
<a name="l00489"></a>00489         end
<a name="l00490"></a>00490     end
<a name="l00491"></a>00491 
<a name="l00492"></a>00492     %model helper functions
<a name="l00493"></a>00493     methods       
<a name="l00494"></a>00494         %Activate free DnaA to DnaA-ATP
<a name="l00495"></a>00495         function activateFreeDnaA(this)
<a name="l00496"></a>00496             nActivations = min(...
<a name="l00497"></a>00497                 this.substrates(this.substrateIndexs_atp), ...
<a name="l00498"></a>00498                 this.enzymes(this.enzymeIndexs_DnaA));
<a name="l00499"></a>00499             
<a name="l00500"></a>00500             %stop early if no activation
<a name="l00501"></a>00501             if nActivations == 0
<a name="l00502"></a>00502                 return; 
<a name="l00503"></a>00503             end
<a name="l00504"></a>00504             
<a name="l00505"></a>00505             %update DnaA, DnaA-ATP, ATP
<a name="l00506"></a>00506             this.substrates(this.substrateIndexs_atp)     = this.substrates(this.substrateIndexs_atp)     - nActivations;
<a name="l00507"></a>00507             this.enzymes(this.enzymeIndexs_DnaA)          = this.enzymes(this.enzymeIndexs_DnaA)          - nActivations;
<a name="l00508"></a>00508             this.enzymes(this.enzymeIndexs_DnaA_1mer_ATP) = this.enzymes(this.enzymeIndexs_DnaA_1mer_ATP) + nActivations;
<a name="l00509"></a>00509         end
<a name="l00510"></a>00510         
<a name="l00511"></a>00511         %Dissociate free DnaA-ATP polymers into monomers and hydrolyze ATPs
<a name="l00512"></a>00512         %
<a name="l00513"></a>00513         %These polymers are normally only found bound to functional DnaA
<a name="l00514"></a>00514         %boxes near the ORI. However if they are released from the
<a name="l00515"></a>00515         %chromosome by another protein, for example by DNA polymerase at the
<a name="l00516"></a>00516         %start of replication, they could become free. These freed polymers
<a name="l00517"></a>00517         %must dissociate into individual DnaA-ADP molecules before they can
<a name="l00518"></a>00518         %again bind to the chromosome.
<a name="l00519"></a>00519         function inactivateFreeDnaAATP(this)
<a name="l00520"></a>00520             nDissociatingPolymers = this.enzymes(this.enzymeIndexs_DnaA_polymer_ATP);
<a name="l00521"></a>00521             
<a name="l00522"></a>00522             %limit by water availability
<a name="l00523"></a>00523             <a class="code" href="json_parse_8m.html#ad2fc293e8080616c8c1e2ffbd7b86742">while</a> true
<a name="l00524"></a>00524                 nDissociatingMonomers = (2:7) * nDissociatingPolymers;
<a name="l00525"></a>00525                 if nDissociatingMonomers == 0
<a name="l00526"></a>00526                     return;
<a name="l00527"></a>00527                 end
<a name="l00528"></a>00528                 if this.substrates(this.substrateIndexs_water) &gt;= nDissociatingMonomers
<a name="l00529"></a>00529                     break;
<a name="l00530"></a>00530                 end
<a name="l00531"></a>00531                 idx = this.randStream.randsample(6, 1, false, nDissociatingPolymers);
<a name="l00532"></a>00532                 nDissociatingPolymers(idx) = nDissociatingPolymers(idx) - 1;
<a name="l00533"></a>00533             end
<a name="l00534"></a>00534 
<a name="l00535"></a>00535             %update DnaA-ATP polymers, DnaA-ADP, water, phosphate, hydrogen
<a name="l00536"></a>00536             this.substrates(this.substrateIndexs_water)      = this.substrates(this.substrateIndexs_water)      - nDissociatingMonomers;
<a name="l00537"></a>00537             this.substrates(this.substrateIndexs_phosphate)  = this.substrates(this.substrateIndexs_phosphate)  + nDissociatingMonomers;
<a name="l00538"></a>00538             this.substrates(this.substrateIndexs_hydrogen)   = this.substrates(this.substrateIndexs_hydrogen)   + nDissociatingMonomers;
<a name="l00539"></a>00539             this.enzymes(this.enzymeIndexs_DnaA_1mer_ADP)    = this.enzymes(this.enzymeIndexs_DnaA_1mer_ADP)    + nDissociatingMonomers;
<a name="l00540"></a>00540             this.enzymes(this.enzymeIndexs_DnaA_polymer_ATP) = this.enzymes(this.enzymeIndexs_DnaA_polymer_ATP) - nDissociatingPolymers;
<a name="l00541"></a>00541         end
<a name="l00542"></a>00542         
<a name="l00543"></a>00543         function [polATPs, polADPs] = bindAndPolymerizeDnaAATP(this, polATPs, polADPs)
<a name="l00544"></a>00544             %% number of free DnaA-ATP
<a name="l00545"></a>00545             numFreeDnaAATP = this.enzymes(this.enzymeIndexs_DnaA_1mer_ATP);
<a name="l00546"></a>00546             if numFreeDnaAATP == 0
<a name="l00547"></a>00547                 return;
<a name="l00548"></a>00548             end
<a name="l00549"></a>00549             
<a name="l00550"></a>00550             %% upper bound of binding
<a name="l00551"></a>00551             %rates of binding each DnaA box type
<a name="l00552"></a>00552             [positionsStrands, bindingRates, avgBindingRate] = this.calculateDnaAATPBindingRates(polATPs, polADPs);
<a name="l00553"></a>00553             
<a name="l00554"></a>00554             %Estimate number of free DnaA boxes
<a name="l00555"></a>00555             [~, complexs] = find(this.chromosome.complexBoundSites);
<a name="l00556"></a>00556             numFreeBindingSites = numel(bindingRates) ...
<a name="l00557"></a>00557                 - sum(complexs == this.enzymeGlobalIndexs(this.enzymeIndexs_DnaA_1mer_ATP)) ...
<a name="l00558"></a>00558                 - sum(complexs == this.enzymeGlobalIndexs(this.enzymeIndexs_DnaA_1mer_ADP));
<a name="l00559"></a>00559             
<a name="l00560"></a>00560             %Maximum number of DnaA-ATP binding
<a name="l00561"></a>00561             maxBinding = this.randStream.stochasticRound(min([
<a name="l00562"></a>00562                 avgBindingRate * numFreeBindingSites * numFreeDnaAATP + nnz(bindingRates(this.dnaABoxIndexs_7mer, :));
<a name="l00563"></a>00563                 numFreeBindingSites;
<a name="l00564"></a>00564                 numFreeDnaAATP]));
<a name="l00565"></a>00565             
<a name="l00566"></a>00566             %% upper bound of polymerization
<a name="l00567"></a>00567             %polymerization state of each function DnaA box
<a name="l00568"></a>00568             maxPol = 0;
<a name="l00569"></a>00569             polATPRates = zeros(size(polATPs));
<a name="l00570"></a>00570             if any(polATPs(:))
<a name="l00571"></a>00571                 
<a name="l00572"></a>00572                 %Rates of polymerizing each DnaA box
<a name="l00573"></a>00573                 polATPRates = this.calculateDnaAR1234ATPPolymerizationRates(polATPs, polADPs);
<a name="l00574"></a>00574                 
<a name="l00575"></a>00575                 %number of site available for polymerization
<a name="l00576"></a>00576                 numFreePolSites = nnz(polATPRates);
<a name="l00577"></a>00577                 if numFreePolSites &gt; 0
<a name="l00578"></a>00578                     
<a name="l00579"></a>00579                     %Calculate total number of DnaA-ATP molecules that bind an
<a name="l00580"></a>00580                     %accessible DnaA box
<a name="l00581"></a>00581                     maxPol = this.randStream.stochasticRound(min([
<a name="l00582"></a>00582                         sum(polATPRates(:)) * numFreeDnaAATP;
<a name="l00583"></a>00583                         numFreePolSites;
<a name="l00584"></a>00584                         numFreeDnaAATP]));
<a name="l00585"></a>00585                 end
<a name="l00586"></a>00586             end
<a name="l00587"></a>00587             
<a name="l00588"></a>00588             %% allocate DnaA-ATP
<a name="l00589"></a>00589             totBindingRate = avgBindingRate * numFreeBindingSites;
<a name="l00590"></a>00590             totPolRate = sum(polATPRates(:));
<a name="l00591"></a>00591             
<a name="l00592"></a>00592             maxBinding = min(maxBinding, this.randStream.stochasticRound(numFreeDnaAATP * totBindingRate / (totBindingRate + totPolRate)));
<a name="l00593"></a>00593             
<a name="l00594"></a>00594             %% bind, polymerize
<a name="l00595"></a>00595             [polATPs, polADPs, nBound] = this.bindDnaAATP(polATPs, polADPs, maxBinding, positionsStrands, bindingRates);
<a name="l00596"></a>00596             [polATPs, polADPs] = this.polymerizeDnaAATP(polATPs, polADPs, min(maxPol, numFreeDnaAATP - nBound), polATPRates);
<a name="l00597"></a>00597         end
<a name="l00598"></a>00598         
<a name="l00599"></a>00599         function [polATPs, polADPs] = bindAndPolymerizeDnaAADP(this, polATPs, polADPs)
<a name="l00600"></a>00600             %% number of free DnaA-ADP
<a name="l00601"></a>00601             numFreeDnaAADP = this.enzymes(this.enzymeIndexs_DnaA_1mer_ADP);
<a name="l00602"></a>00602             if numFreeDnaAADP == 0
<a name="l00603"></a>00603                 return;
<a name="l00604"></a>00604             end
<a name="l00605"></a>00605             
<a name="l00606"></a>00606             %% binding
<a name="l00607"></a>00607             %rates of binding each DnaA box type
<a name="l00608"></a>00608             [positionsStrands, bindingRates, avgBindingRate] = this.calculateDnaAADPBindingRates(polATPs, polADPs);
<a name="l00609"></a>00609             
<a name="l00610"></a>00610             %Estimate number of free DnaA boxes
<a name="l00611"></a>00611             [~, complexs] = find(this.chromosome.complexBoundSites);
<a name="l00612"></a>00612             numFreeBindingSites = numel(bindingRates) ...
<a name="l00613"></a>00613                 - sum(complexs == this.enzymeGlobalIndexs(this.enzymeIndexs_DnaA_1mer_ATP)) ...
<a name="l00614"></a>00614                 - sum(complexs == this.enzymeGlobalIndexs(this.enzymeIndexs_DnaA_1mer_ADP));
<a name="l00615"></a>00615             
<a name="l00616"></a>00616             %Maximum number of DnaA-ADP binding
<a name="l00617"></a>00617             maxBinding = this.randStream.stochasticRound(min([
<a name="l00618"></a>00618                 avgBindingRate * numFreeBindingSites * numFreeDnaAADP + nnz(bindingRates(this.dnaABoxIndexs_7mer, :));
<a name="l00619"></a>00619                 numFreeBindingSites;
<a name="l00620"></a>00620                 numFreeDnaAADP]));
<a name="l00621"></a>00621             
<a name="l00622"></a>00622             %% polymerization
<a name="l00623"></a>00623             %polymerization state of each function DnaA box
<a name="l00624"></a>00624             maxPol = 0;
<a name="l00625"></a>00625             polADPRates = zeros(size(polADPs));
<a name="l00626"></a>00626             if any(polATPs(:))
<a name="l00627"></a>00627                 
<a name="l00628"></a>00628                 %Rates of polymerizing each DnaA box
<a name="l00629"></a>00629                 polADPRates = this.calculateDnaAR1234ADPPolymerizationRates(polATPs, polADPs);
<a name="l00630"></a>00630                 
<a name="l00631"></a>00631                 %number of site available for polymerization
<a name="l00632"></a>00632                 numFreePolSites = nnz(polADPRates);
<a name="l00633"></a>00633                 if numFreePolSites &gt; 0
<a name="l00634"></a>00634                     
<a name="l00635"></a>00635                     %Calculate total number of DnaA-ADP molecules that bind an
<a name="l00636"></a>00636                     %accessible DnaA box
<a name="l00637"></a>00637                     maxPol = this.randStream.stochasticRound(min([
<a name="l00638"></a>00638                         sum(polADPRates(:)) * numFreeDnaAADP;
<a name="l00639"></a>00639                         numFreePolSites;
<a name="l00640"></a>00640                         numFreeDnaAADP]));
<a name="l00641"></a>00641                 end
<a name="l00642"></a>00642             end
<a name="l00643"></a>00643             
<a name="l00644"></a>00644             %% allocation
<a name="l00645"></a>00645             totBindingRate = avgBindingRate * numFreeBindingSites;
<a name="l00646"></a>00646             totPolRate = sum(polADPRates(:));
<a name="l00647"></a>00647             
<a name="l00648"></a>00648             maxBinding = min(maxBinding, this.randStream.stochasticRound(numFreeDnaAADP * totBindingRate / (totBindingRate + totPolRate)));
<a name="l00649"></a>00649             
<a name="l00650"></a>00650             %% bind, polymerize
<a name="l00651"></a>00651             [polATPs, polADPs, nBound] = this.bindDnaAADP(polATPs, polADPs, maxBinding, positionsStrands, bindingRates);
<a name="l00652"></a>00652             [polATPs, polADPs] = this.polymerizeDnaAADP(polATPs, polADPs, min(maxPol, numFreeDnaAADP - nBound), polADPRates);
<a name="l00653"></a>00653         end
<a name="l00654"></a>00654                 
<a name="l00655"></a>00655         %polymerized DnaA-ATP
<a name="l00656"></a>00656         %
<a name="l00657"></a>00657         %Choose binding sites by sampling from CDF.
<a name="l00658"></a>00658         %
<a name="l00659"></a>00659         %Calculate maximum amount of DnaA-ATP that could form
<a name="l00660"></a>00660         %Browning et al 2004, say that if there is enough ATP, all new
<a name="l00661"></a>00661         %DnaA is assumed to be in the ATP form. The consequence of this is
<a name="l00662"></a>00662         %that for most of the simulation there is pretty much only DnaA-ATP
<a name="l00663"></a>00663         %and no DnaA-ADP. Our framework however doesn&#39;t distinguish newly
<a name="l00664"></a>00664         %constructed DnaA-ATPs from those recently released from the
<a name="l00665"></a>00665         %chromosome. Consequently, because we would like to model the
<a name="l00666"></a>00666         %hydrolysis of ATP bound to recently released DnaA molecules, we
<a name="l00667"></a>00667         %must model the binding of ATP to DnaA as occuring just prior to
<a name="l00668"></a>00668         %binding to the chromosome.
<a name="l00669"></a>00669         %
<a name="l00670"></a>00670         %<a class="code" href="class_note.html">Note</a>: to implement the Browning et al model, the hydrolysis of ATP
<a name="l00671"></a>00671         %bound to recently released DnaA would have to be handled by the
<a name="l00672"></a>00672         %setRegionProteinUnbound method of the <a class="code" href="class_chromosome.html">Chromosome</a> class.
<a name="l00673"></a>00673         function [polATPs, polADPs] = polymerizeDnaAATP(this, polATPs, polADPs, maxPol, polATPRates)
<a name="l00674"></a>00674             if maxPol == 0
<a name="l00675"></a>00675                 return;
<a name="l00676"></a>00676             end
<a name="l00677"></a>00677             
<a name="l00678"></a>00678             %stochastically select DnaA boxes to polymerize according to rate distribution
<a name="l00679"></a>00679             idxs = this.randStream.randsample(numel(polATPRates), maxPol, false, polATPRates(:));
<a name="l00680"></a>00680             
<a name="l00681"></a>00681             %update ATP polymerization status
<a name="l00682"></a>00682             polATPs(idxs) = polATPs(idxs) + 1;
<a name="l00683"></a>00683             
<a name="l00684"></a>00684             %update chromosome state
<a name="l00685"></a>00685             positionsStrands = [
<a name="l00686"></a>00686                 this.dnaABoxStartPositions(this.dnaABoxIndexs_R1234(mod(idxs - 1, 4) + 1), 1) ...
<a name="l00687"></a>00687                 2*ceil(idxs/4)-1];
<a name="l00688"></a>00688             
<a name="l00689"></a>00689             this.modifyProteinOnChromosome(positionsStrands, this.enzymeIndexs_DnaA_Nmer_ATP(polATPs(idxs)));
<a name="l00690"></a>00690             
<a name="l00691"></a>00691             counts = histc(polATPs(idxs), 2:7);
<a name="l00692"></a>00692             this.enzymes(this.enzymeIndexs_DnaA_1mer_ATP)      = this.enzymes(this.enzymeIndexs_DnaA_1mer_ATP)      - maxPol;
<a name="l00693"></a>00693             this.enzymes(this.enzymeIndexs_DnaA_Nmer_ATP(1:6)) = this.enzymes(this.enzymeIndexs_DnaA_Nmer_ATP(1:6)) - counts(:);
<a name="l00694"></a>00694             this.enzymes(this.enzymeIndexs_DnaA_Nmer_ATP(2:7)) = this.enzymes(this.enzymeIndexs_DnaA_Nmer_ATP(2:7)) + counts(:);
<a name="l00695"></a>00695         end
<a name="l00696"></a>00696         
<a name="l00697"></a>00697         %polymerized DnaA-ADP
<a name="l00698"></a>00698         function [polATPs, polADPs] = polymerizeDnaAADP(this, polATPs, polADPs, maxPol, polADPRates)
<a name="l00699"></a>00699             if maxPol == 0
<a name="l00700"></a>00700                 return;
<a name="l00701"></a>00701             end
<a name="l00702"></a>00702             
<a name="l00703"></a>00703             %stochastically select DnaA boxes to polymerize according to rate distribution
<a name="l00704"></a>00704             idxs = this.randStream.randsample(numel(polADPRates), maxPol, false, polADPRates(:));
<a name="l00705"></a>00705             
<a name="l00706"></a>00706             %update AxP polymerization status
<a name="l00707"></a>00707             polADPs(idxs) = polATPs(idxs) + 1;
<a name="l00708"></a>00708             polATPs(idxs) = 0;
<a name="l00709"></a>00709             
<a name="l00710"></a>00710             %update chromosome state
<a name="l00711"></a>00711             positionsStrands = [
<a name="l00712"></a>00712                 this.dnaABoxStartPositions(this.dnaABoxIndexs_R1234(mod(idxs - 1, 4) + 1), 1) ...
<a name="l00713"></a>00713                 2*ceil(idxs/4)-1];
<a name="l00714"></a>00714             
<a name="l00715"></a>00715             this.modifyProteinOnChromosome(positionsStrands, this.enzymeIndexs_DnaA_Nmer_ADP(polADPs(idxs)));
<a name="l00716"></a>00716             
<a name="l00717"></a>00717             counts = histc(polADPs(idxs), 2:7);
<a name="l00718"></a>00718             this.enzymes(this.enzymeIndexs_DnaA_1mer_ADP)      = this.enzymes(this.enzymeIndexs_DnaA_1mer_ADP)      - maxPol;
<a name="l00719"></a>00719             this.enzymes(this.enzymeIndexs_DnaA_Nmer_ATP(1:6)) = this.enzymes(this.enzymeIndexs_DnaA_Nmer_ATP(1:6)) - counts(:);
<a name="l00720"></a>00720             this.enzymes(this.enzymeIndexs_DnaA_Nmer_ADP(2:7)) = this.enzymes(this.enzymeIndexs_DnaA_Nmer_ADP(2:7)) + counts(:);
<a name="l00721"></a>00721         end
<a name="l00722"></a>00722         
<a name="l00723"></a>00723         %Bind DnaA-ATP
<a name="l00724"></a>00724         function [polATPs, polADPs, nBound] = bindDnaAATP(this, polATPs, polADPs, maxBinding, positionsStrands, bindingRates)
<a name="l00725"></a>00725             if maxBinding == 0;
<a name="l00726"></a>00726                 nBound = 0;
<a name="l00727"></a>00727                 return;
<a name="l00728"></a>00728             end
<a name="l00729"></a>00729             
<a name="l00730"></a>00730             %Bind DnaA-ATP stochastically to accessible DnaA boxes according to rate distribution
<a name="l00731"></a>00731             [tfs, ~, ~, nBound] = this.bindProteinToChromosome(positionsStrands, ...
<a name="l00732"></a>00732                 this.enzymeIndexs_DnaA_1mer_ATP, maxBinding, bindingRates, true, false, 1, false, [], true);
<a name="l00733"></a>00733             polATPs(tfs(this.dnaABoxIndexs_R1234, 1), 1) = 1;
<a name="l00734"></a>00734         end
<a name="l00735"></a>00735         
<a name="l00736"></a>00736         %Bind DnaA-ADP
<a name="l00737"></a>00737         function [polATPs, polADPs, nBound] = bindDnaAADP(this, polATPs, polADPs, maxBinding, positionsStrands, bindingRates)
<a name="l00738"></a>00738             if maxBinding == 0;
<a name="l00739"></a>00739                 nBound = 0;
<a name="l00740"></a>00740                 return;
<a name="l00741"></a>00741             end
<a name="l00742"></a>00742             
<a name="l00743"></a>00743             %Bind DnaA-ADP stochastically to accessible DnaA boxes according to rate distribution
<a name="l00744"></a>00744             [tfs, ~, ~, nBound] = this.bindProteinToChromosome(positionsStrands, ...
<a name="l00745"></a>00745                 this.enzymeIndexs_DnaA_1mer_ADP, maxBinding, bindingRates, true, false, 1, false, [], true);
<a name="l00746"></a>00746             polADPs(tfs(this.dnaABoxIndexs_R1234, 1), 1) = 1;
<a name="l00747"></a>00747         end
<a name="l00748"></a>00748                 
<a name="l00749"></a>00749         %Stochastically release/depolymerize bound DnaA-AxP with uniform probability
<a name="l00750"></a>00750         function [polATPs, polADPs] = releaseDnaAAxP(this, polATPs, polADPs)
<a name="l00751"></a>00751             %get bound DnaA complexes
<a name="l00752"></a>00752             c = this.chromosome;
<a name="l00753"></a>00753             [posStrnds, complexGblIdxs] = find(c.complexBoundSites);
<a name="l00754"></a>00754             complexLclIdxs = ismembc2(complexGblIdxs, this.enzymeComplexGlobalIndexs);
<a name="l00755"></a>00755             tfs = complexLclIdxs &gt; 0;
<a name="l00756"></a>00756             
<a name="l00757"></a>00757             %protect completed polymerized layers at R1-4 positions
<a name="l00758"></a>00758             minPol = this.calculateDnaAR1234ComplexSize(polATPs, polADPs);
<a name="l00759"></a>00759             
<a name="l00760"></a>00760             if minPol(1) &gt; 0
<a name="l00761"></a>00761                 protectedPositions1 = this.dnaABoxStartPositions(...
<a name="l00762"></a>00762                     this.dnaABoxIndexs_R1234(polATPs(:, 1) == minPol(1)));
<a name="l00763"></a>00763                 if minPol(1) &gt;= 7
<a name="l00764"></a>00764                     protectedPositions1 = [protectedPositions1;
<a name="l00765"></a>00765                         this.dnaABoxStartPositions(this.dnaABoxIndexs_R5, :)];
<a name="l00766"></a>00766                 end
<a name="l00767"></a>00767                 if ~isempty(protectedPositions1)
<a name="l00768"></a>00768                     tfs(tfs) = ~edu.stanford.covert.util.<a class="code" href="class_sparse_mat.html">SparseMat</a>.ismember_subs(...
<a name="l00769"></a>00769                         posStrnds(tfs, :), [protectedPositions1 ones(size(protectedPositions1))], [c.sequenceLen c.nCompartments]);
<a name="l00770"></a>00770                 end
<a name="l00771"></a>00771             end
<a name="l00772"></a>00772             
<a name="l00773"></a>00773             if minPol(2) &gt; 0
<a name="l00774"></a>00774                 protectedPositions2 = this.dnaABoxStartPositions(...
<a name="l00775"></a>00775                     this.dnaABoxIndexs_R1234(polATPs(:, 2) == minPol(2)));
<a name="l00776"></a>00776                 if minPol(2) &gt;= 7
<a name="l00777"></a>00777                     protectedPositions2 = [protectedPositions2;
<a name="l00778"></a>00778                         this.dnaABoxStartPositions(this.dnaABoxIndexs_R5, :)];
<a name="l00779"></a>00779                 end
<a name="l00780"></a>00780                 if ~isempty(protectedPositions2)
<a name="l00781"></a>00781                     tfs(tfs) = ~edu.stanford.covert.util.<a class="code" href="class_sparse_mat.html">SparseMat</a>.ismember_subs(...
<a name="l00782"></a>00782                         posStrnds(tfs, :), [protectedPositions2 3*ones(size(protectedPositions2))], [c.sequenceLen c.nCompartments]);                   
<a name="l00783"></a>00783                 end
<a name="l00784"></a>00784             end
<a name="l00785"></a>00785             
<a name="l00786"></a>00786             %choose complexes to release
<a name="l00787"></a>00787             tfs(tfs) = this.randStream.rand(sum(tfs), 1) &lt; this.kd1ATP / 3600;
<a name="l00788"></a>00788             if ~any(tfs)
<a name="l00789"></a>00789                 return;
<a name="l00790"></a>00790             end
<a name="l00791"></a>00791             complexLclIdxs = complexLclIdxs(tfs, 1);
<a name="l00792"></a>00792             posStrnds = posStrnds(tfs, :);
<a name="l00793"></a>00793             
<a name="l00794"></a>00794             %update enzymes, bound enzymes
<a name="l00795"></a>00795             remainingComplexLclIdxs = this.dnaARelease_remainingDnaAIndexs(complexLclIdxs);
<a name="l00796"></a>00796             
<a name="l00797"></a>00797             this.releaseProteinFromSites(posStrnds(remainingComplexLclIdxs == 0, :), false);
<a name="l00798"></a>00798             
<a name="l00799"></a>00799             posStrnds = posStrnds(remainingComplexLclIdxs ~= 0, :);
<a name="l00800"></a>00800             complexLclIdxs = complexLclIdxs(remainingComplexLclIdxs ~= 0, 1);
<a name="l00801"></a>00801             remainingComplexLclIdxs = remainingComplexLclIdxs(remainingComplexLclIdxs ~= 0, 1);
<a name="l00802"></a>00802             releasedComplexLclIdxs = this.dnaARelease_releasedDnaAIndexs(complexLclIdxs);
<a name="l00803"></a>00803             this.modifyProteinOnChromosome(posStrnds, remainingComplexLclIdxs);
<a name="l00804"></a>00804             
<a name="l00805"></a>00805             count = histc(complexLclIdxs, 1:numel(this.enzymes));
<a name="l00806"></a>00806             remainingCount = histc(remainingComplexLclIdxs, 1:numel(this.enzymes));
<a name="l00807"></a>00807             releasedCount = histc(releasedComplexLclIdxs, 1:numel(this.enzymes));
<a name="l00808"></a>00808             this.enzymes = this.enzymes -count(:) + remainingCount(:) + releasedCount(:);
<a name="l00809"></a>00809         end
<a name="l00810"></a>00810     
<a name="l00811"></a>00811         %Reactivate free DnaA-ATPs from free DnaA-ADPs, upto available DnaA-ADP and ATP
<a name="l00812"></a>00812         %
<a name="l00813"></a>00813         %Incorporating DnaA-ADP rejuvenation to DnaA-ATP as in Atlas 2008.
<a name="l00814"></a>00814         %This reaction is promoted by the aciding phospholipids cadiolipin
<a name="l00815"></a>00815         %and phosphatidylglycerol (yat-ming 1998, crooke 1992, sekimizu
<a name="l00816"></a>00816         %1987).
<a name="l00817"></a>00817         function reactivateFreeDnaAADP(this)
<a name="l00818"></a>00818             %DnaA-ADP available for regeneration
<a name="l00819"></a>00819             numFreeDnaAADP = this.enzymes(this.enzymeIndexs_DnaA_1mer_ADP);
<a name="l00820"></a>00820             if numFreeDnaAADP == 0
<a name="l00821"></a>00821                 return; 
<a name="l00822"></a>00822             end
<a name="l00823"></a>00823             
<a name="l00824"></a>00824             %upper bound on DnaA-ADP regeneration to DnaA-ATP
<a name="l00825"></a>00825             membraneConc = this.mass.metaboliteWt(1, this.mass.compartment.membraneIndexs) / this.geometry.volume; %g/L
<a name="l00826"></a>00826             numRegenerations = min([
<a name="l00827"></a>00827                 this.substrates(this.substrateIndexs_atp);
<a name="l00828"></a>00828                 numFreeDnaAADP;
<a name="l00829"></a>00829                 this.randStream.stochasticRound(numFreeDnaAADP * ...
<a name="l00830"></a>00830                 (this.k_Regen / 3600 * membraneConc) / (this.K_Regen_P4 + membraneConc) * ...
<a name="l00831"></a>00831                 this.stepSizeSec)]);
<a name="l00832"></a>00832             
<a name="l00833"></a>00833             %stop early if no regeneration
<a name="l00834"></a>00834             if numRegenerations == 0
<a name="l00835"></a>00835                 return; 
<a name="l00836"></a>00836             end
<a name="l00837"></a>00837             
<a name="l00838"></a>00838             %update DnaA-ATP, DnaA-ADP, ATP, ADP
<a name="l00839"></a>00839             this.enzymes(this.enzymeIndexs_DnaA_1mer_ADP) = this.enzymes(this.enzymeIndexs_DnaA_1mer_ADP) - numRegenerations;
<a name="l00840"></a>00840             this.enzymes(this.enzymeIndexs_DnaA_1mer_ATP) = this.enzymes(this.enzymeIndexs_DnaA_1mer_ATP) + numRegenerations;
<a name="l00841"></a>00841             this.substrates(this.substrateIndexs_atp)     = this.substrates(this.substrateIndexs_atp)     - numRegenerations;
<a name="l00842"></a>00842             this.substrates(this.substrateIndexs_adp)     = this.substrates(this.substrateIndexs_adp)     + numRegenerations;
<a name="l00843"></a>00843         end
<a name="l00844"></a>00844     end
<a name="l00845"></a>00845     
<a name="l00846"></a>00846     %model helper helper methods
<a name="l00847"></a>00847     methods
<a name="l00848"></a>00848         function polRates = calculateDnaAR1234ATPPolymerizationRates(this, polATPs, polADPs)
<a name="l00849"></a>00849             %initialize rates
<a name="l00850"></a>00850             polRates = zeros(4, 2);
<a name="l00851"></a>00851             
<a name="l00852"></a>00852             %complex size
<a name="l00853"></a>00853             pol = this.calculateDnaAR1234ComplexSize(polATPs, polADPs);
<a name="l00854"></a>00854             
<a name="l00855"></a>00855             %stop if no polymerization possible
<a name="l00856"></a>00856             if ~any(pol)
<a name="l00857"></a>00857                 return;
<a name="l00858"></a>00858             end
<a name="l00859"></a>00859             
<a name="l00860"></a>00860             %complex size range for cooperativity to apply
<a name="l00861"></a>00861             polRange = min(6, max(1, pol));
<a name="l00862"></a>00862             
<a name="l00863"></a>00863             %Rates of polymerizing each DnaA box
<a name="l00864"></a>00864             nAvo = edu.stanford.covert.util.<a class="code" href="class_constant_util.html">ConstantUtil</a>.nAvogadro;
<a name="l00865"></a>00865             polRates(4,   :) = this.kb1ATP * 1e9 / 3600 / nAvo / this.geometry.volume * this.stepSizeSec;
<a name="l00866"></a>00866             polRates(1:3, :) = this.kb2ATP * 1e9 / 3600 / nAvo / this.geometry.volume * this.stepSizeSec;
<a name="l00867"></a>00867             polRates = polRates .* (polATPs == [polRange; polRange; polRange; polRange]);
<a name="l00868"></a>00868             if ~any(polRates(:))
<a name="l00869"></a>00869                 return;
<a name="l00870"></a>00870             end
<a name="l00871"></a>00871             
<a name="l00872"></a>00872             %Include effect of cooperativity
<a name="l00873"></a>00873             polRates = polRates .* this.calculateDnaAR1234ATPPolymerizationCooperativity(polATPs, polADPs, pol);
<a name="l00874"></a>00874         end
<a name="l00875"></a>00875         
<a name="l00876"></a>00876         function polRates = calculateDnaAR1234ADPPolymerizationRates(this, polATPs, polADPs)
<a name="l00877"></a>00877             %initialize rates
<a name="l00878"></a>00878             polRates = zeros(4, 2);
<a name="l00879"></a>00879             
<a name="l00880"></a>00880             %complex size
<a name="l00881"></a>00881             pol = this.calculateDnaAR1234ComplexSize(polATPs, polADPs);
<a name="l00882"></a>00882             
<a name="l00883"></a>00883             %stop if no polymerization possible
<a name="l00884"></a>00884             if ~any(pol)
<a name="l00885"></a>00885                 return;
<a name="l00886"></a>00886             end
<a name="l00887"></a>00887             
<a name="l00888"></a>00888             %complex size range for cooperativity to apply
<a name="l00889"></a>00889             polRange = min(6, max(1, pol));
<a name="l00890"></a>00890             
<a name="l00891"></a>00891             %Rates of polymerizing each DnaA box
<a name="l00892"></a>00892             nAvo = edu.stanford.covert.util.<a class="code" href="class_constant_util.html">ConstantUtil</a>.nAvogadro;
<a name="l00893"></a>00893             polRates(4,   :) = this.kb1ADP * 1e9 / 3600 / nAvo / this.geometry.volume * this.stepSizeSec;
<a name="l00894"></a>00894             polRates(1:3, :) = this.kb2ADP * 1e9 / 3600 / nAvo / this.geometry.volume * this.stepSizeSec;
<a name="l00895"></a>00895             polRates = polRates .* (polATPs == [polRange; polRange; polRange; polRange]);
<a name="l00896"></a>00896         end
<a name="l00897"></a>00897         
<a name="l00898"></a>00898         function cooperativity = calculateDnaAR1234ATPPolymerizationCooperativity(this, polATPs, polADPs, pol)
<a name="l00899"></a>00899             %site cooperativity
<a name="l00900"></a>00900             cooperativity = this.siteCooperativity * [
<a name="l00901"></a>00901                 polATPs(4, :) &gt;  pol;
<a name="l00902"></a>00902                 all(polATPs([1 4], :) &gt; [pol; pol], 1);
<a name="l00903"></a>00903                 all(polATPs([1 4], :) &gt; [pol; pol], 1);
<a name="l00904"></a>00904                 any(polATPs &gt; [pol; pol; pol; pol], 1);
<a name="l00905"></a>00905                 ];
<a name="l00906"></a>00906             
<a name="l00907"></a>00907             %additive state cooperativity
<a name="l00908"></a>00908             %- we considered multiplicative and exponential models, but these
<a name="l00909"></a>00909             %  give rise to higher variance in the replication initiation time
<a name="l00910"></a>00910             cooperativity(4, :) = cooperativity(4, :) + this.stateCooperativity * pol; 
<a name="l00911"></a>00911             
<a name="l00912"></a>00912             %set cooperativity to 1 for sites which can&#39;t polymerize
<a name="l00913"></a>00913             cooperativity = max(1, (polATPs == [pol; pol; pol; pol] &amp; polADPs == 0) .* cooperativity);
<a name="l00914"></a>00914         end
<a name="l00915"></a>00915         
<a name="l00916"></a>00916         %Rate which DnaA-ATP binds to each DnaA box
<a name="l00917"></a>00917         function [positionsStrands, bindingRates, avgBindingRate] = calculateDnaAATPBindingRates(this, polATPs, polADPs)
<a name="l00918"></a>00918             %8-mer, 9-mer, average binding rates
<a name="l00919"></a>00919             nAvo = edu.stanford.covert.util.<a class="code" href="class_constant_util.html">ConstantUtil</a>.nAvogadro;
<a name="l00920"></a>00920             rate9mer = this.kb1ATP * 1e9 / 3600 / nAvo / this.geometry.volume * this.stepSizeSec;
<a name="l00921"></a>00921             rate8mer = this.kb2ATP * 1e9 / 3600 / nAvo / this.geometry.volume * this.stepSizeSec;
<a name="l00922"></a>00922             avgBindingRate = (rate9mer*numel(this.dnaABoxIndexs_9mer) + rate8mer*numel(this.dnaABoxIndexs_8mer)) / ...
<a name="l00923"></a>00923                 numel(this.dnaABoxStartPositions);
<a name="l00924"></a>00924             
<a name="l00925"></a>00925             %functional DnaA complex size
<a name="l00926"></a>00926             complexSize = this.calculateDnaAR1234ComplexSize(polATPs, polADPs);
<a name="l00927"></a>00927             
<a name="l00928"></a>00928             %cooperativity
<a name="l00929"></a>00929             cooperativity = this.calculateDnaAR1234ATPPolymerizationCooperativity(polATPs, polADPs, complexSize);
<a name="l00930"></a>00930             
<a name="l00931"></a>00931             %First chromosome positions, strands, binding rates
<a name="l00932"></a>00932             %set rate of R5 to Inf if R1-4 fully bound
<a name="l00933"></a>00933             %baseline rate of binding 7mer site low, and binding is HIGHLY
<a name="l00934"></a>00934             %cooperative with complete occupancy of R1-4 sites
<a name="l00935"></a>00935             positionsStrands = [this.dnaABoxStartPositions ones(size(this.dnaABoxStartPositions))];
<a name="l00936"></a>00936             bindingRates = zeros(numel(this.dnaABoxStartPositions), 1);
<a name="l00937"></a>00937             bindingRates(this.dnaABoxIndexs_9mer, 1) = rate9mer;
<a name="l00938"></a>00938             bindingRates(this.dnaABoxIndexs_8mer, 1) = rate8mer;
<a name="l00939"></a>00939             bindingRates(this.dnaABoxIndexs_R5,   1) = (complexSize(1) == 7) * realmax;
<a name="l00940"></a>00940             
<a name="l00941"></a>00941             bindingRates(this.dnaABoxIndexs_R1234) = ...
<a name="l00942"></a>00942                 bindingRates(this.dnaABoxIndexs_R1234) .* ...
<a name="l00943"></a>00943                 cooperativity(:, 1);
<a name="l00944"></a>00944             
<a name="l00945"></a>00945             %Second chromosome positions, strands, binding rates
<a name="l00946"></a>00946             %- We ingore setting the R5 box rate for computational efficiency
<a name="l00947"></a>00947             %  because a complex should never be form on the second chromosome
<a name="l00948"></a>00948             %- We also ignore cooperativity on the second chromosome
<a name="l00949"></a>00949             if collapse(this.chromosome.polymerizedRegions) &gt; 2 * this.chromosome.sequenceLen
<a name="l00950"></a>00950                 positionsStrands2 = [this.dnaABoxStartPositions 3*ones(size(this.dnaABoxStartPositions))];
<a name="l00951"></a>00951                 bindingRates2 = zeros(numel(this.dnaABoxStartPositions), 1);
<a name="l00952"></a>00952                 bindingRates2(this.dnaABoxIndexs_9mer, 1) = rate9mer;
<a name="l00953"></a>00953                 bindingRates2(this.dnaABoxIndexs_8mer, 1) = rate8mer;
<a name="l00954"></a>00954                 bindingRates2(this.dnaABoxIndexs_R5,   1) = (complexSize(2) == 7) * realmax;
<a name="l00955"></a>00955                 
<a name="l00956"></a>00956                 bindingRates2(this.dnaABoxIndexs_R1234) = ...
<a name="l00957"></a>00957                     bindingRates2(this.dnaABoxIndexs_R1234) .* ...
<a name="l00958"></a>00958                     cooperativity(:, 2);
<a name="l00959"></a>00959                 
<a name="l00960"></a>00960                 if collapse(this.chromosome.polymerizedRegions) &lt; 4 * this.chromosome.sequenceLen
<a name="l00961"></a>00961                     [pos, len] = find(this.chromosome.doubleStrandedRegions);
<a name="l00962"></a>00962                     len = len(pos(:, 2) == 4, 1);
<a name="l00963"></a>00963                     pos = pos(pos(:, 2) == 4, 1);
<a name="l00964"></a>00964                     tfs = this.dnaABoxStartPositions &lt; pos(1) + len(1) | this.dnaABoxStartPositions &gt; pos(end);
<a name="l00965"></a>00965                     positionsStrands2 = positionsStrands2(tfs, :);
<a name="l00966"></a>00966                     bindingRates2 = bindingRates2(tfs);
<a name="l00967"></a>00967                 end
<a name="l00968"></a>00968                 
<a name="l00969"></a>00969                 bindingRates = [bindingRates; bindingRates2];
<a name="l00970"></a>00970                 positionsStrands = [positionsStrands; positionsStrands2];
<a name="l00971"></a>00971             end
<a name="l00972"></a>00972         end
<a name="l00973"></a>00973         
<a name="l00974"></a>00974         %Rate which DnaA-ADP binds to each DnaA box
<a name="l00975"></a>00975         function [positionsStrands, bindingRates, avgBindingRate] = calculateDnaAADPBindingRates(this, polATPs, polADPs)
<a name="l00976"></a>00976             %8-mer, 9-mer, average binding rates
<a name="l00977"></a>00977             nAvo = edu.stanford.covert.util.<a class="code" href="class_constant_util.html">ConstantUtil</a>.nAvogadro;
<a name="l00978"></a>00978             rate9mer = this.kb1ADP * 1e9 / 3600 / nAvo / this.geometry.volume * this.stepSizeSec;
<a name="l00979"></a>00979             rate8mer = this.kb2ADP * 1e9 / 3600 / nAvo / this.geometry.volume * this.stepSizeSec;
<a name="l00980"></a>00980             avgBindingRate = (rate9mer*numel(this.dnaABoxIndexs_9mer) + rate8mer*numel(this.dnaABoxIndexs_8mer)) / numel(this.dnaABoxStartPositions);
<a name="l00981"></a>00981             
<a name="l00982"></a>00982             %functional DnaA complex size
<a name="l00983"></a>00983             complexSize = this.calculateDnaAR1234ComplexSize(polATPs, polADPs);
<a name="l00984"></a>00984             
<a name="l00985"></a>00985             %First chromosome positions, strands, binding rates
<a name="l00986"></a>00986             %set rate of R5 to Inf if R1-4 fully bound
<a name="l00987"></a>00987             %baseline rate of binding 7mer site low, and binding is HIGHLY
<a name="l00988"></a>00988             %cooperative with complete occupancy of R1-4 sites
<a name="l00989"></a>00989             positionsStrands = [this.dnaABoxStartPositions ones(size(this.dnaABoxStartPositions))];
<a name="l00990"></a>00990             bindingRates = zeros(numel(this.dnaABoxStartPositions), 1);
<a name="l00991"></a>00991             bindingRates(this.dnaABoxIndexs_9mer, 1) = rate9mer;
<a name="l00992"></a>00992             bindingRates(this.dnaABoxIndexs_8mer, 1) = rate8mer;
<a name="l00993"></a>00993             bindingRates(this.dnaABoxIndexs_R5,   1) = (complexSize(1) == 7) * realmax;
<a name="l00994"></a>00994             
<a name="l00995"></a>00995             %Second chromosome positions, strands, binding rates
<a name="l00996"></a>00996             %We ingore setting the R5 box rate for computational efficiency
<a name="l00997"></a>00997             %because a complex should never be form on the second chromosome
<a name="l00998"></a>00998             if collapse(this.chromosome.polymerizedRegions) &gt; 2 * this.chromosome.sequenceLen
<a name="l00999"></a>00999                 positionsStrands2 = [this.dnaABoxStartPositions 3*ones(size(this.dnaABoxStartPositions))];
<a name="l01000"></a>01000                 bindingRates2 = zeros(numel(this.dnaABoxStartPositions), 1);
<a name="l01001"></a>01001                 bindingRates2(this.dnaABoxIndexs_9mer, 1) = rate9mer;
<a name="l01002"></a>01002                 bindingRates2(this.dnaABoxIndexs_8mer, 1) = rate8mer;
<a name="l01003"></a>01003                 bindingRates2(this.dnaABoxIndexs_R5,   1) = (complexSize(2) == 7) * realmax;
<a name="l01004"></a>01004                 
<a name="l01005"></a>01005                 if collapse(this.chromosome.polymerizedRegions) &lt; 4 * this.chromosome.sequenceLen
<a name="l01006"></a>01006                     [pos, len] = find(this.chromosome.doubleStrandedRegions);
<a name="l01007"></a>01007                     len = len(pos(:, 2) == 4, 1);
<a name="l01008"></a>01008                     pos = pos(pos(:, 2) == 4, 1);
<a name="l01009"></a>01009                     tfs = this.dnaABoxStartPositions &lt; pos(1) + len(1) | this.dnaABoxStartPositions &gt; pos(end);
<a name="l01010"></a>01010                     positionsStrands2 = positionsStrands2(tfs, :);
<a name="l01011"></a>01011                     bindingRates2 = bindingRates2(tfs);
<a name="l01012"></a>01012                 end
<a name="l01013"></a>01013                 
<a name="l01014"></a>01014                 bindingRates = [bindingRates; bindingRates2];
<a name="l01015"></a>01015                 positionsStrands = [positionsStrands; positionsStrands2];
<a name="l01016"></a>01016             end
<a name="l01017"></a>01017         end
<a name="l01018"></a>01018         
<a name="l01019"></a>01019         function [polATP, polADP] = calculateDnaAR1234Polymerization(this)
<a name="l01020"></a>01020             polATP = zeros(4, 2);
<a name="l01021"></a>01021             polADP = zeros(4, 2);
<a name="l01022"></a>01022             c = this.chromosome;
<a name="l01023"></a>01023             [posStrnds, complexs] = find(c.complexBoundSites);
<a name="l01024"></a>01024             
<a name="l01025"></a>01025             %ATP
<a name="l01026"></a>01026             idxsATP = ismembc2(complexs, this.enzymeGlobalIndexs(this.enzymeIndexs_DnaA_Nmer_ATP));
<a name="l01027"></a>01027             tfsATP = idxsATP &gt; 0;
<a name="l01028"></a>01028             idxsATP = idxsATP(tfsATP, 1);
<a name="l01029"></a>01029             [tfs2, idxs2] = edu.stanford.covert.util.<a class="code" href="class_sparse_mat.html">SparseMat</a>.ismember_subs(...
<a name="l01030"></a>01030                 [this.dnaABoxStartPositions(this.dnaABoxIndexs_R1234) ones(4, 1)], ...
<a name="l01031"></a>01031                 posStrnds(tfsATP, :), [c.sequenceLen c.nCompartments]);
<a name="l01032"></a>01032             polATP(tfs2, 1) = idxsATP(idxs2(tfs2, 1), 1);
<a name="l01033"></a>01033             
<a name="l01034"></a>01034             %ADP
<a name="l01035"></a>01035             if nargout &gt;= 2
<a name="l01036"></a>01036                 idxsADP = ismembc2(complexs, this.enzymeGlobalIndexs(this.enzymeIndexs_DnaA_Nmer_ADP));
<a name="l01037"></a>01037                 tfsADP = idxsADP &gt; 0;
<a name="l01038"></a>01038                 idxsADP = idxsADP(tfsADP, 1);
<a name="l01039"></a>01039                 [tfs2, idxs2] = edu.stanford.covert.util.<a class="code" href="class_sparse_mat.html">SparseMat</a>.ismember_subs(...
<a name="l01040"></a>01040                     [this.dnaABoxStartPositions(this.dnaABoxIndexs_R1234) ones(4, 1)], ...
<a name="l01041"></a>01041                     posStrnds(tfsADP, :), [c.sequenceLen c.nCompartments]);
<a name="l01042"></a>01042                 polADP(tfs2, 1) = idxsADP(idxs2(tfs2, 1), 1);
<a name="l01043"></a>01043             end
<a name="l01044"></a>01044             
<a name="l01045"></a>01045             %second chromosome
<a name="l01046"></a>01046             if nnz(this.chromosome.polymerizedRegions) ~= 2
<a name="l01047"></a>01047                 %ATP
<a name="l01048"></a>01048                 [tfs2, idxs2] = edu.stanford.covert.util.<a class="code" href="class_sparse_mat.html">SparseMat</a>.ismember_subs(...
<a name="l01049"></a>01049                     [this.dnaABoxStartPositions(this.dnaABoxIndexs_R1234) 3*ones(4, 1)], ...
<a name="l01050"></a>01050                     posStrnds(tfsATP, :), [c.sequenceLen c.nCompartments]);
<a name="l01051"></a>01051                 polATP(tfs2, 2) = idxsATP(idxs2(tfs2, 1), 1);
<a name="l01052"></a>01052                 
<a name="l01053"></a>01053                 %ADP
<a name="l01054"></a>01054                 if nargout &gt;= 2
<a name="l01055"></a>01055                     [tfs2, idxs2] = edu.stanford.covert.util.<a class="code" href="class_sparse_mat.html">SparseMat</a>.ismember_subs(...
<a name="l01056"></a>01056                         [this.dnaABoxStartPositions(this.dnaABoxIndexs_R1234) 3*ones(4, 1)], ...
<a name="l01057"></a>01057                         posStrnds(tfsADP, :), [c.sequenceLen c.nCompartments]);
<a name="l01058"></a>01058                     polADP(tfs2, 2) = idxsADP(idxs2(tfs2, 1), 1);
<a name="l01059"></a>01059                 end
<a name="l01060"></a>01060             end
<a name="l01061"></a>01061         end
<a name="l01062"></a>01062         
<a name="l01063"></a>01063         function siz = calculateDnaAR1234ComplexSize(~, polATPs, polADPs)
<a name="l01064"></a>01064             siz = min(max(polATPs, polADPs-1), [], 1);
<a name="l01065"></a>01065         end
<a name="l01066"></a>01066         
<a name="l01067"></a>01067         function tf = calcuateIsDnaAR5Occupied(this)
<a name="l01068"></a>01068             tf = this.chromosome.complexBoundSites([
<a name="l01069"></a>01069                 this.dnaABoxStartPositions(this.dnaABoxIndexs_R5) 1
<a name="l01070"></a>01070                 this.dnaABoxStartPositions(this.dnaABoxIndexs_R5) 3])&#39; == ...
<a name="l01071"></a>01071                 this.enzymeGlobalIndexs(this.enzymeIndexs_DnaA_1mer_ATP);
<a name="l01072"></a>01072         end
<a name="l01073"></a>01073         
<a name="l01074"></a>01074         %Returns true if all functional DnaA boxes (R1-5) are maximally
<a name="l01075"></a>01075         %occupied:
<a name="l01076"></a>01076         %- R4   (9mer, high affinity)   is  bound by DnaA-ATP 7mer
<a name="l01077"></a>01077         %- R1-3 (8mer, medium affinity) are bound by DnaA-ATP 7mers
<a name="l01078"></a>01078         %- R5   (7mer, low affinity)    is  bound by DnaA-ATP 1mer
<a name="l01079"></a>01079         function tf = calculateIsDnaAORIComplexAssembled(this)
<a name="l01080"></a>01080             tf = all(this.calculateDnaAR1234Polymerization() &gt;= [7 7 7 7; 7 7 7 7]&#39;, 1) &amp; ...
<a name="l01081"></a>01081                 this.calcuateIsDnaAR5Occupied();
<a name="l01082"></a>01082         end
<a name="l01083"></a>01083         
<a name="l01084"></a>01084         %approximate status of DnaA boxes (approximate to speed calculation;
<a name="l01085"></a>01085         %approximate because doesn&#39;t use <a class="code" href="class_chromosome.html">Chromosome</a> isRegionPolymerized
<a name="l01086"></a>01086         %method)
<a name="l01087"></a>01087         %
<a name="l01088"></a>01088         %A more exact calculation would replace the second and third sections
<a name="l01089"></a>01089         %below with:
<a name="l01090"></a>01090         %  status = repmat([this.dnaABoxStatus_NotBound this.dnaABoxStatus_NotExist], size(this.dnaABoxStartPositions, 1), 1);
<a name="l01091"></a>01091         %  status(reshape(this.chromosome.isRegionPolymerized(positionsStrands, this.enzymeDNAFootprints(this.enzymeIndexs_DnaA_1mer_ATP)), [], 2)) = this.dnaABoxStatus_NotBound;
<a name="l01092"></a>01092         function status = calculateDnaABoxStatus(this)
<a name="l01093"></a>01093             %starting positions and strands of DnaA boxes
<a name="l01094"></a>01094             positionsStrands = [repmat(this.dnaABoxStartPositions, 2, 1) reshape(repmat([1 3], size(this.dnaABoxStartPositions, 1), 1), [], 1)];
<a name="l01095"></a>01095                         
<a name="l01096"></a>01096             %initialize status
<a name="l01097"></a>01097             status = repmat(this.dnaABoxStatus_NotBound, size(this.dnaABoxStartPositions, 1), 2);
<a name="l01098"></a>01098             
<a name="l01099"></a>01099             %find polymerized sites
<a name="l01100"></a>01100             [starts1, lengths1] = find(this.chromosome.polymerizedRegions(:, 3));
<a name="l01101"></a>01101             starts2 = find(this.chromosome.polymerizedRegions(:, 4));
<a name="l01102"></a>01102             if isempty(starts1)
<a name="l01103"></a>01103                 if isempty(starts2)
<a name="l01104"></a>01104                     status(:, 2) = this.dnaABoxStatus_NotExist;
<a name="l01105"></a>01105                 else
<a name="l01106"></a>01106                     status(this.dnaABoxStartPositions &lt; starts2(end), 2) = this.dnaABoxStatus_NotExist;
<a name="l01107"></a>01107                 end
<a name="l01108"></a>01108             else
<a name="l01109"></a>01109                 if isempty(starts2)
<a name="l01110"></a>01110                     status(this.dnaABoxStartPositions &gt; starts1(1), 2) = this.dnaABoxStatus_NotExist;
<a name="l01111"></a>01111                 else
<a name="l01112"></a>01112                     status(this.dnaABoxStartPositions &gt; starts1(1) + lengths1(1) &amp; this.dnaABoxStartPositions &lt; starts2(end), 2) = this.dnaABoxStatus_NotExist;
<a name="l01113"></a>01113                 end
<a name="l01114"></a>01114             end
<a name="l01115"></a>01115             
<a name="l01116"></a>01116             %find bound sites
<a name="l01117"></a>01117             boundComplexs = reshape(this.chromosome.complexBoundSites(positionsStrands), [], 2);
<a name="l01118"></a>01118             status(ismembc(boundComplexs, this.enzymeGlobalIndexs(this.enzymeIndexs_DnaA_Nmer_ATP))) = this.dnaABoxStatus_DnaAATPBound;
<a name="l01119"></a>01119             status(ismembc(boundComplexs, this.enzymeGlobalIndexs(this.enzymeIndexs_DnaA_Nmer_ADP))) = this.dnaABoxStatus_DnaAADPBound;
<a name="l01120"></a>01120         end
<a name="l01121"></a>01121     end
<a name="l01122"></a>01122 end
</pre></div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="_replication_initiation_8m.html">ReplicationInitiation.m</a>      </li>

    <li class="footer">Generated on Wed Feb 8 2012 21:42:32 for Whole Cell Simulation by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
