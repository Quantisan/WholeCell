<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of Chromosome</title>
  <meta name="keywords" content="Chromosome">
  <meta name="description" content="Chromosome">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../../../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../../../../../../index.html">Home</a> &gt;  <a href="../../../../../../../index.html">simulation</a> &gt; <a href="#">src</a> &gt; <a href="#">+edu</a> &gt; <a href="#">+stanford</a> &gt; <a href="#">+covert</a> &gt; <a href="#">+cell</a> &gt; <a href="../index.html">+sim</a> &gt; <a href="index.html">+state</a> &gt; Chromosome.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../../../../../../index.html"><img alt="<" border="0" src="../../../../../../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for simulation/src/+edu/+stanford/+covert/+cell/+sim/+state&nbsp;<img alt=">" border="0" src="../../../../../../../../right.png"></a></td></tr></table>-->

<h1>Chromosome
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../../../../../up.png"></a></h2>
<div class="box"><strong>Chromosome</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../../../../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">Chromosome
 Integration point for processes which interact with specific
 positions/strands of the cell's chromosome(s).
 - Represents the portion of chromosome(s) accessible to enzymes. That is
   positions/strands which are NOT
   - damaged in any way (no gap sites, abasic sites, damaged
     sugar-phosphates, damaged bases, cross links, strand breaks,
     or Holliday junctions)
   - stably bound by enzymes
   - single stranded

 Terminology:
 ==================
         Site  single base/bond of chromosomes, indicated by strand index and
               number of bases/bonds along 5'-&gt;3' strand from ORI [position X
               strand]
       Region  contiguous set of bases/bonds of chromosomes, indicated by start
               and end positions (bases/bonds along 5'-&gt;3' strand from ORI and
               strand (positive/negative)
   Accessible  polymerized, not bound by protein, and not damaged
 Inaccessible  not polymerized, bound by protein, or damaged

 Author: Jonathan Karr, jkarr@stanford.edu
 Affiliation: Covert Lab, Department of Bioengineering, Stanford University
 Last Updated: 9/12/2010</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../../../../../matlabicon.gif)">
<li><a href="Chromosome.html" class="code" title="">Chromosome</a>	Chromosome</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../../../../../../matlabicon.gif)">
<li><a href="Chromosome.html" class="code" title="">Chromosome</a>	Chromosome</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../../../../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../../../../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function this = Chromosome(wholeCellModelID, name)</a></li><li><a href="#_sub2" class="code">function storeObjectReferences(this, simulation)</a></li><li><a href="#_sub3" class="code">function initializeConstants(this, knowledgeBase, simulation)</a></li><li><a href="#_sub4" class="code">function allocateMemory(this, numTimePoints)</a></li><li><a href="#_sub5" class="code">function initialize(this)</a></li><li><a href="#_sub6" class="code">function [tfs, idxs, positionsStrands, lengths] = sampleAccessibleRegions(this,</a></li><li><a href="#_sub7" class="code">function positionsStrands = sampleAccessibleSites(this, prob, nSites, seq)</a></li><li><a href="#_sub8" class="code">function [tfs, idxs, positionsStrands, lengths] = isRegionAccessible(this,</a></li><li><a href="#_sub9" class="code">function [tfs, idxs, positionsStrands, lengths] = isRegionSingleStranded(this, positionsStrands, lengths, returnExtent)</a></li><li><a href="#_sub10" class="code">function [tfs, idxs, positionsStrands, lengths] = isRegionDoubleStranded(this, positionsStrands, lengths, returnExtent, checkRegionSupercoiled)</a></li><li><a href="#_sub11" class="code">function [tfs, idxs, positionsStrands, lengths] = isRegionPolymerized(this,</a></li><li><a href="#_sub12" class="code">function [tfs, idxs, positionsStrands, lengths] = isRegionNotPolymerized(this, positionsStrands, lengths, returnExtent)</a></li><li><a href="#_sub13" class="code">function [tfs, idxs, positionsStrands, lengths, monomers, complexs] = isRegionProteinFree(this,</a></li><li><a href="#_sub14" class="code">function [tfs, idxs, positionsStrands, lengths] = isRegionUndamaged(this,</a></li><li><a href="#_sub15" class="code">function varargout = getStrandView(this, outputs)</a></li><li><a href="#_sub16" class="code">function [footprint, footprint3Prime, footprint5Prime, bindingStrandedness, regionStrandedness] = getDNAFootprint(this, monomers, complexs)</a></li><li><a href="#_sub17" class="code">function [releasableMonomerIndexs, releasableComplexIndexs] = getReleasableProteins(this, bindingMonomers, bindingComplexs)</a></li><li><a href="#_sub18" class="code">function [rgnPosStrnds, rgnLens] = getAccessibleRegions(this, monomerIdx, complexIdx, checkRegionSupercoiled)</a></li><li><a href="#_sub19" class="code">function value = getDamagedSites(this, includeBases, includeBonds, includeBase5Prime, includeBond5Prime, includeBase3Prime, includeBond3Prime, includeM6AD)</a></li><li><a href="#_sub20" class="code">function [unmethylatedSites, hemimethylatedSites, methylatedSites, cleavedSites, inaccessibleRegions] = rmStatus(this,</a></li><li><a href="#_sub21" class="code">function sideEffects = setRegionUnwound(this, positions, lengths)</a></li><li><a href="#_sub22" class="code">function spmat = shiftStrandToNewChromosome(~, spmat, pos, len, oldStrd, newStrd)</a></li><li><a href="#_sub23" class="code">function sideEffects = setRegionPolymerized(this, positionsStrands, lengths)</a></li><li><a href="#_sub24" class="code">function [releasedMonomers, releasedComplexs, sideEffects, tfs, idxs, positionsStrands, lengths] =</a></li><li><a href="#_sub25" class="code">function [releasedMonomers, releasedComplexs, sideEffects] =</a></li><li><a href="#_sub26" class="code">function [releasedMonomers, releasedComplexs, sideEffects] = setRegionProteinUnbound(this,</a></li><li><a href="#_sub27" class="code">function [positionsStrands, sideEffects] = stochasticallySetProteinUnbound(this, monomerIndex, complexIndex,</a></li><li><a href="#_sub28" class="code">function updateExternalState(this, ~, ~, unbindingComplexSubs, unbindingComplexVals, proteinIsDegraded)</a></li><li><a href="#_sub29" class="code">function [positionsStrands, sideEffects] = setSiteDamaged(this,</a></li><li><a href="#_sub30" class="code">function mergeOwnAdjacentRegions(this)</a></li><li><a href="#_sub31" class="code">function polymerizedRegions = mergeAdjacentRegions(~, polymerizedRegions)</a></li><li><a href="#_sub32" class="code">function [rgnPosStrnds, rgnLens] = excludeRegions(this, incPosStrnds, incLens, excPosStrnds, excLens)</a></li><li><a href="#_sub33" class="code">function [posStrnds, lens] = intersectRegions(this, posStrndsA, lensA, posStrndsB, lensB)</a></li><li><a href="#_sub34" class="code">function [posStrnds, lens] = splitRegions(~, rgnPosStrnds, rgnLens, splitLen)</a></li><li><a href="#_sub35" class="code">function [posStrnds, lens] = splitOverOriC(this, posStrnds, lens)</a></li><li><a href="#_sub36" class="code">function [posStrnds, lens] = joinSplitOverOriCRegions(this, posStrnds, lens)</a></li><li><a href="#_sub37" class="code">function [posStrnds, lens] = joinSplitRegions(this, posStrnds, lens)</a></li><li><a href="#_sub38" class="code">function [idxs, newIdxs] = excludeOverlappingRegions(this,</a></li><li><a href="#_sub39" class="code">function set.polymerizedRegions(this, value)</a></li><li><a href="#_sub40" class="code">function set.linkingNumbers(this, value)</a></li><li><a href="#_sub41" class="code">function set.monomerBoundSites(this, value)</a></li><li><a href="#_sub42" class="code">function set.complexBoundSites(this, value)</a></li><li><a href="#_sub43" class="code">function set.gapSites(this, value)</a></li><li><a href="#_sub44" class="code">function set.abasicSites(this, value)</a></li><li><a href="#_sub45" class="code">function set.damagedSugarPhosphates(this, value)</a></li><li><a href="#_sub46" class="code">function set.damagedBases(this, value)</a></li><li><a href="#_sub47" class="code">function set.intrastrandCrossLinks(this, value)</a></li><li><a href="#_sub48" class="code">function set.strandBreaks(this, value)</a></li><li><a href="#_sub49" class="code">function set.hollidayJunctions(this, value)</a></li><li><a href="#_sub50" class="code">function set.segregated(this, value)</a></li><li><a href="#_sub51" class="code">function invalidate(this)</a></li><li><a href="#_sub52" class="code">function value = get.unpolymerizedRegions(this)</a></li><li><a href="#_sub53" class="code">function value = calcUnpolymerizedRegions(this)</a></li><li><a href="#_sub54" class="code">function value = get.singleStrandedRegions(this)</a></li><li><a href="#_sub55" class="code">function value = calcSingleStrandedRegions(this)</a></li><li><a href="#_sub56" class="code">function value = get.doubleStrandedRegions(this)</a></li><li><a href="#_sub57" class="code">function value = calcDoubleStrandedRegions(this)</a></li><li><a href="#_sub58" class="code">function value = get.geneCopyNumbers(this)</a></li><li><a href="#_sub59" class="code">function value = calcGeneCopyNumbers(this)</a></li><li><a href="#_sub60" class="code">function value = get.ploidy(this)</a></li><li><a href="#_sub61" class="code">function value = calcPloidy(this)</a></li><li><a href="#_sub62" class="code">function value = get.polymerizedGenes(this)</a></li><li><a href="#_sub63" class="code">function value = calcPolymerizedGenes(this)</a></li><li><a href="#_sub64" class="code">function value = get.transcriptionUnitCopyNumbers(this)</a></li><li><a href="#_sub65" class="code">function value = getTranscriptionUnitCopyNumbers(this)</a></li><li><a href="#_sub66" class="code">function value = get.polymerizedTranscriptionUnits(this)</a></li><li><a href="#_sub67" class="code">function value = calcPolymerizedTranscriptionUnits(this)</a></li><li><a href="#_sub68" class="code">function value = get.geneCopyNumbers_Accessible(this)</a></li><li><a href="#_sub69" class="code">function value = calcCopyNumbers_Accessible(this)</a></li><li><a href="#_sub70" class="code">function value = get.transcriptionUnitCopyNumbers_Accessible(this)</a></li><li><a href="#_sub71" class="code">function value = calcTranscriptionUnitCopyNumbers_Accessible(this)</a></li><li><a href="#_sub72" class="code">function value = get.accessibleGenes(this)</a></li><li><a href="#_sub73" class="code">function value = calcAccessibleGenes(this)</a></li><li><a href="#_sub74" class="code">function value = get.accessibleTranscriptionUnits(this)</a></li><li><a href="#_sub75" class="code">function value = calcAccessibleTranscriptionUnits(this)</a></li><li><a href="#_sub76" class="code">function value = get.strandBreakClassification(this)</a></li><li><a href="#_sub77" class="code">function value = calcStrandBreakClassification(this)</a></li><li><a href="#_sub78" class="code">function value = get.linkingNumbers_minFreeEnergy(this)</a></li><li><a href="#_sub79" class="code">function value = calcLinkingNumbers_minFreeEnergy(this)</a></li><li><a href="#_sub80" class="code">function value = get.supercoils(this)</a></li><li><a href="#_sub81" class="code">function value = calcSupercoils(this)</a></li><li><a href="#_sub82" class="code">function value = get.superhelicalDensity(this)</a></li><li><a href="#_sub83" class="code">function value = calcSuperhelicalDensity(this)</a></li><li><a href="#_sub84" class="code">function value = get.supercoiled(this)</a></li><li><a href="#_sub85" class="code">function value = calcSupercoiled(this)</a></li><li><a href="#_sub86" class="code">function value = get.damagedSites(this)</a></li><li><a href="#_sub87" class="code">function value = calcDamagedSites(this)</a></li><li><a href="#_sub88" class="code">function value = get.damagedSites_shifted_incm6AD(this)</a></li><li><a href="#_sub89" class="code">function value = calcDamagedSites_shifted_incm6AD(this)</a></li><li><a href="#_sub90" class="code">function value = get.damagedSites_nonRedundant(this)</a></li><li><a href="#_sub91" class="code">function value = calcDamagedSites_nonRedundant(this)</a></li><li><a href="#_sub92" class="code">function value = get.damagedSites_excm6AD(this)</a></li><li><a href="#_sub93" class="code">function value = calcDamagedSites_excm6AD(this)</a></li><li><a href="#_sub94" class="code">function value = get.gapSites3(this)</a></li><li><a href="#_sub95" class="code">function value = calcGapSites3(this)</a></li><li><a href="#_sub96" class="code">function value = get.gapSites5(this)</a></li><li><a href="#_sub97" class="code">function value = calcGapSites5(this)</a></li><li><a href="#_sub98" class="code">function value = get.abasicSites3(this)</a></li><li><a href="#_sub99" class="code">function value = calcAbasicSites3(this)</a></li><li><a href="#_sub100" class="code">function value = get.abasicSites5(this)</a></li><li><a href="#_sub101" class="code">function value = calcAbasicSites5(this)</a></li><li><a href="#_sub102" class="code">function value = get.damagedSugarPhosphates3(this)</a></li><li><a href="#_sub103" class="code">function value = calcDamagedSugarPhosphates3(this)</a></li><li><a href="#_sub104" class="code">function value = get.damagedSugarPhosphates5(this)</a></li><li><a href="#_sub105" class="code">function value = calcDamagedSugarPhosphates5(this)</a></li><li><a href="#_sub106" class="code">function value = get.damagedBases3(this)</a></li><li><a href="#_sub107" class="code">function value = calcDamagedBases3(this)</a></li><li><a href="#_sub108" class="code">function value = get.damagedBases5(this)</a></li><li><a href="#_sub109" class="code">function value = calcDamagedBases5(this)</a></li><li><a href="#_sub110" class="code">function value = get.intrastrandCrossLinks3(this)</a></li><li><a href="#_sub111" class="code">function value = calcIntrastrandCrossLinks3(this)</a></li><li><a href="#_sub112" class="code">function value = get.intrastrandCrossLinks5(this)</a></li><li><a href="#_sub113" class="code">function value = calcIntrastrandCrossLinks5(this)</a></li><li><a href="#_sub114" class="code">function value = get.strandBreaks3(this)</a></li><li><a href="#_sub115" class="code">function value = calcStrandBreaks3(this)</a></li><li><a href="#_sub116" class="code">function value = get.strandBreaks5(this)</a></li><li><a href="#_sub117" class="code">function value = calcStrandBreaks5(this)</a></li><li><a href="#_sub118" class="code">function value = get.hollidayJunctions3(this)</a></li><li><a href="#_sub119" class="code">function value = calcHollidayJunctions3(this)</a></li><li><a href="#_sub120" class="code">function value = get.hollidayJunctions5(this)</a></li><li><a href="#_sub121" class="code">function value = calcHollidayJunctions5(this)</a></li><li><a href="#_sub122" class="code">function value = get.singleStrandBreaks(this)</a></li><li><a href="#_sub123" class="code">function value = calcSingleStrandBreaks(this)</a></li><li><a href="#_sub124" class="code">function value = get.doubleStrandBreaks(this)</a></li><li><a href="#_sub125" class="code">function value = calcDoubleStrandBreaks(this)</a></li><li><a href="#_sub126" class="code">function value = get.restrictableMunIRMSites(this)</a></li><li><a href="#_sub127" class="code">function value = get.hemiunmethylatedMunIRMSites(this)</a></li><li><a href="#_sub128" class="code">function value = calcRestrictableMunIRMSites(this)</a></li><li><a href="#_sub129" class="code">function value = calcHemiunmethylatedMunIRMSites(this)</a></li><li><a href="#_sub130" class="code">function value = get.dryWeight(this)</a></li><li><a href="#_sub131" class="code">function value = calcDryWeight(this)</a></li><li><a href="#_sub132" class="code">function value = shiftCircularSparseMatBase3Prime(sparseMat, varargin)</a></li><li><a href="#_sub133" class="code">function value = shiftCircularSparseMatBase5Prime(sparseMat, varargin)</a></li><li><a href="#_sub134" class="code">function value = shiftCircularSparseMatBond3Prime(sparseMat, varargin)</a></li><li><a href="#_sub135" class="code">function value = unshiftCircularSparseMatBond3Prime(sparseMat, varargin)</a></li><li><a href="#_sub136" class="code">function value = shiftCircularSparseMatBond5Prime(sparseMat, varargin)</a></li><li><a href="#_sub137" class="code">function value = unshiftCircularSparseMatBond5Prime(sparseMat, varargin)</a></li><li><a href="#_sub138" class="code">function positionsStrands = shiftPositionsStrandsBase3Prime(positionsStrands, lengths)</a></li><li><a href="#_sub139" class="code">function positionsStrands = shiftPositionsStrandsBase5Prime(positionsStrands, lengths)</a></li><li><a href="#_sub140" class="code">function positionsStrands = shiftPositionsStrandsBond3Prime(positionsStrands, lengths)</a></li><li><a href="#_sub141" class="code">function positionsStrands = unshiftPositionsStrandsBond3Prime(positionsStrands, lengths)</a></li><li><a href="#_sub142" class="code">function positionsStrands = shiftPositionsStrandsBond5Prime(positionsStrands, lengths)</a></li><li><a href="#_sub143" class="code">function positionsStrands = unshiftPositionsStrandsBond5Prime(positionsStrands, lengths)</a></li><li><a href="#_sub144" class="code">function [footprint3Prime, footprint5Prime] = calculateFootprintOverhangs(footprint)</a></li><li><a href="#_sub145" class="code">function disp(this)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">%Chromosome</span>
0002 <span class="comment">% Integration point for processes which interact with specific</span>
0003 <span class="comment">% positions/strands of the cell's chromosome(s).</span>
0004 <span class="comment">% - Represents the portion of chromosome(s) accessible to enzymes. That is</span>
0005 <span class="comment">%   positions/strands which are NOT</span>
0006 <span class="comment">%   - damaged in any way (no gap sites, abasic sites, damaged</span>
0007 <span class="comment">%     sugar-phosphates, damaged bases, cross links, strand breaks,</span>
0008 <span class="comment">%     or Holliday junctions)</span>
0009 <span class="comment">%   - stably bound by enzymes</span>
0010 <span class="comment">%   - single stranded</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% Terminology:</span>
0013 <span class="comment">% ==================</span>
0014 <span class="comment">%         Site  single base/bond of chromosomes, indicated by strand index and</span>
0015 <span class="comment">%               number of bases/bonds along 5'-&gt;3' strand from ORI [position X</span>
0016 <span class="comment">%               strand]</span>
0017 <span class="comment">%       Region  contiguous set of bases/bonds of chromosomes, indicated by start</span>
0018 <span class="comment">%               and end positions (bases/bonds along 5'-&gt;3' strand from ORI and</span>
0019 <span class="comment">%               strand (positive/negative)</span>
0020 <span class="comment">%   Accessible  polymerized, not bound by protein, and not damaged</span>
0021 <span class="comment">% Inaccessible  not polymerized, bound by protein, or damaged</span>
0022 <span class="comment">%</span>
0023 <span class="comment">% Author: Jonathan Karr, jkarr@stanford.edu</span>
0024 <span class="comment">% Affiliation: Covert Lab, Department of Bioengineering, Stanford University</span>
0025 <span class="comment">% Last Updated: 9/12/2010</span>
0026 
0027 <span class="comment">%TODO</span>
0028 <span class="comment">%- more precise ignoreDamageFilter</span>
0029 <span class="comment">%- include gapsites in isRegionPolymerized</span>
0030 classdef <a href="Chromosome.html" class="code" title="">Chromosome</a> &lt; edu.stanford.covert.cell.sim.CellState
0031     <span class="comment">%constants</span>
0032     properties (Constant)
0033         optionNames             = {   <span class="comment">%names of properties that are options</span>
0034             <span class="string">'verbosity'</span>;
0035             <span class="string">'seed'</span>;
0036             };
0037         fixedConstantNames      = {   <span class="comment">%names of process properties that are considered fixed constants</span>
0038             <span class="string">'doubleStrandBreakSeparation'</span>;
0039             <span class="string">'strandBreakClassification_doubleStrandBreakSeparation'</span>;
0040             <span class="string">'strandBreakClassification_segmentLength'</span>;
0041             <span class="string">'sequence'</span>;
0042             <span class="string">'sequenceLen'</span>;
0043             <span class="string">'oriCPosition'</span>;
0044             <span class="string">'terCPosition'</span>;
0045             <span class="string">'transcriptionUnitStartCoordinates'</span>;
0046             <span class="string">'transcriptionUnitLengths'</span>;
0047             <span class="string">'transcriptionUnitStrands'</span>;
0048             <span class="string">'monomerDNAFootprints'</span>;
0049             <span class="string">'complexDNAFootprints'</span>;
0050             <span class="string">'monomerDNAFootprintBindingStrandedness'</span>;
0051             <span class="string">'complexDNAFootprintBindingStrandedness'</span>;
0052             <span class="string">'monomerDNAFootprintRegionStrandedness'</span>;
0053             <span class="string">'complexDNAFootprintRegionStrandedness'</span>;
0054             <span class="string">'reactionBoundMonomer'</span>;
0055             <span class="string">'reactionBoundComplex'</span>;
0056             <span class="string">'reactionMonomerCatalysisMatrix'</span>;
0057             <span class="string">'reactionComplexCatalysisMatrix'</span>;
0058             <span class="string">'reactionThresholds'</span>;
0059             <span class="string">'relaxedBasesPerTurn'</span>;
0060             <span class="string">'equilibriumSuperhelicalDensity'</span>;
0061             <span class="string">'supercoiledSuperhelicalDensityTolerance'</span>;
0062             };
0063         fittedConstantNames = {};  <span class="comment">%names of process properties that are considered fitted constants, and should be stored with the simulation as such</span>
0064         stateNames = {             <span class="comment">%names of properties which are part of the simulation's state</span>
0065             <span class="string">'polymerizedRegions'</span>;
0066             <span class="string">'linkingNumbers'</span>;
0067             <span class="string">'monomerBoundSites'</span>;
0068             <span class="string">'complexBoundSites'</span>;
0069             <span class="string">'gapSites'</span>;
0070             <span class="string">'abasicSites'</span>;
0071             <span class="string">'damagedSugarPhosphates'</span>;
0072             <span class="string">'damagedBases'</span>;
0073             <span class="string">'intrastrandCrossLinks'</span>;
0074             <span class="string">'strandBreaks'</span>;
0075             <span class="string">'hollidayJunctions'</span>;
0076             <span class="string">'segregated'</span>;
0077             };
0078         dependentStateNames     = {   <span class="comment">%names of properties which can be calculated from the simulation's state</span>
0079             <span class="comment">%'unpolymerizedRegions'</span>
0080             <span class="string">'singleStrandedRegions'</span>
0081             <span class="string">'doubleStrandedRegions'</span>
0082             <span class="string">'geneCopyNumbers'</span>
0083             <span class="comment">%'polymerizedGenes'</span>
0084             <span class="string">'transcriptionUnitCopyNumbers'</span>
0085             <span class="comment">%'polymerizedTranscriptionUnits'</span>
0086             <span class="comment">%'geneCopyNumbers_Accessible'</span>
0087             <span class="comment">%'transcriptionUnitCopyNumbers_Accessible'</span>
0088             <span class="comment">%'accessibleGenes'</span>
0089             <span class="comment">%'accessibleTranscriptionUnits'</span>
0090             <span class="string">'ploidy'</span>
0091             <span class="comment">%'linkingNumbers_minFreeEnergy'</span>
0092             <span class="comment">%'supercoils'</span>
0093             <span class="string">'superhelicalDensity'</span>
0094             <span class="comment">%'supercoiled'</span>
0095             <span class="comment">%'damagedSites'</span>
0096             <span class="comment">%'damagedSites_shifted_incm6AD'</span>
0097             <span class="comment">%'damagedSites_nonRedundant'</span>
0098             <span class="comment">%'damagedSites_excm6AD'</span>
0099             <span class="comment">%'gapSites3'</span>
0100             <span class="comment">%'gapSites5'</span>
0101             <span class="comment">%'abasicSites3'</span>
0102             <span class="comment">%'abasicSites5'</span>
0103             <span class="comment">%'damagedSugarPhosphates3'</span>
0104             <span class="comment">%'damagedSugarPhosphates5'</span>
0105             <span class="comment">%'damagedBases3'</span>
0106             <span class="comment">%'damagedBases5'</span>
0107             <span class="comment">%'strandBreaks3'</span>
0108             <span class="comment">%'strandBreaks5'</span>
0109             <span class="comment">%'intrastrandCrossLinks3'</span>
0110             <span class="comment">%'intrastrandCrossLinks5'</span>
0111             <span class="comment">%'hollidayJunctions3'</span>
0112             <span class="comment">%'hollidayJunctions5'</span>
0113             <span class="comment">%'singleStrandBreaks'</span>
0114             <span class="comment">%'doubleStrandBreaks'</span>
0115             <span class="comment">%'strandBreakClassification'</span>
0116             <span class="comment">%'restrictableMunIRMSites'</span>
0117             <span class="comment">%'hemiunmethylatedMunIRMSites'</span>
0118             };
0119         
0120         nCompartments = 4;              <span class="comment">%number of strands</span>
0121         nChromosomes = 2;               <span class="comment">%number of chromosomes</span>
0122         
0123         strandIndexs_positive    = [1; 3]; <span class="comment">%5'-&gt;3' strands</span>
0124         strandIndexs_negative    = [2; 4]; <span class="comment">%3'-&gt;5' strands</span>
0125         
0126         strandIndexs_ch1         = [1; 2]; <span class="comment">%chromosome 1 strands; sort to &quot;mother&quot; cell during division</span>
0127         strandIndexs_ch2         = [3; 4]; <span class="comment">%chromosome 2 strands; sort to &quot;daughter&quot; cell during division</span>
0128         
0129         strandIndexs_template    = [1; 4]; <span class="comment">%strands which are serving as templates for replication</span>
0130         strandIndexs_nonTemplate = [2; 3]; <span class="comment">%strands which are not serving as templates for replication</span>
0131         
0132         strandIndexs_old         = [1; 4]; <span class="comment">%strands which (at end the end of the cell cycle) were present at the beginning of the cell cycle</span>
0133         strandIndexs_new         = [2; 3]; <span class="comment">%strands which (at end the end of the cell cycle) were synthesized during the cell cycle</span>
0134         
0135         dnaStrandedness_ssDNA = 1; <span class="comment">%values of ssDNA footprints within *DNAFootprintStrandedness</span>
0136         dnaStrandedness_dsDNA = 2; <span class="comment">%values of dsDNA footprints within *DNAFootprintStrandedness</span>
0137         dnaStrandedness_xsDNA = 3; <span class="comment">%values of ssDNA/dsDNA footprints within *DNAFootprintStrandedness</span>
0138         
0139         strandBreakClassification_index_NB    = 1; <span class="comment">%index within strandBreakClassification of NB</span>
0140         strandBreakClassification_index_SSB   = 2; <span class="comment">%index within strandBreakClassification of SSB</span>
0141         strandBreakClassification_index_SSB_  = 3; <span class="comment">%index within strandBreakClassification of SSB+</span>
0142         strandBreakClassification_index_2SSB  = 4; <span class="comment">%index within strandBreakClassification of 2SSB</span>
0143         strandBreakClassification_index_DSB   = 5; <span class="comment">%index within strandBreakClassification of DSB</span>
0144         strandBreakClassification_index_DSB_  = 6; <span class="comment">%index within strandBreakClassification of DSB+</span>
0145         strandBreakClassification_index_DSB__ = 7; <span class="comment">%index within strandBreakClassification of DSB++</span>
0146     <span class="keyword">end</span>
0147     
0148     <span class="comment">%computed ids, names, indices</span>
0149     properties
0150         transcriptionUnitWholeCellModelIDs     <span class="comment">%whole cell model IDs of transcription units</span>
0151         transcriptionUnitNames                 <span class="comment">%names of transcription units</span>
0152         
0153         monomerIndexs_ligase                   <span class="comment">%index within ProteinMonomer.matureIndexs of DNA ligase</span>
0154         complexIndexs_dnaPolymerase            <span class="comment">%index within ProteinComplex.matureIndexs of DNA polymerase</span>
0155         complexIndexs_DisA                     <span class="comment">%index within ProteinComplex.matureIndexs of DisA</span>
0156         complexIndexs_rnaPolymerase            <span class="comment">%index within ProteinComplex.matureIndexs of RNA polymerase</span>
0157         monomerIndexs_replisome                <span class="comment">%index within ProteinMonomer.matureIndexs of replication machinery</span>
0158         complexIndexs_replisome                <span class="comment">%index within ProteinComplex.matureIndexs of replication machinery</span>
0159         
0160         reactionWholeCellModelIDs              <span class="comment">%IDs of bound protein release reactions</span>
0161         reactionNames                          <span class="comment">%names of bound protein release reactions</span>
0162     <span class="keyword">end</span>
0163     
0164     <span class="comment">%constants</span>
0165     properties
0166         doubleStrandBreakSeparation                           = 1;   <span class="comment">%max separtion in bases between SSB's to be consider a DBSB</span>
0167         strandBreakClassification_doubleStrandBreakSeparation = 10;  <span class="comment">%maximum separation of single strand breaks which is considered double strand break [PUB_0486]</span>
0168         strandBreakClassification_segmentLength               = 216; <span class="comment">%length of segments for which SSB/SSB+/2SSB/DSB/DSB+/DSB++ classification applies [PUB_0486]</span>
0169         
0170         sequence                                <span class="comment">%chromosome sequence</span>
0171         sequenceLen                             <span class="comment">%chromosome sequence length (number of bases)</span>
0172         sequenceGCContent                       <span class="comment">%chromosome G/C content</span>
0173         oriCPosition                            <span class="comment">%oriC position</span>
0174         terCPosition                            <span class="comment">%terC position</span>
0175         
0176         transcriptionUnitStartCoordinates       <span class="comment">%genomic coordinates of transcription units</span>
0177         transcriptionUnitLengths                <span class="comment">%genomic coordinates of transcription units</span>
0178         transcriptionUnitStrands                <span class="comment">%genomic direction of transcription units</span>
0179         
0180         monomerDNAFootprints                    <span class="comment">%number of bases of DNA each monomer occupies when bound to DNA</span>
0181         complexDNAFootprints                    <span class="comment">%number of bases of DNA each complex occupies when bound to DNA</span>
0182         monomerDNAFootprintBindingStrandedness  <span class="comment">%enumeration of binding strandedness of DNA footprints (ssDNA, dsDNA, ssDNA/dsDNA) using this.dnaStrandedness_*sDNA</span>
0183         complexDNAFootprintBindingStrandedness  <span class="comment">%enumeration of binding strandedness of DNA footprints (ssDNA, dsDNA, ssDNA/dsDNA) using this.dnaStrandedness_*sDNA</span>
0184         monomerDNAFootprintRegionStrandedness   <span class="comment">%enumeration of region strandedness of DNA footprints (ssDNA, dsDNA, ssDNA/dsDNA) using this.dnaStrandedness_*sDNA</span>
0185         complexDNAFootprintRegionStrandedness   <span class="comment">%enumeration of region strandedness of DNA footprints (ssDNA, dsDNA, ssDNA/dsDNA) using this.dnaStrandedness_*sDNA</span>
0186         
0187         reactionBoundMonomer                    <span class="comment">%protein monomer released by each reaction [reactions X 1]</span>
0188         reactionBoundComplex                    <span class="comment">%protein complex released by each reaction [reactions X 1]</span>
0189         reactionMonomerCatalysisMatrix          <span class="comment">%monomers required to catalyze the release of a bound protein [reactions X monomers]</span>
0190         reactionComplexCatalysisMatrix          <span class="comment">%complexs required to catalyze the release of a bound protein [reactions X complexs]</span>
0191         reactionThresholds                      <span class="comment">%number of proteins required to catalyze each release reaction [reactions X 1]</span>
0192         
0193         relaxedBasesPerTurn                     <span class="comment">%Number of dna bases per turn for the relaxed LK calculation (10.5)</span>
0194         equilibriumSuperhelicalDensity          <span class="comment">%equilibrium superhelical density; also known as specific linking difference / \sigma_{sp} [-0.06; PUB_0749]</span>
0195         supercoiledSuperhelicalDensityTolerance <span class="comment">%tolerance in superhelical density to be considered supercoiled (0.1)</span>
0196     <span class="keyword">end</span>
0197     
0198     <span class="comment">%state</span>
0199     properties
0200         polymerizedRegions       <span class="comment">%integers [positions x strands] indicating the start positions of polymerized regions of strands and their lengths</span>
0201         linkingNumbers           <span class="comment">%integers [positions x strands] indicating the current linking number of each double-stranded region</span>
0202         
0203         monomerBoundSites        <span class="comment">%indices [positions x strands] indicating start positions of protein monomers bound to DNA bases</span>
0204         complexBoundSites        <span class="comment">%indices [positions x strands] indicating start positions of macromolecular complexes bound to DNA bases</span>
0205         
0206         gapSites                 <span class="comment">%boolean [positions x strands] indicating positions of gap sites</span>
0207         abasicSites              <span class="comment">%boolean [positions x strands] indicating positions of abasic sites</span>
0208         damagedSugarPhosphates   <span class="comment">%indices [positions x strands] indicating metabolite identity of damaged sugar-phosphates</span>
0209         damagedBases             <span class="comment">%indices [positions x strands] indicating metabolite identity of damaged bases</span>
0210         intrastrandCrossLinks    <span class="comment">%boolean [positions x strands] indicating metabolite identity of intrastrand cross links in DNA</span>
0211         strandBreaks             <span class="comment">%boolean [positions x strands] indicating positions of strand breaks in strands of DNA</span>
0212         hollidayJunctions        <span class="comment">%boolean [positions x strands] indicating positions of holliday junctions</span>
0213         
0214         segregated               <span class="comment">%boolean indicating whether or not the chromsomes are segregated</span>
0215     <span class="keyword">end</span>
0216     
0217     <span class="comment">%properties to keep track of whether or not the dependent properties need to</span>
0218     <span class="comment">%be recomputed</span>
0219     properties (SetAccess = protected)
0220         validated
0221         
0222         validated_polymerizedRegions
0223         validated_linkingNumbers
0224         validated_proteinBoundSites
0225         validated_damaged
0226         validated_gapSites
0227         validated_abasicSites
0228         validated_damagedSugarPhosphates
0229         validated_damagedBases
0230         validated_intrastrandCrossLinks
0231         validated_strandBreaks
0232         validated_hollidayJunctions
0233         validated_segregated
0234         
0235         validated_unpolymerizedRegions
0236         validated_singleStrandedRegions
0237         validated_doubleStrandedRegions
0238         validated_geneCopyNumbers
0239         validated_ploidy
0240         validated_polymerizedGenes
0241         validated_transcriptionUnitCopyNumbers
0242         validated_polymerizedTranscriptionUnits
0243         validated_geneCopyNumbers_Accessible
0244         validated_transcriptionUnitCopyNumbers_Accessible
0245         validated_accessibleGenes
0246         validated_accessibleTranscriptionUnits
0247         validated_linkingNumbers_minFreeEnergy
0248         validated_supercoils
0249         validated_superhelicalDensity
0250         validated_supercoiled
0251         validated_damagedSites
0252         validated_damagedSites_shifted_incm6AD
0253         validated_damagedSites_nonRedundant
0254         validated_damagedSites_excm6AD
0255         validated_gapSites3
0256         validated_gapSites5
0257         validated_abasicSites3
0258         validated_abasicSites5
0259         validated_damagedSugarPhosphates3
0260         validated_damagedSugarPhosphates5
0261         validated_damagedBases3
0262         validated_damagedBases5
0263         validated_strandBreaks3
0264         validated_strandBreaks5
0265         validated_intrastrandCrossLinks3
0266         validated_intrastrandCrossLinks5
0267         validated_hollidayJunctions3
0268         validated_hollidayJunctions5
0269         validated_singleStrandBreaks
0270         validated_doubleStrandBreaks
0271         validated_strandBreakClassification
0272         validated_munIRMSiteMethylationStatus
0273         validated_munIRMSiteRestrictionStatus
0274         validated_dryWeight
0275     <span class="keyword">end</span>
0276     
0277     <span class="comment">%dependent local state (implemented as dependent property for convenience)</span>
0278     properties (SetAccess = protected)
0279         unpolymerizedRegions         <span class="comment">%integers indicating the start positions of unpolymerized regions (ie. not yet replicated) of strands and their lengths</span>
0280         singleStrandedRegions
0281         doubleStrandedRegions
0282         geneCopyNumbers
0283         polymerizedGenes
0284         transcriptionUnitCopyNumbers
0285         polymerizedTranscriptionUnits
0286         geneCopyNumbers_Accessible
0287         transcriptionUnitCopyNumbers_Accessible
0288         accessibleGenes
0289         accessibleTranscriptionUnits
0290         ploidy
0291         
0292         linkingNumbers_minFreeEnergy <span class="comment">%free energy mininum linking number</span>
0293         supercoils                   <span class="comment">%difference between linkingNumbers and free energy mininum linking number</span>
0294         superhelicalDensity          <span class="comment">%supercoils / free energy minimum linking number</span>
0295         supercoiled                  <span class="comment">%boolean (1 x 2) indicating whether or not each chromosome is properly supercoiled (eg. within some tolerance of the free energy minimum)</span>
0296         
0297         damagedSites                 <span class="comment">%integers (genome length x 4) indicating identities of bases which are damaged or which are adjacent to damaged bonds</span>
0298         damagedSites_shifted_incm6AD <span class="comment">%integers (genome length x 4) indicating identities of damaged bases/sites</span>
0299         damagedSites_nonRedundant    <span class="comment">%integers (genome length x 4) indicating identities of damaged bases/sites</span>
0300         damagedSites_excm6AD         <span class="comment">%integers (genome length x 4) indicating identities of damaged bases/sites</span>
0301         gapSites3                    <span class="comment">%boolean (genome length x 4) indicating positions of gap sites 3' to bases</span>
0302         gapSites5                    <span class="comment">%boolean (genome length x 4) indicating positions of gap sites 5' to bases</span>
0303         abasicSites3                 <span class="comment">%boolean (genome length x 4) indicating positions of abasic sites 3' to bases</span>
0304         abasicSites5                 <span class="comment">%boolean (genome length x 4) indicating positions of abasic sites 5' to bases</span>
0305         damagedSugarPhosphates3      <span class="comment">%integers (genome length x 4) indicating indices of damaged sugar-phosphate 3' to bases</span>
0306         damagedSugarPhosphates5      <span class="comment">%integers (genome length x 4) indicating indices of damaged sugar-phosphate 5' to bases</span>
0307         damagedBases3                <span class="comment">%integers (genome length x 4) indicating indices of damaged bases 3' to bases</span>
0308         damagedBases5                <span class="comment">%integers (genome length x 4) indicating indices of damaged bases 5' to bases</span>
0309         strandBreaks3                <span class="comment">%boolean (genome length x 4) indicating positions of strand breaks 3' to bases</span>
0310         strandBreaks5                <span class="comment">%boolean (genome length x 4) indicating positions of strand breaks 5' to bases</span>
0311         intrastrandCrossLinks3       <span class="comment">%boolean (genome length x 4) indicating positions of intrastrand cross links 3' to bases</span>
0312         intrastrandCrossLinks5       <span class="comment">%boolean (genome length x 4) indicating positions of intrastrand cross links 5' to bases</span>
0313         hollidayJunctions3           <span class="comment">%boolean (genome length x 4) indicating positions of holliday junctions 3' to bases</span>
0314         hollidayJunctions5           <span class="comment">%boolean (genome length x 4) indicating positions of holliday junctions 5' to bases</span>
0315         
0316         singleStrandBreaks           <span class="comment">%boolean (genome length x 4) indicating positions of single strand breaks (strand breaks excluding double strand breaks and strand breaks adjacent to gapSites)</span>
0317         doubleStrandBreaks           <span class="comment">%boolean (genome length x 4) indicating positions of double strand breaks</span>
0318         strandBreakClassification
0319         
0320         restrictableMunIRMSites      <span class="comment">%boolean (genome length x 4) indicating positions of restrictable MunI R/M sites because they aren't methylated</span>
0321         hemiunmethylatedMunIRMSites  <span class="comment">%boolean (genome length x 4) indicating positions of hemi-unmethylated MunI R/M sites</span>
0322         
0323         dryWeight                    <span class="comment">%dry weight of this class' state properties</span>
0324     <span class="keyword">end</span>
0325     
0326     <span class="comment">%references to objects</span>
0327     properties
0328         compartment   <span class="comment">%compartments</span>
0329         gene          <span class="comment">%genes</span>
0330         
0331         metabolite    <span class="comment">%metabolites</span>
0332         transcript    <span class="comment">%transcript</span>
0333         rnaPolymerase <span class="comment">%RNA polymerase</span>
0334         
0335         dnaRepair     <span class="comment">%DNA repair process</span>
0336     <span class="keyword">end</span>
0337     
0338     <span class="comment">%constructor</span>
0339     methods
0340         <a name="_sub0" href="#_subfunctions" class="code">function this = Chromosome(wholeCellModelID, name)</a>
0341             this = this@edu.stanford.covert.cell.sim.CellState(wholeCellModelID, name);
0342         <span class="keyword">end</span>
0343     <span class="keyword">end</span>
0344     
0345     methods
0346         <a name="_sub1" href="#_subfunctions" class="code">function storeObjectReferences(this, simulation)</a>
0347             this.compartment = simulation.compartment;
0348             this.gene = simulation.gene;
0349             this.metabolite = simulation.state(<span class="string">'Metabolite'</span>);
0350             this.transcript = simulation.state(<span class="string">'Transcript'</span>);
0351             this.rnaPolymerase = simulation.state(<span class="string">'RNAPolymerase'</span>);
0352             this.dnaRepair = simulation.process(<span class="string">'DNARepair'</span>);
0353         <span class="keyword">end</span>
0354     <span class="keyword">end</span>
0355     
0356     methods
0357         <a name="_sub2" href="#_subfunctions" class="code">function initializeConstants(this, knowledgeBase, simulation)</a>
0358             this.initializeConstants@edu.stanford.covert.cell.sim.CellState(knowledgeBase, simulation);
0359             
0360             <span class="comment">%% import classes</span>
0361             import edu.stanford.covert.cell.sim.constant.ChromosomeSequence;
0362             
0363             <span class="comment">%% sequence</span>
0364             this.sequence = ChromosomeSequence(knowledgeBase.genome.sequence);
0365             this.sequenceLen = size(this.sequence, 1);
0366             this.sequenceGCContent = getGCContent(this.sequence);
0367             oriC = findobj(knowledgeBase.genomeFeatures, <span class="string">'wholeCellModelID'</span>, <span class="string">'oriC'</span>);
0368             terC = findobj(knowledgeBase.genomeFeatures, <span class="string">'wholeCellModelID'</span>, <span class="string">'terC'</span>);
0369             this.oriCPosition = oriC.startCoordinate;
0370             this.terCPosition = terC.startCoordinate;
0371             
0372             <span class="comment">%Ensure that relaxedBasesPerTurn is defined such that the relaxed</span>
0373             <span class="comment">%linking number will be a whole number for this organism.</span>
0374             this.relaxedBasesPerTurn = length(this.sequence) * (1 + this.equilibriumSuperhelicalDensity) / <span class="keyword">...</span>
0375                 ceil(length(this.sequence) / this.relaxedBasesPerTurn * (1 + this.equilibriumSuperhelicalDensity));
0376             
0377             <span class="comment">%% transcription units</span>
0378             this.transcriptionUnitWholeCellModelIDs = {knowledgeBase.transcriptionUnits.wholeCellModelID}';
0379             this.transcriptionUnitNames             = {knowledgeBase.transcriptionUnits.name}';
0380             this.transcriptionUnitStartCoordinates  = [knowledgeBase.transcriptionUnits.startCoordinate]';
0381             this.transcriptionUnitLengths           = [knowledgeBase.transcriptionUnits.sequenceLength]';
0382             this.transcriptionUnitStrands           = 2-[knowledgeBase.transcriptionUnits.direction]';
0383             
0384             <span class="comment">%% proteins</span>
0385             this.monomerIndexs_ligase        = simulation.state(<span class="string">'ProteinMonomer'</span>).getIndexs({<span class="string">'MG_254_MONOMER'</span>});
0386             this.complexIndexs_dnaPolymerase = simulation.state(<span class="string">'ProteinComplex'</span>).getIndexs({<span class="string">'DNA_POLYMERASE_CORE'</span>});
0387             this.complexIndexs_DisA          = simulation.state(<span class="string">'ProteinComplex'</span>).getIndexs({<span class="string">'MG_105_OCTAMER'</span>});
0388             this.complexIndexs_rnaPolymerase = sort(simulation.state(<span class="string">'ProteinComplex'</span>).getIndexs({<span class="string">'RNA_POLYMERASE'</span>; <span class="string">'RNA_POLYMERASE_HOLOENZYME'</span>}));
0389             this.monomerIndexs_replisome     = zeros(0, 1);
0390             this.complexIndexs_replisome     = sort(simulation.state(<span class="string">'ProteinComplex'</span>).getIndexs({
0391                 <span class="string">'DNA_POLYMERASE_2CORE_BETA_CLAMP_GAMMA_COMPLEX_PRIMASE'</span>
0392                 <span class="string">'DNA_POLYMERASE_CORE_BETA_CLAMP_GAMMA_COMPLEX'</span>
0393                 <span class="string">'DNA_POLYMERASE_CORE_BETA_CLAMP_PRIMASE'</span>
0394                 <span class="string">'MG_001_DIMER'</span>
0395                 <span class="string">'MG_094_HEXAMER'</span>
0396                 }));
0397             
0398             this.monomerDNAFootprints = ceil([knowledgeBase.proteinMonomers.dnaFootprint]');
0399             this.complexDNAFootprints = ceil([knowledgeBase.proteinComplexs.dnaFootprint]');
0400             
0401             strandedValues = cell(3, 1);
0402             strandedValues{this.dnaStrandedness_ssDNA} = <span class="string">'ssDNA'</span>;
0403             strandedValues{this.dnaStrandedness_dsDNA} = <span class="string">'dsDNA'</span>;
0404             strandedValues{this.dnaStrandedness_xsDNA} = <span class="string">'Either'</span>;
0405             
0406             monomerStrandedness = {knowledgeBase.proteinMonomers.dnaFootprintBindingStrandedness}';
0407             complexStrandedness = {knowledgeBase.proteinComplexs.dnaFootprintBindingStrandedness}';
0408             monomerStrandedness(cellfun(@isempty, monomerStrandedness)) = {<span class="string">'dsDNA'</span>};
0409             complexStrandedness(cellfun(@isempty, complexStrandedness)) = {<span class="string">'dsDNA'</span>};
0410             [~, this.monomerDNAFootprintBindingStrandedness] = ismember(monomerStrandedness, strandedValues);
0411             [~, this.complexDNAFootprintBindingStrandedness] = ismember(complexStrandedness, strandedValues);
0412             
0413             monomerStrandedness = {knowledgeBase.proteinMonomers.dnaFootprintRegionStrandedness}';
0414             complexStrandedness = {knowledgeBase.proteinComplexs.dnaFootprintRegionStrandedness}';
0415             monomerStrandedness(cellfun(@isempty, monomerStrandedness)) = {<span class="string">'dsDNA'</span>};
0416             complexStrandedness(cellfun(@isempty, complexStrandedness)) = {<span class="string">'dsDNA'</span>};
0417             [~, this.monomerDNAFootprintRegionStrandedness] = ismember(monomerStrandedness, strandedValues);
0418             [~, this.complexDNAFootprintRegionStrandedness] = ismember(complexStrandedness, strandedValues);
0419             
0420             <span class="comment">%% proteins which have ability to release other proteins bound to chromosomes</span>
0421             state = findobj(knowledgeBase.states, <span class="string">'wholeCellModelID'</span>, this.wholeCellModelID);
0422             reactions = state.reactions;
0423             reactionGlobalIndexs = [reactions.idx]';
0424             this.reactionWholeCellModelIDs = {reactions.wholeCellModelID}';
0425             this.reactionNames = {reactions.name}';
0426             
0427             this.reactionBoundMonomer = zeros(size(reactions));
0428             this.reactionBoundComplex = zeros(size(reactions));
0429             [i, j] = find(max(0, knowledgeBase.reactionProteinMonomerStoichiometryMatrix(:, reactionGlobalIndexs, this.compartment.cytosolIndexs)));
0430             this.reactionBoundMonomer(j) = i;
0431             [i, j] = find(max(0, knowledgeBase.reactionProteinComplexStoichiometryMatrix(:, reactionGlobalIndexs, this.compartment.cytosolIndexs)));
0432             this.reactionBoundComplex(j) = i;
0433             
0434             this.reactionMonomerCatalysisMatrix = max(0, -knowledgeBase.reactionProteinMonomerStoichiometryMatrix(:, reactionGlobalIndexs, this.compartment.cytosolIndexs)');
0435             this.reactionComplexCatalysisMatrix = max(0, -knowledgeBase.reactionProteinComplexStoichiometryMatrix(:, reactionGlobalIndexs, this.compartment.cytosolIndexs)');
0436             
0437             this.reactionThresholds = <span class="keyword">...</span>
0438                 sum(this.reactionMonomerCatalysisMatrix, 2) + <span class="keyword">...</span>
0439                 sum(this.reactionComplexCatalysisMatrix, 2);
0440         <span class="keyword">end</span>
0441     <span class="keyword">end</span>
0442     
0443     methods
0444         <span class="comment">%allocate memory</span>
0445         <a name="_sub3" href="#_subfunctions" class="code">function allocateMemory(this, numTimePoints)</a>
0446             import edu.stanford.covert.util.CircularSparseMat;
0447             
0448             this.polymerizedRegions       = CircularSparseMat([], [], [this.sequenceLen, this.nCompartments, numTimePoints], 1);
0449             this.linkingNumbers           = CircularSparseMat([], [], [this.sequenceLen, this.nCompartments, numTimePoints], 1);
0450 
0451             this.monomerBoundSites        = CircularSparseMat([], [], [this.sequenceLen, this.nCompartments, numTimePoints], 1);
0452             this.complexBoundSites        = CircularSparseMat([], [], [this.sequenceLen, this.nCompartments, numTimePoints], 1);
0453             
0454             this.gapSites                 = CircularSparseMat([], false(0,1), [this.sequenceLen, this.nCompartments, numTimePoints], 1);
0455             this.abasicSites              = CircularSparseMat([], false(0,1), [this.sequenceLen, this.nCompartments, numTimePoints], 1);
0456             this.damagedSugarPhosphates   = CircularSparseMat([], [],         [this.sequenceLen, this.nCompartments, numTimePoints], 1);
0457             this.damagedBases             = CircularSparseMat([], [],         [this.sequenceLen, this.nCompartments, numTimePoints], 1);
0458             this.intrastrandCrossLinks    = CircularSparseMat([], [],         [this.sequenceLen, this.nCompartments, numTimePoints], 1);
0459             this.strandBreaks             = CircularSparseMat([], false(0,1), [this.sequenceLen, this.nCompartments, numTimePoints], 1);
0460             this.hollidayJunctions        = CircularSparseMat([], false(0,1), [this.sequenceLen, this.nCompartments, numTimePoints], 1);
0461             
0462             this.segregated               = false(1, 1, numTimePoints);
0463             
0464             this.invalidate();
0465         <span class="keyword">end</span>
0466     <span class="keyword">end</span>
0467     
0468     methods
0469         <a name="_sub4" href="#_subfunctions" class="code">function initialize(this)</a>
0470             this.allocateMemory(1);
0471             
0472             this.polymerizedRegions(1, this.strandIndexs_ch1) = this.sequenceLen;
0473             this.linkingNumbers(1, this.strandIndexs_ch1) = this.sequenceLen / this.relaxedBasesPerTurn * (1 + this.equilibriumSuperhelicalDensity);
0474             
0475             this.invalidate();
0476         <span class="keyword">end</span>        
0477     <span class="keyword">end</span>
0478 
0479     <span class="comment">%general methods which query, but do not modify state</span>
0480     methods
0481         <span class="comment">%- positionsStrands must be a 2 column vector</span>
0482         <span class="comment">%- lengths must have same number of rows as positionsStrands</span>
0483         <a name="_sub5" href="#_subfunctions" class="code">function [tfs, idxs, positionsStrands, lengths] = sampleAccessibleRegions(this, </a><span class="keyword">...</span>
0484                 nSites, weights, positionsStrands, lengths, <span class="keyword">...</span>
0485                 bindingMonomers, bindingComplexs, <span class="keyword">...</span>
0486                 isPositionsStrandFootprintCentroid, ignoreDamageFilter, returnOverlappingRegions, returnExtentAccessible, <span class="keyword">...</span>
0487                 checkRegionSupercoiled)
0488 
0489             <span class="keyword">if</span> nargin &lt; 12
0490                 checkRegionSupercoiled = false;
0491             <span class="keyword">end</span>
0492             
0493             <span class="keyword">if</span> isempty(weights)
0494                 weights = ones(size(positionsStrands, 1), 1);
0495             <span class="keyword">end</span>
0496             
0497             [footprint, footprint3Prime, footprint5Prime, footprintBindingStrandedness] = this.getDNAFootprint(bindingMonomers, bindingComplexs);
0498             
0499             idxs = [];
0500             <span class="keyword">while</span> any(weights) &amp;&amp; numel(idxs) &lt; nSites
0501                 <span class="comment">%sample sites</span>
0502                 nMoreSites = min(max(2 * (nSites - numel(idxs)), 10), nnz(weights));
0503                 selectedSites = this.randStream.randsample(numel(weights), nMoreSites, false, weights);
0504                 weights(selectedSites) = 0;
0505                 
0506                 <span class="comment">%determine if selected sites are accessible</span>
0507                 [tmpTfs, ~, ~, extents] = this.isRegionAccessible(positionsStrands(selectedSites, :), lengths(selectedSites), <span class="keyword">...</span>
0508                     bindingMonomers, bindingComplexs, isPositionsStrandFootprintCentroid, ignoreDamageFilter, <span class="keyword">...</span>
0509                     returnExtentAccessible, true, checkRegionSupercoiled);
0510                 newIdxs = selectedSites(tmpTfs);
0511                 lengths(selectedSites(~tmpTfs)) = 0;
0512                 lengths(selectedSites(tmpTfs)) = extents;
0513                 
0514                 <span class="comment">%if proteins binding, make sure proteins won't sterically overlap</span>
0515                 <span class="keyword">if</span> ~returnOverlappingRegions
0516                     [idxs, newIdxs] = this.excludeOverlappingRegions(<span class="keyword">...</span>
0517                         idxs, newIdxs, positionsStrands, lengths, <span class="keyword">...</span>
0518                         footprint, footprint3Prime, footprint5Prime, isPositionsStrandFootprintCentroid, <span class="keyword">...</span>
0519                         footprintBindingStrandedness == this.dnaStrandedness_dsDNA);
0520                 <span class="keyword">end</span>
0521                 
0522                 <span class="keyword">if</span> numel(newIdxs) &gt; nSites - numel(idxs)
0523                     newIdxs = newIdxs(1:nSites - numel(idxs));
0524                 <span class="keyword">end</span>
0525                 idxs = [idxs; newIdxs];
0526             <span class="keyword">end</span>
0527             
0528             <span class="comment">%format output</span>
0529             idxs = sort(idxs);
0530             tfs = false(size(positionsStrands, 1), 1);
0531             tfs(idxs) = true;
0532             positionsStrands = positionsStrands(idxs, :);
0533             lengths = lengths(idxs, :);
0534         <span class="keyword">end</span>
0535         
0536         <span class="comment">%randomly select among accessible sites (which if sequence seq is</span>
0537         <span class="comment">%specified, have this sequence) with probability probOrNSites (or if</span>
0538         <span class="comment">%probOrNSites &gt; 1, randomly select probOrNSites sites)</span>
0539         <a name="_sub6" href="#_subfunctions" class="code">function positionsStrands = sampleAccessibleSites(this, prob, nSites, seq)</a>
0540             <span class="comment">%for convenience</span>
0541             dnaLength = this.sequenceLen;
0542             posStrnds = find(this.polymerizedRegions);
0543             nStrands = max(posStrnds(:, 2));
0544             seqLen = numel(seq);
0545             
0546             <span class="comment">%estimate total number of accessible sites</span>
0547             [~, boundMonomers] = find(this.monomerBoundSites);
0548             [~, boundComplexs] = find(this.complexBoundSites);
0549             
0550             nAccessibleSites = <span class="keyword">...</span>
0551                 collapse(this.polymerizedRegions) <span class="keyword">...</span>
0552                 - sum(this.monomerDNAFootprints(boundMonomers, 1)) <span class="keyword">...</span>
0553                 - sum(this.complexDNAFootprints(boundComplexs, 1)) <span class="keyword">...</span>
0554                 - nnz(this.damagedSites);
0555             
0556             <span class="comment">%calculate number of sites to select</span>
0557             <span class="keyword">if</span> ~isempty(prob)
0558                 nGC = sum(seq == <span class="string">'G'</span> | seq == <span class="string">'C'</span>);
0559                 nSites = min(nSites, this.randStream.stochasticRound(<span class="keyword">...</span>
0560                     nAccessibleSites * prob * <span class="keyword">...</span>
0561                     (this.sequenceGCContent/2)^nGC * ((1-this.sequenceGCContent)/2)^(seqLen-nGC)));
0562             <span class="keyword">end</span>
0563             <span class="keyword">if</span> nSites == 0
0564                 positionsStrands = zeros(0, 2);
0565                 <span class="keyword">return</span>;
0566             <span class="keyword">end</span>
0567             
0568             <span class="comment">%randomly select nSites undamaged sites with sequence equal to seq</span>
0569             positionsStrands = zeros(0, 2);
0570             iter = 0;
0571             <span class="keyword">while</span> iter &lt; 15
0572                 <span class="comment">%iterations</span>
0573                 iter = iter + 1;
0574                 
0575                 <span class="comment">%more sites</span>
0576                 nMoreSites = nSites - size(positionsStrands, 1);
0577                 nMoreSites = max(2 * nMoreSites, nMoreSites + 10);
0578                 
0579                 <span class="comment">%pick random positions and strand</span>
0580                 positions = ceil(dnaLength * this.randStream.rand(nMoreSites, 1));
0581                 strands   = ceil(nStrands * this.randStream.rand(nMoreSites, 1));
0582                 
0583                 <span class="comment">%throw away positions that aren't inaccessible</span>
0584                 <span class="keyword">if</span> isempty(seq)
0585                     [~, idxs] = this.isRegionAccessible([positions strands], 1, [], [], true, [], false, false);
0586                 <span class="keyword">else</span>
0587                     dir = 2 * (mod(strands, 2) == 1) - 1;
0588                     pos = 0:seqLen - 1;
0589                     
0590                     subsequences = this.sequence.subsequence(<span class="keyword">...</span>
0591                         positions(:, ones(1, seqLen)) + <span class="keyword">...</span>
0592                         dir(:, ones(1, seqLen)) .* pos(ones(nMoreSites, 1), :), <span class="keyword">...</span>
0593                         strands);
0594                     
0595                     <span class="keyword">if</span> size(seq, 1) == 1
0596                         <span class="keyword">if</span> isscalar(seq)
0597                             idx = find(subsequences == seq);
0598                         <span class="keyword">elseif</span> size(seq, 2) == 2
0599                             idx = find(subsequences(:, 1) == seq(1) &amp; subsequences(:, 2) == seq(2));
0600                         <span class="keyword">else</span>
0601                             idx = find(all(subsequences == seq(ones(size(subsequences, 1), 1), :), 2));
0602                         <span class="keyword">end</span>
0603                     <span class="keyword">else</span>
0604                         idx = find(ismember(subsequences, seq, <span class="string">'rows'</span>));
0605                     <span class="keyword">end</span>
0606                     positions = positions(idx, :);
0607                     strands = strands(idx, :);
0608                     
0609                     [~, idxs] = this.isRegionAccessible([positions strands], seqLen, [], [], true, [], false, false);
0610                 <span class="keyword">end</span>
0611                 
0612                 <span class="comment">%append to list of valid positions and strands</span>
0613                 positionsStrands = edu.stanford.covert.util.SparseMat.unique_subs(<span class="keyword">...</span>
0614                     [positionsStrands; positions(idxs) strands(idxs)], [dnaLength this.nCompartments]);
0615                 
0616                 <span class="comment">%if more sites that requested, randomly select</span>
0617                 <span class="keyword">if</span> size(positionsStrands, 1) &gt;= nSites
0618                     positionsStrands = this.randStream.randomlySelectNRows(positionsStrands, nSites);
0619                     <span class="keyword">break</span>;
0620                 <span class="keyword">end</span>
0621             <span class="keyword">end</span>
0622             
0623             <span class="comment">%sort</span>
0624             <span class="keyword">if</span> nSites &gt; 1
0625                 positionsStrands = edu.stanford.covert.util.SparseMat.sort_subs(positionsStrands, [dnaLength this.nCompartments]);
0626             <span class="keyword">end</span>
0627         <span class="keyword">end</span>
0628         
0629         <span class="comment">%Filters a list of sites (positionsStrands -- strands and positions along</span>
0630         <span class="comment">%strands), returning only those sites which are accessible to the</span>
0631         <span class="comment">%queried protein monomers and complexes (that is site which have been</span>
0632         <span class="comment">%polymerized, which aren't damaged, and which are either not bound by</span>
0633         <span class="comment">%protein, or are bound by proteins which at least one of the query</span>
0634         <span class="comment">%protein can release from the chromosome). Query proteins are indicated</span>
0635         <span class="comment">%by their indices within simulation.matureMatureIndexs</span>
0636         <span class="comment">%(monomerIndexs) and simulation.matureIndexs (complexIndexs).</span>
0637         <span class="comment">%</span>
0638         <span class="comment">%If monomerIndexs and complexIndexs are null, or aren't defined, this</span>
0639         <span class="comment">%function only returns sites that have been polymerized, aren't damaged,</span>
0640         <span class="comment">%and aren't bound by any proteins.</span>
0641         <span class="comment">%</span>
0642         <span class="comment">%Also returns the indices (idxs) of the query sites which are</span>
0643         <span class="comment">%accessible, and a boolean vector (tfs) indicated whether or not each</span>
0644         <span class="comment">%query site is accessible</span>
0645         <span class="comment">%</span>
0646         <span class="comment">%Returns true/false if regions defined by positionsStrands and lengths</span>
0647         <span class="comment">%are accessible/inaccessible.</span>
0648         <span class="comment">%</span>
0649         <span class="comment">%true  ==&gt; region is accessible</span>
0650         <span class="comment">%false ==&gt; region is not accessible</span>
0651         <a name="_sub7" href="#_subfunctions" class="code">function [tfs, idxs, positionsStrands, lengths] = isRegionAccessible(this, </a><span class="keyword">...</span>
0652                 positionsStrands, lengths, <span class="keyword">...</span>
0653                 bindingMonomers, bindingComplexs, <span class="keyword">...</span>
0654                 isPositionsStrandFootprintCentroid, ignoreDamageFilter, <span class="keyword">...</span>
0655                 returnExtent, returnOverlappingRegions, checkRegionSupercoiled)
0656             <span class="keyword">if</span> isempty(positionsStrands)
0657                 tfs = false(0, 1);
0658                 idxs = zeros(0, 1);
0659                 lengths = zeros(0, 1);
0660                 <span class="keyword">return</span>;
0661             <span class="keyword">end</span>
0662             
0663             <span class="comment">%% default values of inputs</span>
0664             <span class="keyword">if</span> ~all(lengths)
0665                 throw(MException(<span class="string">'Chromosome:invalidInput'</span>, <span class="string">'Lengths must be non-zero integers'</span>));
0666             <span class="keyword">elseif</span> numel(lengths) == 1
0667                 lengths = lengths(ones(size(positionsStrands, 1), 1), 1);
0668             <span class="keyword">end</span>
0669             <span class="keyword">if</span> isempty(ignoreDamageFilter)
0670                 ignoreDamageFilter = zeros(size(positionsStrands, 1), 0);
0671             <span class="keyword">elseif</span> size(ignoreDamageFilter, 1) &lt;= 1
0672                 ignoreDamageFilter = ignoreDamageFilter(ones(size(positionsStrands, 1), 1), :);
0673             <span class="keyword">end</span>
0674             <span class="keyword">if</span> nargin &lt; 9
0675                 returnOverlappingRegions = true;
0676             <span class="keyword">end</span>
0677             <span class="keyword">if</span> nargin &lt; 10
0678                 checkRegionSupercoiled = false;
0679             <span class="keyword">end</span>
0680             
0681             <span class="comment">%% indices of complexs and monomers which at least one of the the</span>
0682             <span class="comment">%query proteins can release, and therefore shouldn't be cause for a</span>
0683             <span class="comment">%site to be filtered out if they are bound to a site</span>
0684             [releasableMonomerIndexs, releasableComplexIndexs] = this.getReleasableProteins(bindingMonomers, bindingComplexs);
0685             
0686             <span class="comment">%% DNA footprint of binding proteins,</span>
0687             [footprint, footprint3Prime, footprint5Prime, footprintBindingStrandedness, footprintRegionStrandedness] = this.getDNAFootprint(bindingMonomers, bindingComplexs);
0688             
0689             <span class="comment">%adding query positions if input positions are the centroid of</span>
0690             <span class="comment">%the binding proteins' DNA footpring</span>
0691             queryPositionsStrands = positionsStrands;
0692             <span class="keyword">if</span> isPositionsStrandFootprintCentroid
0693                 strnd = queryPositionsStrands(:, 2);
0694                 
0695                 queryPositionsStrands(mod(strnd, 2) == 1 &amp; lengths &gt; 0, 1) = queryPositionsStrands(mod(strnd, 2) == 1 &amp; lengths &gt; 0, 1) - footprint5Prime;
0696                 queryPositionsStrands(mod(strnd, 2) == 0 &amp; lengths &gt; 0, 1) = queryPositionsStrands(mod(strnd, 2) == 0 &amp; lengths &gt; 0, 1) - footprint3Prime;
0697                 queryPositionsStrands(mod(strnd, 2) == 1 &amp; lengths &lt; 0, 1) = queryPositionsStrands(mod(strnd, 2) == 1 &amp; lengths &lt; 0, 1) + footprint3Prime;
0698                 queryPositionsStrands(mod(strnd, 2) == 0 &amp; lengths &lt; 0, 1) = queryPositionsStrands(mod(strnd, 2) == 0 &amp; lengths &lt; 0, 1) + footprint5Prime;
0699                 
0700                 ignoreDamageFilter(mod(strnd, 2) == 1 &amp; lengths &gt; 0, :) = ignoreDamageFilter(mod(strnd, 2) == 1 &amp; lengths &gt; 0, :) + footprint5Prime;
0701                 ignoreDamageFilter(mod(strnd, 2) == 0 &amp; lengths &gt; 0, :) = ignoreDamageFilter(mod(strnd, 2) == 0 &amp; lengths &gt; 0, :) + footprint3Prime;
0702                 ignoreDamageFilter(mod(strnd, 2) == 1 &amp; lengths &lt; 0, :) = ignoreDamageFilter(mod(strnd, 2) == 1 &amp; lengths &lt; 0, :) - footprint3Prime;
0703                 ignoreDamageFilter(mod(strnd, 2) == 0 &amp; lengths &lt; 0, :) = ignoreDamageFilter(mod(strnd, 2) == 0 &amp; lengths &lt; 0, :) - footprint5Prime;
0704             <span class="keyword">elseif</span> lengths &lt; 0
0705                 queryPositionsStrands(:, 1) = queryPositionsStrands(:, 1) + footprint - 1;
0706             <span class="keyword">end</span>
0707             queryLengths = lengths + sign(lengths) * (footprint - 1);
0708             
0709             <span class="comment">%% filter query sites</span>
0710             <span class="keyword">switch</span> footprintRegionStrandedness
0711                 <span class="keyword">case</span> this.dnaStrandedness_dsDNA
0712                     [~, ~, ~, polymerized] = this.isRegionDoubleStranded(queryPositionsStrands, queryLengths, true, checkRegionSupercoiled);
0713                 <span class="keyword">case</span> this.dnaStrandedness_ssDNA
0714                     [~, ~, ~, polymerized] = this.isRegionSingleStranded(queryPositionsStrands, queryLengths, true);                
0715                 <span class="keyword">case</span> this.dnaStrandedness_xsDNA
0716                     <span class="comment">%TODO: calculate extent</span>
0717                     polymerized = queryLengths;
0718                 <span class="keyword">otherwise</span>
0719                     throw(MException(<span class="string">'Chromosome:invalidInput'</span>,<span class="string">'Invalid footprint strandedness'</span>));
0720             <span class="keyword">end</span>
0721             
0722             [~, ~, ~, proteinFree] = this.isRegionProteinFree(queryPositionsStrands, queryLengths, true, <span class="keyword">...</span>
0723                 releasableMonomerIndexs, releasableComplexIndexs, <span class="keyword">...</span>
0724                 footprintBindingStrandedness == this.dnaStrandedness_dsDNA, <span class="keyword">...</span>
0725                 footprintRegionStrandedness == this.dnaStrandedness_xsDNA);
0726             [~, ~, ~, undamaged] = this.isRegionUndamaged(queryPositionsStrands, queryLengths, <span class="keyword">...</span>
0727                 footprintBindingStrandedness == this.dnaStrandedness_dsDNA, ignoreDamageFilter, true, <span class="keyword">...</span>
0728                 footprintRegionStrandedness == this.dnaStrandedness_xsDNA);
0729             
0730             extents = sign(lengths) .* max(0, (min(abs([proteinFree polymerized undamaged]), [], 2) - (footprint - 1)));
0731             
0732             <span class="comment">%% Make sure regions don't sterically overlap</span>
0733             <span class="keyword">if</span> ~returnOverlappingRegions
0734                 <span class="keyword">if</span> returnExtent
0735                     tfs = find(extents ~= 0);
0736                 <span class="keyword">else</span>
0737                     tfs = find(lengths == extents);
0738                 <span class="keyword">end</span>
0739                 [~, idxs] = this.excludeOverlappingRegions([], tfs, positionsStrands, extents, <span class="keyword">...</span>
0740                     footprint, footprint3Prime, footprint5Prime, isPositionsStrandFootprintCentroid, <span class="keyword">...</span>
0741                     footprintBindingStrandedness == this.dnaStrandedness_dsDNA);
0742                 extents(setdiff(1:<span class="keyword">end</span>, idxs)) = 0;
0743             <span class="keyword">end</span>
0744             
0745             <span class="comment">%% format output</span>
0746             <span class="comment">%- extract sites which pass filter</span>
0747             <span class="comment">%- reshape indices of sites which pass filter</span>
0748             <span class="comment">%- construct boolean indicating which sites pass filter</span>
0749             <span class="keyword">if</span> returnExtent
0750                 tfs = true(size(positionsStrands, 1), 1);
0751             <span class="keyword">else</span>
0752                 tfs = lengths == extents;
0753             <span class="keyword">end</span>
0754             idxs = find(tfs);
0755             idxs = idxs(:);
0756             positionsStrands = positionsStrands(idxs, :);
0757             lengths = extents(idxs, :);
0758         <span class="keyword">end</span>
0759     <span class="keyword">end</span>
0760     
0761     <span class="comment">%private methods for query state by region</span>
0762     methods
0763         <a name="_sub8" href="#_subfunctions" class="code">function [tfs, idxs, positionsStrands, lengths] = isRegionSingleStranded(this, positionsStrands, lengths, returnExtent)</a>
0764             <span class="keyword">if</span> isempty(positionsStrands)
0765                 tfs = false(0, 1);
0766                 idxs = zeros(0, 1);
0767                 lengths = zeros(0, 1);
0768                 <span class="keyword">return</span>;
0769             <span class="keyword">end</span>
0770             <span class="keyword">if</span> numel(lengths) == 1
0771                 lengths = lengths(ones(size(positionsStrands, 1), 1), 1);
0772             <span class="keyword">end</span>
0773             
0774             [polPosStrnds, polLens] = find(this.polymerizedRegions);
0775             
0776             <span class="comment">%only 1 chromosome</span>
0777             <span class="keyword">if</span> size(positionsStrands, 2) == 2 &amp;&amp; all(polLens == this.sequenceLen) &amp;&amp; mod(numel(polLens), 2) == 0 &amp;&amp; all(polPosStrnds(:, 2) == (1:numel(polLens))')
0778                 <span class="keyword">if</span> returnExtent
0779                     tfs = true(size(positionsStrands, 1), 1);
0780                     idxs = (1:numel(tfs))';
0781                     lengths(:) = 0;
0782                 <span class="keyword">else</span>
0783                     tfs = false(size(lengths));
0784                     idxs = zeros(0, 1);
0785                     positionsStrands = zeros(0, 2);
0786                     lengths = zeros(0, 1);
0787                 <span class="keyword">end</span>
0788                 <span class="keyword">return</span>;
0789             <span class="keyword">end</span>
0790             
0791             <span class="comment">%all other cases</span>
0792             [tfs, idxs, positionsStrands, lengths] = this.isRegionPolymerized(positionsStrands, lengths, returnExtent, this.dnaStrandedness_ssDNA);
0793         <span class="keyword">end</span>
0794         
0795         <a name="_sub9" href="#_subfunctions" class="code">function [tfs, idxs, positionsStrands, lengths] = isRegionDoubleStranded(this, positionsStrands, lengths, returnExtent, checkRegionSupercoiled)</a>
0796             <span class="keyword">if</span> isempty(positionsStrands)
0797                 tfs = false(0, 1);
0798                 idxs = zeros(0, 1);
0799                 lengths = zeros(0, 1);
0800                 <span class="keyword">return</span>;
0801             <span class="keyword">end</span>
0802             <span class="keyword">if</span> nargin &lt; 5
0803                 checkRegionSupercoiled = false;
0804             <span class="keyword">end</span>
0805             
0806             <span class="keyword">if</span> numel(lengths) == 1
0807                 lengths = lengths(ones(size(positionsStrands, 1), 1), 1);
0808             <span class="keyword">end</span>
0809             
0810             [polPosStrnds, polLens] = find(this.polymerizedRegions);
0811             <span class="keyword">if</span> checkRegionSupercoiled
0812                 supPosStrnds = find(this.supercoiled);
0813             <span class="keyword">end</span>
0814             
0815             <span class="comment">%only fully formed chromosomes</span>
0816             <span class="keyword">if</span> size(positionsStrands, 2) == 2 &amp;&amp; all(polLens == this.sequenceLen) &amp;&amp; mod(numel(polLens), 2) == 0 &amp;&amp; all(polPosStrnds(:, 2) == (1:numel(polLens))')
0817                 <span class="keyword">if</span> numel(polLens) == 2
0818                     <span class="keyword">if</span> returnExtent
0819                         tfs = true(size(positionsStrands, 1), 1);
0820                         idxs = (1:numel(tfs))';
0821                         lengths(positionsStrands(:, 2) &gt; 2) = 0;
0822                         <span class="keyword">if</span> checkRegionSupercoiled
0823                             lengths(~ismembc(positionsStrands(:, 2), supPosStrnds(:, 2))) = 0;
0824                         <span class="keyword">end</span>
0825                     <span class="keyword">else</span>
0826                         tfs = positionsStrands(:, 2) &lt;= 2;
0827                         <span class="keyword">if</span> checkRegionSupercoiled
0828                             tfs = tfs &amp; ismembc(positionsStrands(:, 2), supPosStrnds(:, 2));
0829                         <span class="keyword">end</span>
0830                         idxs = find(tfs);
0831                         positionsStrands = positionsStrands(tfs, :);
0832                         lengths = lengths(tfs, 1);
0833                     <span class="keyword">end</span>
0834                 <span class="keyword">else</span>
0835                     <span class="keyword">if</span> returnExtent
0836                         tfs = true(size(positionsStrands, 1), 1);
0837                         idxs = (1:numel(tfs))';
0838                         <span class="keyword">if</span> checkRegionSupercoiled
0839                             lengths(~ismembc(positionsStrands(:, 2), supPosStrnds(:, 2))) = 0;
0840                         <span class="keyword">end</span>
0841                     <span class="keyword">else</span>
0842                         tfs = true(size(positionsStrands, 1), 1);
0843                         <span class="keyword">if</span> checkRegionSupercoiled
0844                             tfs = tfs &amp; ismembc(positionsStrands(:, 2), supPosStrnds(:, 2));
0845                         <span class="keyword">end</span>
0846                         idxs = find(tfs);
0847                         positionsStrands = positionsStrands(tfs, :);
0848                         lengths = lengths(tfs, 1);
0849                     <span class="keyword">end</span>
0850                 <span class="keyword">end</span>
0851                 <span class="keyword">return</span>;
0852             <span class="keyword">end</span>
0853             
0854             <span class="comment">%all other cases</span>
0855             [tfs, idxs, positionsStrands, lengths] = this.isRegionPolymerized(positionsStrands, lengths, returnExtent, this.dnaStrandedness_dsDNA, checkRegionSupercoiled);
0856         <span class="keyword">end</span>
0857         
0858         <a name="_sub10" href="#_subfunctions" class="code">function [tfs, idxs, positionsStrands, lengths] = isRegionPolymerized(this, </a><span class="keyword">...</span>
0859                 positionsStrands, lengths, returnExtent, checkRegionStrandedness, checkRegionSupercoiled, polymerizedRegions)
0860             <span class="keyword">if</span> isempty(positionsStrands)
0861                 tfs = false(0, 1);
0862                 idxs = zeros(0, 1);
0863                 lengths = zeros(0, 1);
0864                 <span class="keyword">return</span>;
0865             <span class="keyword">end</span>
0866             <span class="keyword">if</span> ~all(lengths)
0867                 throw(MException(<span class="string">'Chromosome:invalidInput'</span>,<span class="string">'Lengths must be non-zero integers'</span>));
0868             <span class="keyword">elseif</span> numel(lengths) == 1
0869                 lengths = lengths(ones(size(positionsStrands, 1), 1), 1);
0870             <span class="keyword">end</span>
0871             <span class="keyword">if</span> nargin &lt; 7
0872                 polymerizedRegions = this.polymerizedRegions;
0873             <span class="keyword">end</span>
0874             
0875             <span class="keyword">if</span> nargin &gt;= 5 &amp;&amp; ~isempty(checkRegionStrandedness) &amp;&amp; checkRegionStrandedness == this.dnaStrandedness_dsDNA
0876                 [regions, regionLengths] = find(this.doubleStrandedRegions);
0877                 <span class="keyword">if</span> nargin &gt;= 6 &amp;&amp; ~isempty(checkRegionSupercoiled) &amp;&amp; checkRegionSupercoiled
0878                     tfs = this.supercoiled(regions);
0879                     regions = regions(tfs, :);
0880                     regionLengths = regionLengths(tfs, :);
0881                 <span class="keyword">end</span>
0882             <span class="keyword">elseif</span> nargin &gt;= 5 &amp;&amp; ~isempty(checkRegionStrandedness) &amp;&amp; checkRegionStrandedness == this.dnaStrandedness_ssDNA
0883                 [regions, regionLengths] = find(this.singleStrandedRegions);
0884             <span class="keyword">else</span>
0885                 [regions, regionLengths] = find(polymerizedRegions);
0886             <span class="keyword">end</span>
0887             
0888             <span class="comment">%all strands either fully, or not at all synthesized</span>
0889             <span class="keyword">if</span> all(regionLengths == this.sequenceLen) &amp;&amp; size(regions, 2) == 2
0890                 <span class="keyword">if</span> size(regions, 1) == this.nCompartments
0891                     <span class="comment">%all chromosomes fully synethesized</span>
0892                     tfs = true(size(positionsStrands,1), 1);
0893                     idxs = (1:size(positionsStrands,1))';
0894                 <span class="keyword">elseif</span> isequal(regions(:,2), [1; 2])
0895                     <span class="comment">%first chromosome fully synethesized</span>
0896                     <span class="keyword">if</span> returnExtent
0897                         tfs = true(size(positionsStrands,1), 1);
0898                         idxs = (1:size(positionsStrands,1))';
0899                         lengths(~ismembc(positionsStrands(:,2), regions(:, 2))) = 0;
0900                     <span class="keyword">else</span>
0901                         tfs = ceil(positionsStrands(:,2)/2) == 1;
0902                         idxs = reshape(find(tfs), [], 1);
0903                         positionsStrands = positionsStrands(idxs, :);
0904                         lengths = lengths(idxs, :);
0905                     <span class="keyword">end</span>
0906                 <span class="keyword">else</span>
0907                     <span class="comment">%all strands either fully, or not at all synthesized</span>
0908                     <span class="keyword">if</span> returnExtent
0909                         tfs = true(size(positionsStrands,1), 1);
0910                         idxs = (1:size(positionsStrands,1))';
0911                         lengths(~ismembc(positionsStrands(:,2), regions(:, 2))) = 0;
0912                     <span class="keyword">else</span>
0913                         tfs = ismembc(positionsStrands(:,2), regions(:, 2));
0914                         idxs = reshape(find(tfs), [], 1);
0915                         positionsStrands = positionsStrands(idxs, :);
0916                         lengths = lengths(idxs, :);
0917                     <span class="keyword">end</span>
0918                 <span class="keyword">end</span>
0919                 <span class="keyword">return</span>;
0920             <span class="keyword">end</span>
0921             
0922             regionStartCoors = regions(:, 1);
0923             regionEndCoors = regionStartCoors  + regionLengths - 1;
0924             regionStrandTimes = [regions(:, 2:end) ones(size(regions, 1), size(positionsStrands,2) - size(regions, 2))];
0925             
0926             startCoors = mod(positionsStrands(:, 1) + min(0, lengths+1) - 1, this.sequenceLen) +1;
0927             endCoors = startCoors + abs(lengths) - 1;
0928             strandTimes = [positionsStrands(:, 2:end) ones(size(positionsStrands, 1), size(regions, 2) - size(positionsStrands,2))];
0929             idxs = (1:size(positionsStrands, 1))';
0930             
0931             tmpIdxs = find(endCoors &gt; this.sequenceLen);
0932             strandTimes = [strandTimes; strandTimes(tmpIdxs, :)];
0933             startCoors = [startCoors; max(1, startCoors(tmpIdxs) - this.sequenceLen)];
0934             endCoors = [endCoors; endCoors(tmpIdxs) - this.sequenceLen];
0935             endCoors(tmpIdxs) = this.sequenceLen;
0936             idxs = [idxs; idxs(tmpIdxs)];
0937             
0938             tmpIdxs = find(startCoors &lt; 0);
0939             strandTimes = [strandTimes; strandTimes(tmpIdxs, :)];
0940             startCoors = [startCoors; startCoors(tmpIdxs) + this.sequenceLen];
0941             endCoors = [endCoors; min(this.sequenceLen, endCoors(tmpIdxs) + this.sequenceLen)];
0942             startCoors(tmpIdxs) = 1;
0943             idxs = [idxs; idxs(tmpIdxs)];
0944             
0945             extents = zeros(size(positionsStrands, 1), 1);
0946             <span class="keyword">if</span> ndims(polymerizedRegions) == 2
0947                 regionStrandTimeSiz = size(polymerizedRegions, 2);
0948             <span class="keyword">else</span>
0949                 regionStrandTimeSiz = [size(polymerizedRegions, 2) size(polymerizedRegions, 3)];
0950             <span class="keyword">end</span>
0951             
0952             tfs = <span class="keyword">...</span>
0953                 ((max(endCoors) &gt;= regionStartCoors &amp; max(endCoors) &lt;= regionEndCoors) | <span class="keyword">...</span>
0954                 (min(startCoors) &gt;= regionStartCoors &amp; min(startCoors) &lt;= regionEndCoors) | <span class="keyword">...</span>
0955                 (min(startCoors) &lt; regionStartCoors &amp; max(endCoors) &gt; regionEndCoors)) &amp; <span class="keyword">...</span>
0956                 edu.stanford.covert.util.SparseMat.ismember_subs(regionStrandTimes, strandTimes, regionStrandTimeSiz);
0957             regionStartCoors = regionStartCoors(tfs);
0958             regionEndCoors = regionEndCoors(tfs);
0959             regionStrandTimes = regionStrandTimes(tfs, :);
0960             
0961             <span class="keyword">if</span> size(positionsStrands, 1) == numel(idxs)
0962                 [~, idxs1, idxs2] = edu.stanford.covert.util.SparseMat.unique_subs([startCoors endCoors], [this.sequenceLen; this.sequenceLen]);
0963                 <span class="keyword">for</span> j = 1:numel(idxs1)
0964                     idxs3 = find(idxs2 == j);
0965                     startCoor = startCoors(idxs3(1));
0966                     endCoor = endCoors(idxs3(1));
0967                     len = lengths(idxs(idxs3(1)));
0968                     <span class="keyword">if</span> len &gt; 0
0969                         idxs3 = idxs3(idxs3 &lt;= size(positionsStrands, 1) | extents(idxs(idxs3)) &gt;= this.sequenceLen - startCoor + 1);
0970                         tfs = startCoor &gt;= regionStartCoors &amp; startCoor &lt;= regionEndCoors;
0971                         tmpregionEndCoors = regionEndCoors(tfs);
0972                         [tfs, idxs4] = edu.stanford.covert.util.SparseMat.ismember_subs(strandTimes(idxs3, :), regionStrandTimes(tfs, :), regionStrandTimeSiz);
0973                         extents(idxs(idxs3(tfs))) = extents(idxs(idxs3(tfs))) + min(tmpregionEndCoors(idxs4(tfs)), endCoor) - startCoor + 1;
0974                     <span class="keyword">else</span>
0975                         idxs3 = idxs3(idxs3 &lt;= size(positionsStrands, 1) | -extents(idxs(idxs3)) &gt;= endCoor);
0976                         tfs = endCoor &gt;= regionStartCoors &amp; endCoor &lt;= regionEndCoors;
0977                         tmpregionStartCoors = regionStartCoors(tfs);
0978                         [tfs, idxs4] = edu.stanford.covert.util.SparseMat.ismember_subs(strandTimes(idxs3, :), regionStrandTimes(tfs, :), regionStrandTimeSiz);
0979                         extents(idxs(idxs3(tfs))) = extents(idxs(idxs3(tfs))) - (endCoor - max(tmpregionStartCoors(idxs4(tfs)), startCoor) + 1);
0980                     <span class="keyword">end</span>
0981                 <span class="keyword">end</span>
0982             <span class="keyword">else</span>
0983                 <span class="keyword">for</span> i = 1:numel(startCoors)
0984                     <span class="keyword">if</span> lengths(idxs(i)) &gt; 0
0985                         <span class="keyword">if</span> i &gt; size(positionsStrands, 1) &amp;&amp; extents(idxs(i)) &lt; this.sequenceLen - startCoors(idxs(i)) + 1
0986                             <span class="keyword">continue</span>;
0987                         <span class="keyword">end</span>
0988                         
0989                         tmpIdxs = find(<span class="keyword">...</span>
0990                             startCoors(i) &gt;= regionStartCoors &amp; <span class="keyword">...</span>
0991                             startCoors(i) &lt;= regionEndCoors &amp; <span class="keyword">...</span>
0992                             ismember(regionStrandTimes, strandTimes(i, :), <span class="string">'rows'</span>), 1, <span class="string">'first'</span>);
0993                         
0994                         <span class="keyword">if</span> ~isempty(tmpIdxs)
0995                             extents(idxs(i)) = extents(idxs(i)) + min(regionEndCoors(tmpIdxs), endCoors(i)) - startCoors(i) + 1;
0996                         <span class="keyword">end</span>
0997                     <span class="keyword">else</span>
0998                         <span class="keyword">if</span> i &gt; size(positionsStrands, 1) &amp;&amp; -extents(idxs(i)) &lt; endCoors(idxs(i))
0999                             <span class="keyword">continue</span>;
1000                         <span class="keyword">end</span>
1001                         
1002                         tmpIdxs = find(<span class="keyword">...</span>
1003                             endCoors(i) &gt;= regionStartCoors &amp; <span class="keyword">...</span>
1004                             endCoors(i) &lt;= regionEndCoors &amp; <span class="keyword">...</span>
1005                             ismember(regionStrandTimes, strandTimes(i, :), <span class="string">'rows'</span>), 1, <span class="string">'first'</span>);
1006                         
1007                         <span class="keyword">if</span> ~isempty(tmpIdxs)
1008                             extents(idxs(i)) = extents(idxs(i)) - (endCoors(i) - max(regionStartCoors(tmpIdxs), startCoors(i)) + 1);
1009                         <span class="keyword">end</span>
1010                     <span class="keyword">end</span>
1011                 <span class="keyword">end</span>
1012             <span class="keyword">end</span>
1013             
1014             <span class="keyword">if</span> returnExtent
1015                 tfs = true(size(positionsStrands, 1), 1);
1016             <span class="keyword">else</span>
1017                 tfs = extents == lengths;
1018             <span class="keyword">end</span>
1019             
1020             idxs = reshape(find(tfs), [], 1);
1021             positionsStrands = positionsStrands(idxs, :);
1022             lengths = extents(idxs, :);
1023         <span class="keyword">end</span>
1024         
1025         <a name="_sub11" href="#_subfunctions" class="code">function [tfs, idxs, positionsStrands, lengths] = isRegionNotPolymerized(this, positionsStrands, lengths, returnExtent)</a>
1026             <span class="keyword">if</span> isempty(positionsStrands)
1027                 tfs = false(0, 1);
1028                 idxs = zeros(0, 1);
1029                 lengths = zeros(0, 1);
1030                 <span class="keyword">return</span>;
1031             <span class="keyword">end</span>
1032             
1033             <span class="keyword">if</span> ~all(lengths)
1034                 throw(MException(<span class="string">'Chromosome:invalidInput'</span>,<span class="string">'Lengths must be non-zero integers'</span>));
1035             <span class="keyword">elseif</span> numel(lengths) == 1
1036                 lengths = lengths(ones(size(positionsStrands, 1), 1), 1);
1037             <span class="keyword">end</span>
1038             
1039             unpolRgns = this.unpolymerizedRegions;
1040             <span class="keyword">if</span> nnz(unpolRgns) == 0
1041                 <span class="keyword">if</span> returnExtent
1042                     tfs = true(size(positionsStrands,1), 1);
1043                     idxs = (1:size(positionsStrands,1))';
1044                     lengths =  zeros(size(positionsStrands,1), 1);
1045                 <span class="keyword">else</span>
1046                     tfs = false(size(positionsStrands,1), 1);
1047                     idxs = zeros(0, 1);
1048                     positionsStrands = zeros(0, ndims(positionsStrands));
1049                     lengths = zeros(0, 1);
1050                 <span class="keyword">end</span>
1051                 <span class="keyword">return</span>;
1052             <span class="keyword">end</span>
1053             
1054             [regions, regionLengths] = find(unpolRgns);
1055             regionStartCoors = regions(:, 1);
1056             regionEndCoors = regionStartCoors  + regionLengths - 1;
1057             regionStrandTimes = [regions(: ,2:end) ones(size(regions, 1), size(positionsStrands,2) - size(regions, 2))];
1058             
1059             startCoors = mod(positionsStrands(:, 1) + min(0, lengths+1) - 1, this.sequenceLen) +1;
1060             endCoors = startCoors + abs(lengths) - 1;
1061             strandTimes = [positionsStrands(: ,2:end) ones(size(positionsStrands, 1), size(regions, 2) - size(positionsStrands,2))];
1062             idxs = (1:size(positionsStrands, 1))';
1063             
1064             tmpIdxs = find(endCoors &gt; this.sequenceLen);
1065             strandTimes = [strandTimes; strandTimes(tmpIdxs, :)];
1066             startCoors = [startCoors; max(1, startCoors(tmpIdxs) - this.sequenceLen)];
1067             endCoors = [endCoors; endCoors(tmpIdxs) - this.sequenceLen];
1068             endCoors(tmpIdxs) = this.sequenceLen;
1069             idxs = [idxs; idxs(tmpIdxs)];
1070             
1071             tmpIdxs = find(startCoors &lt; 0);
1072             strandTimes = [strandTimes; strandTimes(tmpIdxs, :)];
1073             startCoors = [startCoors; startCoors(tmpIdxs) + this.sequenceLen];
1074             endCoors = [endCoors; min(this.sequenceLen, endCoors(tmpIdxs) + this.sequenceLen)];
1075             startCoors(tmpIdxs) = 1;
1076             idxs = [idxs; idxs(tmpIdxs)];
1077             
1078             extents = zeros(size(positionsStrands, 1), 1);
1079             <span class="keyword">for</span> i = 1:numel(startCoors)
1080                 <span class="keyword">if</span> lengths(idxs(i)) &gt; 0
1081                     <span class="keyword">if</span> i &gt; size(positionsStrands, 1) &amp;&amp; extents(idxs(i)) &lt; this.sequenceLen - startCoors(idxs(i)) + 1
1082                         <span class="keyword">continue</span>;
1083                     <span class="keyword">end</span>
1084                     
1085                     tmpIdxs = find(<span class="keyword">...</span>
1086                         startCoors(i) &gt;= regionStartCoors &amp; <span class="keyword">...</span>
1087                         startCoors(i) &lt;= regionEndCoors &amp; <span class="keyword">...</span>
1088                         ismember(regionStrandTimes, strandTimes(i, :), <span class="string">'rows'</span>), 1, <span class="string">'first'</span>);
1089                     
1090                     <span class="keyword">if</span> ~isempty(tmpIdxs)
1091                         extents(idxs(i)) = extents(idxs(i)) + min(regionEndCoors(tmpIdxs), endCoors(i)) - startCoors(i) + 1;
1092                     <span class="keyword">end</span>
1093                 <span class="keyword">else</span>
1094                     <span class="keyword">if</span> i &gt; size(positionsStrands, 1) &amp;&amp; -extents(idxs(i)) &lt; endCoors(idxs(i))
1095                         <span class="keyword">continue</span>;
1096                     <span class="keyword">end</span>
1097                     
1098                     tmpIdxs = find(<span class="keyword">...</span>
1099                         endCoors(i) &gt;= regionStartCoors &amp; <span class="keyword">...</span>
1100                         endCoors(i) &lt;= regionEndCoors &amp; <span class="keyword">...</span>
1101                         ismember(regionStrandTimes, strandTimes(i, :), <span class="string">'rows'</span>), 1, <span class="string">'first'</span>);
1102                     
1103                     <span class="keyword">if</span> ~isempty(tmpIdxs)
1104                         extents(idxs(i)) = extents(idxs(i)) - (endCoors(i) - max(regionStartCoors(tmpIdxs), startCoors(i)) + 1);
1105                     <span class="keyword">end</span>
1106                 <span class="keyword">end</span>
1107             <span class="keyword">end</span>
1108             
1109             <span class="keyword">if</span> returnExtent
1110                 tfs = true(size(positionsStrands, 1), 1);
1111             <span class="keyword">else</span>
1112                 tfs = extents == lengths;
1113             <span class="keyword">end</span>
1114             
1115             idxs = reshape(find(tfs), [], 1);
1116             positionsStrands = positionsStrands(idxs, :);
1117             lengths = extents(idxs, :);
1118         <span class="keyword">end</span>
1119 
1120         <span class="comment">%lengths must be non-negative integer</span>
1121         <span class="comment">%releasableMonomerIndexs and releasableComplexIndexs must be sorted</span>
1122         <a name="_sub12" href="#_subfunctions" class="code">function [tfs, idxs, positionsStrands, lengths, monomers, complexs] = isRegionProteinFree(this, </a><span class="keyword">...</span>
1123                 positionsStrands, lengths, returnExtent, releasableMonomerIndexs, releasableComplexIndexs, bothStrands, allStrands)
1124             <span class="keyword">if</span> isempty(positionsStrands)
1125                 tfs = false(0, 1);
1126                 idxs = zeros(0, 1);
1127                 lengths = zeros(0, 1);
1128                 monomers = zeros(0, 0);
1129                 complexs = zeros(0, 0);
1130                 <span class="keyword">return</span>;
1131             <span class="keyword">end</span>
1132             
1133             <span class="keyword">if</span> numel(lengths) == 1
1134                 lengths = lengths(ones(size(positionsStrands, 1), 1), 1);
1135             <span class="keyword">end</span>
1136             <span class="keyword">if</span> nargin &lt; 8
1137                 allStrands = false;
1138             <span class="keyword">end</span>
1139             
1140             startCoors = mod(positionsStrands(:, 1) + min(0, lengths+1) - 1, this.sequenceLen) + 1;
1141             endCoors = startCoors + abs(lengths) - 1;
1142             strnds = positionsStrands(:, 2);
1143             <span class="keyword">if</span> bothStrands
1144                 strnds = ceil(strnds/2);
1145             <span class="keyword">end</span>
1146             <span class="keyword">if</span> allStrands
1147                 strnds(:) = 1;
1148             <span class="keyword">end</span>
1149             idxs = (1:size(positionsStrands, 1))';
1150             
1151             tmpIdxs = find(endCoors &gt; this.sequenceLen);
1152             startCoors = [startCoors; max(1, startCoors(tmpIdxs) - this.sequenceLen)];
1153             endCoors = [endCoors; endCoors(tmpIdxs) - this.sequenceLen];
1154             endCoors(tmpIdxs) = this.sequenceLen;
1155             strnds = [strnds; strnds(tmpIdxs, :)];
1156             idxs = [idxs; idxs(tmpIdxs)];
1157             
1158             tmpIdxs = find(startCoors &lt; 0);
1159             startCoors = [startCoors; startCoors(tmpIdxs) + this.sequenceLen];
1160             endCoors = [endCoors; min(this.sequenceLen, endCoors(tmpIdxs) + this.sequenceLen)];
1161             startCoors(tmpIdxs) = 1;
1162             strnds = [strnds; strnds(tmpIdxs, :)];
1163             idxs = [idxs; idxs(tmpIdxs)];
1164             
1165             <span class="comment">%initialize output</span>
1166             extents  = abs(lengths);
1167             monomers = sparse(size(positionsStrands, 1), max(abs([lengths; 0])));
1168             complexs = sparse(size(positionsStrands, 1), max(abs([lengths; 0])));
1169             
1170             <span class="comment">%bound monomers</span>
1171             [subs, vals] = find(this.monomerBoundSites);
1172             <span class="keyword">if</span> ~bothStrands
1173                 dsTfs = this.monomerDNAFootprintBindingStrandedness(vals) == this.dnaStrandedness_dsDNA;
1174                 subs = [
1175                     subs(~dsTfs, :)
1176                     subs( dsTfs, 1) 2*ceil(subs(dsTfs, 2)/2)-1
1177                     subs( dsTfs, 1) 2*ceil(subs(dsTfs, 2)/2)
1178                     ];
1179                 vals = [
1180                     vals(~dsTfs)
1181                     vals( dsTfs)
1182                     vals( dsTfs)
1183                     ];
1184                 [subs, order] = edu.stanford.covert.util.SparseMat.sort_subs(subs, [this.sequenceLen this.nCompartments]);
1185                 vals = vals(order, :);
1186             <span class="keyword">end</span>
1187             <span class="keyword">if</span> allStrands
1188                 tfs = ~ismembc(vals, this.monomerIndexs_replisome);
1189                 subs = subs(tfs, :);
1190                 vals = vals(tfs);
1191             <span class="keyword">end</span>
1192             monomerStarts = subs(:, 1);
1193             monomerEnds   = monomerStarts + this.monomerDNAFootprints(vals, :) - 1;
1194             monomerStrnds = subs(:, 2);
1195             <span class="keyword">if</span> bothStrands
1196                 monomerStrnds = ceil(monomerStrnds/2);
1197             <span class="keyword">end</span>
1198             <span class="keyword">if</span> allStrands
1199                 monomerStrnds(:) = 1;
1200             <span class="keyword">end</span>
1201             
1202             tmpIdxs = find(monomerEnds &gt; this.sequenceLen);
1203             monomerStarts = [monomerStarts; ones(numel(tmpIdxs), 1)];
1204             monomerEnds   = [monomerEnds;   monomerEnds(tmpIdxs, :) - this.sequenceLen];
1205             monomerStrnds = [monomerStrnds; monomerStrnds(tmpIdxs, :)];
1206             vals = [vals; vals(tmpIdxs, :)];
1207             
1208             <span class="keyword">for</span> i = 1:numel(startCoors)
1209                 monMask = <span class="keyword">...</span>
1210                     (monomerStarts &gt;= startCoors(i) &amp; monomerStarts &lt;= endCoors(i)) | <span class="keyword">...</span>
1211                     (monomerEnds &gt;= startCoors(i) &amp; monomerEnds &lt;= endCoors(i)) | <span class="keyword">...</span>
1212                     (monomerStarts &lt;= startCoors(i) &amp; monomerEnds &gt;= endCoors(i));
1213                 tmpIdxs = find(monMask);
1214                 <span class="keyword">if</span> isempty(tmpIdxs); <span class="keyword">continue</span>; <span class="keyword">end</span>;
1215                 
1216                 tmpIdxs = tmpIdxs(monomerStrnds(monMask, 1) ==  strnds(i, 1));
1217                 <span class="keyword">if</span> isempty(tmpIdxs); <span class="keyword">continue</span>; <span class="keyword">end</span>;
1218                 
1219                 <span class="keyword">if</span> lengths(idxs(i)) &gt; 0
1220                     <span class="keyword">if</span> i &lt;= size(positionsStrands, 1)
1221                         monomerPos = monomerStarts(tmpIdxs) - startCoors(i) + 1;
1222                     <span class="keyword">else</span>
1223                         monomerPos = monomerStarts(tmpIdxs) - startCoors(i) + 1 + (this.sequenceLen-positionsStrands(idxs(i), 1));
1224                     <span class="keyword">end</span>
1225                 <span class="keyword">else</span>
1226                     <span class="keyword">if</span> i &lt;= size(positionsStrands, 1)
1227                         monomerPos = endCoors(i) - monomerEnds(tmpIdxs) + 1;
1228                     <span class="keyword">else</span>
1229                         monomerPos = endCoors(i) - monomerEnds(tmpIdxs) + 1 + positionsStrands(idxs(i), 1);
1230                     <span class="keyword">end</span>
1231                 <span class="keyword">end</span>
1232                 monomerPos = max(monomerPos, 1);
1233                 
1234                 extents(idxs(i)) = min([
1235                     extents(idxs(i));
1236                     monomerPos(~ismembc(vals(tmpIdxs), releasableMonomerIndexs))-1]);
1237                 
1238                 monomers(idxs(i), monomerPos) = vals(tmpIdxs); <span class="comment">%#ok&lt;SPRIX&gt;</span>
1239             <span class="keyword">end</span>
1240             
1241             <span class="comment">%bound complexes</span>
1242             [subs, vals] = find(this.complexBoundSites);
1243             <span class="keyword">if</span> ~bothStrands
1244                 dsTfs = this.complexDNAFootprintBindingStrandedness(vals) == this.dnaStrandedness_dsDNA;
1245                 subs = [
1246                     subs(~dsTfs, :)
1247                     subs( dsTfs, 1) 2*ceil(subs(dsTfs, 2)/2)-1
1248                     subs( dsTfs, 1) 2*ceil(subs(dsTfs, 2)/2)
1249                     ];
1250                 vals = [
1251                     vals(~dsTfs)
1252                     vals( dsTfs)
1253                     vals( dsTfs)
1254                     ];
1255                 [subs, order] = edu.stanford.covert.util.SparseMat.sort_subs(subs, [this.sequenceLen this.nCompartments]);
1256                 vals = vals(order, :);
1257             <span class="keyword">end</span>
1258             <span class="keyword">if</span> allStrands
1259                 tfs = ~ismembc(vals, this.complexIndexs_replisome);
1260                 subs = subs(tfs, :);
1261                 vals = vals(tfs);
1262             <span class="keyword">end</span>
1263             complexStarts = subs(:, 1);
1264             complexEnds   = complexStarts + this.complexDNAFootprints(vals, :) - 1;
1265             complexStrnds = subs(:, 2);
1266             <span class="keyword">if</span> bothStrands
1267                 complexStrnds = ceil(complexStrnds/2);
1268             <span class="keyword">end</span>
1269             <span class="keyword">if</span> allStrands
1270                 complexStrnds(:) = 1;
1271             <span class="keyword">end</span>
1272             
1273             tmpIdxs = find(complexEnds &gt; this.sequenceLen);
1274             complexStarts = [complexStarts; ones(numel(tmpIdxs), 1)];
1275             complexEnds   = [complexEnds;   complexEnds(tmpIdxs, :) - this.sequenceLen];
1276             complexStrnds = [complexStrnds; complexStrnds(tmpIdxs, :)];
1277             vals = [vals; vals(tmpIdxs, :)];
1278             
1279             <span class="keyword">for</span> i = 1:numel(startCoors)
1280                 comMask = <span class="keyword">...</span>
1281                     (complexStarts &gt;= startCoors(i) &amp; complexStarts &lt;= endCoors(i)) | <span class="keyword">...</span>
1282                     (complexEnds &gt;= startCoors(i) &amp; complexEnds &lt;= endCoors(i)) | <span class="keyword">...</span>
1283                     (complexStarts &lt;= startCoors(i) &amp; complexEnds &gt;= endCoors(i));
1284                 tmpIdxs = find(comMask);
1285                 <span class="keyword">if</span> isempty(tmpIdxs); <span class="keyword">continue</span>; <span class="keyword">end</span>;
1286                 
1287                 tmpIdxs = tmpIdxs(complexStrnds(comMask, 1) ==  strnds(i, 1));
1288                 <span class="keyword">if</span> isempty(tmpIdxs); <span class="keyword">continue</span>; <span class="keyword">end</span>;
1289                 
1290                 <span class="keyword">if</span> lengths(idxs(i)) &gt; 0
1291                     <span class="keyword">if</span> i &lt;= size(positionsStrands, 1)
1292                         complexPos = complexStarts(tmpIdxs) - startCoors(i) + 1;
1293                     <span class="keyword">else</span>
1294                         complexPos = complexStarts(tmpIdxs) - startCoors(i) + 1 + (this.sequenceLen-positionsStrands(idxs(i), 1));
1295                     <span class="keyword">end</span>
1296                 <span class="keyword">else</span>
1297                     <span class="keyword">if</span> i &lt;= size(positionsStrands, 1)
1298                         complexPos = endCoors(i) - complexEnds(tmpIdxs) + 1;
1299                     <span class="keyword">else</span>
1300                         complexPos = endCoors(i) - complexEnds(tmpIdxs) + 1 + positionsStrands(idxs(i), 1);
1301                     <span class="keyword">end</span>
1302                 <span class="keyword">end</span>
1303                 complexPos = max(complexPos, 1);
1304                 
1305                 extents(idxs(i)) = min([
1306                     extents(idxs(i));
1307                     complexPos(~ismembc(vals(tmpIdxs), releasableComplexIndexs))-1]);
1308                 
1309                 complexs(idxs(i), complexPos) = vals(tmpIdxs); <span class="comment">%#ok&lt;SPRIX&gt;</span>
1310             <span class="keyword">end</span>
1311             
1312             <span class="comment">%format output</span>
1313             extents = sign(lengths) .* extents;
1314             <span class="keyword">if</span> returnExtent
1315                 tfs = true(size(positionsStrands, 1), 1);
1316             <span class="keyword">else</span>
1317                 tfs = extents == lengths;
1318             <span class="keyword">end</span>
1319             idxs = reshape(find(tfs), [], 1);
1320             positionsStrands = positionsStrands(idxs, :);
1321             lengths = extents(idxs, :);
1322         <span class="keyword">end</span>
1323         
1324         <span class="comment">%lengths must be non-negative integer</span>
1325         <a name="_sub13" href="#_subfunctions" class="code">function [tfs, idxs, positionsStrands, lengths] = isRegionUndamaged(this, </a><span class="keyword">...</span>
1326                 positionsStrands, lengths, isEitherStrandDamaged, ignoreDamageFilter, returnExtent, isAnyStrandDamaged)
1327             <span class="keyword">if</span> isempty(positionsStrands)
1328                 tfs = false(0, 1);
1329                 idxs = zeros(0, 1);
1330                 lengths = zeros(0, 1);
1331                 <span class="keyword">return</span>;
1332             <span class="keyword">end</span>
1333             
1334             <span class="keyword">if</span> numel(lengths) == 1
1335                 lengths = lengths(ones(size(positionsStrands, 1), 1), 1);
1336             <span class="keyword">end</span>
1337             <span class="keyword">if</span> nargin &lt; 7
1338                 isAnyStrandDamaged = false;
1339             <span class="keyword">end</span>
1340             
1341             [damagedPosStrnds, damages] = find(this.damagedSites);
1342             <span class="keyword">if</span> isempty(damages)
1343                 tfs = true(size(lengths));
1344                 idxs = (1:numel(lengths))';
1345                 <span class="keyword">return</span>;
1346             <span class="keyword">end</span>
1347             
1348             <span class="keyword">if</span> isempty(ignoreDamageFilter)
1349                 ignoreDamageFilter = zeros(size(positionsStrands, 1), 0);
1350             <span class="keyword">elseif</span> size(ignoreDamageFilter, 1) &lt;= 1
1351                 ignoreDamageFilter = reshape(ignoreDamageFilter(ones(size(positionsStrands, 1), 1), :), size(positionsStrands, 1), []);
1352             <span class="keyword">end</span>
1353                         
1354             damagedPositions   = damagedPosStrnds(:, 1);
1355             damagedStrandTimes = [damagedPosStrnds(:, 2:end) ones(size(damagedPosStrnds, 1), size(positionsStrands, 2) - size(damagedPosStrnds, 2))];
1356             strandTimes        = [positionsStrands(:, 2:end) ones(size(positionsStrands, 1), size(damagedPosStrnds, 2) - size(positionsStrands, 2))];
1357             
1358             <span class="keyword">if</span> isAnyStrandDamaged
1359                 strandTimes(:, 1) = 1;
1360                 damagedStrandTimes(:, 1) = 1;
1361             <span class="keyword">elseif</span> isEitherStrandDamaged
1362                 strandTimes(:, 1) = ceil(strandTimes(:, 1) / 2);
1363                 damagedStrandTimes(:, 1) = ceil(damagedStrandTimes(:, 1) / 2);
1364             <span class="keyword">end</span>
1365                         
1366             startPositions = mod(positionsStrands(:, 1) + min(0, lengths+1) - 1, this.sequenceLen) + 1;
1367             endPositions   = startPositions + abs(lengths) - 1;
1368             idxs = (1:size(positionsStrands,1))';
1369             
1370             tmpIdxs = find(endPositions &gt; this.sequenceLen);
1371             strandTimes = [strandTimes; strandTimes(tmpIdxs)];
1372             startPositions = [startPositions; max(1, startPositions(tmpIdxs) - this.sequenceLen)];
1373             endPositions = [endPositions; endPositions(tmpIdxs) - this.sequenceLen];
1374             endPositions(tmpIdxs) = this.sequenceLen;
1375             idxs = [idxs; idxs(tmpIdxs)];
1376             
1377             tmpIdxs = find(startPositions &lt; 0);
1378             strandTimes = [strandTimes; strandTimes(tmpIdxs)];
1379             startPositions = [startPositions; startPositions(tmpIdxs) + this.sequenceLen];
1380             endPositions = [endPositions; min(this.sequenceLen, endPositions(tmpIdxs) + this.sequenceLen)];
1381             startPositions(tmpIdxs) = 1;
1382             idxs = [idxs; idxs(tmpIdxs)];
1383             
1384             extents = zeros(size(positionsStrands,1), 1);
1385             <span class="keyword">for</span> i = 1:numel(startPositions)
1386                 tmpIdxs = <span class="keyword">...</span>
1387                     damagedPositions &gt;= startPositions(i, 1) &amp; <span class="keyword">...</span>
1388                     damagedPositions &lt;= endPositions(i, 1) &amp; <span class="keyword">...</span>
1389                     ismember(damagedStrandTimes, strandTimes(i, :), <span class="string">'rows'</span>);
1390                 
1391                 <span class="keyword">if</span> lengths(idxs(i)) &gt; 0
1392                     <span class="keyword">if</span> i &gt; size(positionsStrands, 1) &amp;&amp; extents(idxs(i)) &lt; this.sequenceLen - startPositions(idxs(i)) + 1
1393                         <span class="keyword">continue</span>;
1394                     <span class="keyword">end</span>
1395                     
1396                     <span class="keyword">if</span> i &lt;= size(positionsStrands, 1)
1397                         tmpIgnoreDamageFilter = ignoreDamageFilter(idxs(i), :);
1398                     <span class="keyword">else</span>
1399                         tmpIgnoreDamageFilter = ignoreDamageFilter(idxs(i), :) - (this.sequenceLen - startPositions(idxs(i)) + 1);
1400                     <span class="keyword">end</span>
1401                     
1402                     extent = min(setdiff(damagedPositions(tmpIdxs) - startPositions(i) + 1, tmpIgnoreDamageFilter)) - 1;
1403                     <span class="keyword">if</span> isempty(extent)
1404                         extent = endPositions(i) - startPositions(i) + 1;
1405                     <span class="keyword">end</span>
1406                     extents(idxs(i)) = extents(idxs(i)) + extent;
1407                 <span class="keyword">else</span>
1408                     <span class="keyword">if</span> i &lt;= size(positionsStrands, 1)
1409                         tmpIgnoreDamageFilter = ignoreDamageFilter(idxs(i), :);
1410                     <span class="keyword">else</span>
1411                         tmpIgnoreDamageFilter = ignoreDamageFilter(idxs(i), :) + positionsStrands(idxs(i), 1);
1412                     <span class="keyword">end</span>
1413                     
1414                     extent = min(setdiff(endPositions(i) - damagedPositions(tmpIdxs) + 1, tmpIgnoreDamageFilter - lengths(idxs(i)) - 1)) - 1;
1415                     <span class="keyword">if</span> isempty(extent)
1416                         extents(idxs(i)) = extents(idxs(i)) -(endPositions(i) - startPositions(i) + 1);
1417                     <span class="keyword">else</span>
1418                         extents(idxs(i)) = extents(idxs(i)) - extent;
1419                     <span class="keyword">end</span>
1420                 <span class="keyword">end</span>
1421             <span class="keyword">end</span>
1422             
1423             <span class="keyword">if</span> returnExtent
1424                 tfs = true(size(positionsStrands, 1), 1);
1425             <span class="keyword">else</span>
1426                 tfs = extents == lengths;
1427             <span class="keyword">end</span>
1428             idxs = reshape(find(tfs), [], 1);
1429             positionsStrands = positionsStrands(idxs, :);
1430             lengths = extents(idxs, :);
1431         <span class="keyword">end</span>
1432     <span class="keyword">end</span>
1433     
1434     <span class="comment">%additional private methods used to query state</span>
1435     methods
1436         <span class="comment">%Converts from the base-pair centric view of the chromosomes that this</span>
1437         <span class="comment">%class uses to a strand-centric view where each column represents a</span>
1438         <span class="comment">%single strand.</span>
1439         <a name="_sub14" href="#_subfunctions" class="code">function varargout = getStrandView(this, outputs)</a>
1440             import edu.stanford.covert.util.CircularSparseMat;
1441             
1442             <span class="keyword">if</span> nargin &lt; 2
1443                 outputs = {
1444                     <span class="string">'polymerizedRegions'</span>;
1445                     <span class="string">'monomerBoundSites'</span>;
1446                     <span class="string">'complexBoundSites'</span>;
1447                     <span class="string">'gapSites'</span>;
1448                     <span class="string">'abasicSites'</span>;
1449                     <span class="string">'damagedSugarPhosphates'</span>;
1450                     <span class="string">'damagedBases'</span>;
1451                     <span class="string">'intrastrandCrossLinks'</span>;
1452                     <span class="string">'strandBreaks'</span>;
1453                     <span class="string">'hollidayJunctions'</span>;
1454                     };
1455             <span class="keyword">end</span>
1456             <span class="keyword">if</span> ~iscell(outputs)
1457                 outputs = {outputs};
1458             <span class="keyword">end</span>
1459             <span class="keyword">if</span> numel(outputs) &lt; nargout
1460                 throw(MException(<span class="string">'Chromosome:tooManyOutputs'</span>, <span class="string">'Too many outputs requested'</span>));
1461             <span class="keyword">end</span>
1462             
1463             varargout = cell(nargout, 1);            
1464             <span class="keyword">for</span> i = 1:nargout
1465                 tmp = this.(outputs{i});
1466                 <span class="keyword">switch</span> outputs{i}
1467                     <span class="keyword">case</span> <span class="string">'polymerizedRegions'</span>
1468                         [positionsStrands, lengths] = find(this.polymerizedRegions);
1469                         positionsStrands = [positionsStrands ones(size(positionsStrands,1), 3-size(positionsStrands,2))];
1470                         idx1 = find(positionsStrands(:,2) == this.strandIndexs_negative(1));
1471                         idx2 = find(positionsStrands(:,2) == this.strandIndexs_negative(2));
1472                         
1473                         starts1 = positionsStrands(idx1, 1);
1474                         starts2 = positionsStrands(idx2, 1);
1475                         ends1 = starts1 + lengths(idx1) - 1;
1476                         ends2 = starts2 + lengths(idx2) - 1;
1477                         times1 = positionsStrands(idx1, 3:end);
1478                         times2 = positionsStrands(idx2, 3:end);
1479                         
1480                         tmpStarts2 = zeros(0,1);
1481                         tmpEnds2 = zeros(0,1);
1482                         tmpTimes2 = zeros(0,size(times2,2));
1483                         <span class="keyword">for</span> j = 1:numel(idx2)
1484                             idx = find(<span class="keyword">...</span>
1485                                 ((starts1 &gt;= starts2(j) &amp; starts1 &lt;= ends2(j)) | <span class="keyword">...</span>
1486                                 (ends1    &gt;= starts2(j) &amp; ends1   &lt;= ends2(j)) | <span class="keyword">...</span>
1487                                 (starts1  &lt;= starts2(j) &amp; ends1   &gt;= ends2(j))) &amp; <span class="keyword">...</span>
1488                                 all(times1 == times2(j, :), 2));                                                                                   
1489                             
1490                             tmpStarts2 = [tmpStarts2;
1491                                 max(starts1(idx), starts2(j))];
1492                             tmpEnds2 = [tmpEnds2;
1493                                 min(ends1(idx), ends2(j))];
1494                             tmpTimes2 = [tmpTimes2;
1495                                 times1(idx, :)];
1496                             
1497                             starts1 = [starts1(setdiff(1:<span class="keyword">end</span>, idx));
1498                                 min([starts1(idx); starts2(j)])];
1499                             ends1 = [ends1(setdiff(1:<span class="keyword">end</span>, idx));
1500                                 max([ends1(idx); ends2(j)])];
1501                             times1 = [times1(setdiff(1:<span class="keyword">end</span>, idx), :);
1502                                 times2(j)];
1503                         <span class="keyword">end</span>
1504                         
1505                         tmpPosStrnds = [positionsStrands(setdiff(1:<span class="keyword">end</span>, [idx1; idx2]), :);
1506                             starts1 this.strandIndexs_negative(ones(numel(starts1), 1)) times1;
1507                             tmpStarts2 this.strandIndexs_negative(2 * ones(numel(tmpStarts2), 1)) tmpTimes2];
1508                         tmpLengths = [lengths(setdiff(1:<span class="keyword">end</span>, [idx1; idx2]), :);
1509                             ends1 - starts1 + 1;
1510                             tmpEnds2 - tmpStarts2 + 1;];                        
1511                         tmp = CircularSparseMat(tmpPosStrnds, tmpLengths, size(tmp), 1);
1512                         tmp = this.mergeAdjacentRegions(tmp);
1513                     <span class="keyword">case</span> <span class="string">'linkingNumbers'</span>
1514                         throw(MException(<span class="string">'Chromosome:tooLazy'</span>, <span class="string">'You''re going to have to write this yourself.'</span>));
1515                     <span class="keyword">otherwise</span>
1516                         [positionsStrands, lengths] = find(this.polymerizedRegions(:, this.strandIndexs_negative(2), :));            
1517                         [tmpPosStrnds, tmpVals] = find(tmp);
1518                         
1519                         positionsStrands = [positionsStrands ones(size(positionsStrands,1), 3-size(positionsStrands,2))];
1520                         tmpPosStrnds = [tmpPosStrnds ones(size(tmpPosStrnds,1), 3-size(tmpPosStrnds,2))];
1521                         <span class="keyword">for</span> j = size(positionsStrands, 1)
1522                             idx1 = <span class="keyword">...</span>
1523                                 tmpPosStrnds(:, 1) &gt;= positionsStrands(j, 1) &amp; <span class="keyword">...</span>
1524                                 tmpPosStrnds(:, 1) &lt;= positionsStrands(j, 1) + lengths(j)-1 &amp; <span class="keyword">...</span>
1525                                 tmpPosStrnds(:, 2) == this.strandIndexs_negative(1) &amp; <span class="keyword">...</span>
1526                                 all(tmpPosStrnds(:, 3:end) == positionsStrands(j, 3:end), 2);
1527                             idx2 = <span class="keyword">...</span>
1528                                 tmpPosStrnds(:, 1) &gt;= positionsStrands(j, 1) &amp; <span class="keyword">...</span>
1529                                 tmpPosStrnds(:, 1) &lt;= positionsStrands(j, 1) + lengths(j)-1 &amp; <span class="keyword">...</span>
1530                                 tmpPosStrnds(:, 2) == this.strandIndexs_negative(2) &amp; <span class="keyword">...</span>
1531                                 all(tmpPosStrnds(:, 3:end) == positionsStrands(j, 3:end), 2);
1532                             tmpPosStrnds(idx1, 2) = this.strandIndexs_negative(2);
1533                             tmpPosStrnds(idx2, 2) = this.strandIndexs_negative(1);
1534                         <span class="keyword">end</span>
1535                         tmp = CircularSparseMat(tmpPosStrnds, tmpVals, size(tmp), 1);
1536                 <span class="keyword">end</span>
1537                 varargout{i} = tmp;
1538             <span class="keyword">end</span>
1539         <span class="keyword">end</span>
1540         
1541         <span class="comment">%Calculates the footprint of a group of proteins as the maximum of their</span>
1542         <span class="comment">%individual footprints. Also calculates the number of bases that the</span>
1543         <span class="comment">%footprint spans 3'- and 5'- to the centroid base of the footprint.</span>
1544         <a name="_sub15" href="#_subfunctions" class="code">function [footprint, footprint3Prime, footprint5Prime, bindingStrandedness, regionStrandedness] = getDNAFootprint(this, monomers, complexs)</a>
1545             footprint = max([1;
1546                 this.monomerDNAFootprints(monomers);
1547                 this.complexDNAFootprints(complexs)]);
1548             
1549             [footprint3Prime, footprint5Prime] = this.calculateFootprintOverhangs(footprint);
1550             
1551             bindingStrandedness = [this.monomerDNAFootprintBindingStrandedness(monomers); this.complexDNAFootprintBindingStrandedness(complexs)];
1552             <span class="keyword">if</span> isempty(bindingStrandedness)
1553                 bindingStrandedness = this.dnaStrandedness_dsDNA;
1554             <span class="keyword">elseif</span> ~isscalar(bindingStrandedness)
1555                 <span class="keyword">if</span> any(bindingStrandedness ~= bindingStrandedness(1))
1556                     throw(MException(<span class="string">'Chromosome:invalidInput'</span>,<span class="string">'Footprints must be of a single strandedness'</span>));
1557                 <span class="keyword">else</span>
1558                     bindingStrandedness = bindingStrandedness(1);
1559                 <span class="keyword">end</span>
1560             <span class="keyword">end</span>
1561             
1562             regionStrandedness = [this.monomerDNAFootprintRegionStrandedness(monomers); this.complexDNAFootprintRegionStrandedness(complexs)];
1563             <span class="keyword">if</span> isempty(regionStrandedness)
1564                 regionStrandedness = this.dnaStrandedness_dsDNA;
1565             <span class="keyword">elseif</span> ~isscalar(regionStrandedness)
1566                 <span class="keyword">if</span> any(regionStrandedness ~= regionStrandedness(1))
1567                     throw(MException(<span class="string">'Chromosome:invalidInput'</span>,<span class="string">'Footprints must be of a single strandedness'</span>));
1568                 <span class="keyword">else</span>
1569                     regionStrandedness = regionStrandedness(1);
1570                 <span class="keyword">end</span>
1571             <span class="keyword">end</span>
1572         <span class="keyword">end</span>
1573         
1574         <span class="comment">%return sorted releasableMonomerIndexs, releasableComplexIndexs</span>
1575         <a name="_sub16" href="#_subfunctions" class="code">function [releasableMonomerIndexs, releasableComplexIndexs] = getReleasableProteins(this, bindingMonomers, bindingComplexs)</a>
1576             releasableMonomerIndexs = this.reactionBoundMonomer .* (<span class="keyword">...</span>
1577                 sum(this.reactionMonomerCatalysisMatrix(:, bindingMonomers), 2) + <span class="keyword">...</span>
1578                 sum(this.reactionComplexCatalysisMatrix(:, bindingComplexs), 2) &gt;= <span class="keyword">...</span>
1579                 this.reactionThresholds);
1580             
1581             <span class="keyword">if</span> any(releasableMonomerIndexs)
1582                 releasableMonomerIndexs = sort(releasableMonomerIndexs);
1583                 <span class="keyword">if</span> ~isempty(releasableMonomerIndexs)
1584                     releasableMonomerIndexs = releasableMonomerIndexs([diff(releasableMonomerIndexs) ~= 0; true], 1);
1585                 <span class="keyword">end</span>
1586             <span class="keyword">else</span>
1587                 releasableMonomerIndexs = 0;
1588             <span class="keyword">end</span>
1589             
1590             releasableComplexIndexs = this.reactionBoundComplex .* (<span class="keyword">...</span>
1591                 sum(this.reactionMonomerCatalysisMatrix(:, bindingMonomers), 2) + <span class="keyword">...</span>
1592                 sum(this.reactionComplexCatalysisMatrix(:, bindingComplexs), 2) &gt;= <span class="keyword">...</span>
1593                 this.reactionThresholds);
1594             <span class="keyword">if</span> any(releasableComplexIndexs)
1595                 releasableComplexIndexs = sort(releasableComplexIndexs);
1596                 <span class="keyword">if</span> ~isempty(releasableComplexIndexs)
1597                     releasableComplexIndexs = releasableComplexIndexs([diff(releasableComplexIndexs) ~= 0; true], 1);
1598                 <span class="keyword">end</span>
1599             <span class="keyword">else</span>
1600                 releasableComplexIndexs = 0;
1601             <span class="keyword">end</span>
1602         <span class="keyword">end</span>
1603         
1604         <span class="comment">%Estimates regions that are accessible to a given protein species. That is</span>
1605         <span class="comment">%regions:</span>
1606         <span class="comment">%- that are polymerized, and have the strandedness that the protein requires</span>
1607         <span class="comment">%- that are not already bound by the specified protein species</span>
1608         <a name="_sub17" href="#_subfunctions" class="code">function [rgnPosStrnds, rgnLens] = getAccessibleRegions(this, monomerIdx, complexIdx, checkRegionSupercoiled)</a>
1609             <span class="keyword">if</span> nargin &lt; 4
1610                 checkRegionSupercoiled = false;
1611             <span class="keyword">end</span>
1612             
1613             <span class="comment">%find lengths and type of footprint</span>
1614             [dnaFtpt, ~, ~, dnaFtptBindingStrandedness, dnaFtptRegionStrandedness] = this.getDNAFootprint(monomerIdx, complexIdx);
1615             
1616             <span class="comment">%initialize excluded regions</span>
1617             excPosStrnds = [];
1618             excLens = [];
1619             
1620             <span class="comment">%exclude regions which are bound by proteins</span>
1621             [releasableMonomerIndexs, releasableComplexIndexs] = this.getReleasableProteins(monomerIdx, complexIdx);
1622             
1623             [monPosStrnds, mons] = find(this.monomerBoundSites);
1624             [cpxPosStrnds, cpxs] = find(this.complexBoundSites);
1625             
1626             iMonSS = find(~ismembc(mons, releasableMonomerIndexs) &amp; this.monomerDNAFootprintBindingStrandedness(mons) == this.dnaStrandedness_ssDNA);
1627             iMonDS = find(~ismembc(mons, releasableMonomerIndexs) &amp; this.monomerDNAFootprintBindingStrandedness(mons) == this.dnaStrandedness_dsDNA);
1628             iCpxSS = find(~ismembc(cpxs, releasableComplexIndexs) &amp; this.complexDNAFootprintBindingStrandedness(cpxs) == this.dnaStrandedness_ssDNA);
1629             iCpxDS = find(~ismembc(cpxs, releasableComplexIndexs) &amp; this.complexDNAFootprintBindingStrandedness(cpxs) == this.dnaStrandedness_dsDNA);
1630             
1631             excPosStrnds = [
1632                 excPosStrnds
1633                 monPosStrnds(iMonSS, :)
1634                 monPosStrnds(iMonDS, 1) 2*ceil(monPosStrnds(iMonDS, 2)/2)-1
1635                 monPosStrnds(iMonDS, 1) 2*ceil(monPosStrnds(iMonDS, 2)/2)
1636                 cpxPosStrnds(iCpxSS, :)
1637                 cpxPosStrnds(iCpxDS, 1) 2*ceil(cpxPosStrnds(iCpxDS, 2)/2)-1
1638                 cpxPosStrnds(iCpxDS, 1) 2*ceil(cpxPosStrnds(iCpxDS, 2)/2)
1639                 ];
1640             excLens = [
1641                 excLens
1642                 this.monomerDNAFootprints(mons(iMonSS))
1643                 this.monomerDNAFootprints(mons(iMonDS))
1644                 this.monomerDNAFootprints(mons(iMonDS))
1645                 this.complexDNAFootprints(cpxs(iCpxSS))
1646                 this.complexDNAFootprints(cpxs(iCpxDS))
1647                 this.complexDNAFootprints(cpxs(iCpxDS))
1648                 ];
1649             
1650             <span class="comment">%exclude regions which are damaged</span>
1651             dmgPosStrnds = find(this.damagedSites);
1652             
1653             excPosStrnds = [
1654                 excPosStrnds;
1655                 dmgPosStrnds];
1656             excLens = [
1657                 excLens;
1658                 ones(size(dmgPosStrnds, 1), 1)];
1659             
1660             <span class="comment">%exclude other strand if proteins by both strands</span>
1661             <span class="keyword">if</span> dnaFtptBindingStrandedness == this.dnaStrandedness_dsDNA
1662                 excPosStrnds(:, 2) = ceil(excPosStrnds(:, 2) / 2);
1663             <span class="keyword">end</span>
1664             
1665             <span class="comment">%find polymerized regions</span>
1666             <span class="keyword">switch</span> dnaFtptRegionStrandedness
1667                 <span class="keyword">case</span> this.dnaStrandedness_ssDNA
1668                     <span class="keyword">if</span> dnaFtptBindingStrandedness == this.dnaStrandedness_ssDNA
1669                         [polRgnPosStrnds, polRgnLens] = find(this.singleStrandedRegions);
1670                     <span class="keyword">else</span>
1671                         throw(MException(<span class="string">'Chromosome:error'</span>, <span class="string">'unsupported strandedness: %s'</span>, dnaFtptRegionStrandedness));
1672                     <span class="keyword">end</span>
1673                 <span class="keyword">case</span> this.dnaStrandedness_dsDNA
1674                     <span class="keyword">if</span> dnaFtptBindingStrandedness == this.dnaStrandedness_dsDNA
1675                         [polRgnPosStrnds, polRgnLens] = find(this.doubleStrandedRegions(:, 1:2:end));
1676                         <span class="keyword">if</span> checkRegionSupercoiled
1677                             tfs = this.supercoiled([polRgnPosStrnds(:, 1) 2 * polRgnPosStrnds(:, 2)]);
1678                             polRgnPosStrnds = polRgnPosStrnds(tfs, :);
1679                             polRgnLens = polRgnLens(tfs, :);
1680                         <span class="keyword">end</span>
1681                     <span class="keyword">else</span>
1682                         [polRgnPosStrnds, polRgnLens] = find(this.doubleStrandedRegions);
1683                         <span class="keyword">if</span> checkRegionSupercoiled
1684                             tfs = this.supercoiled(polRgnPosStrnds);
1685                             polRgnPosStrnds = polRgnPosStrnds(tfs, :);
1686                             polRgnLens = polRgnLens(tfs, :);
1687                         <span class="keyword">end</span>
1688                     <span class="keyword">end</span>
1689                 <span class="keyword">otherwise</span>
1690                     throw(MException(<span class="string">'Chromosome:error'</span>, <span class="string">'unsupported strandedness: %s'</span>, dnaFtptRegionStrandedness));
1691             <span class="keyword">end</span>
1692             
1693             <span class="comment">%find difference of polymerized and excluded regions</span>
1694             [rgnPosStrnds, rgnLens] = this.excludeRegions(polRgnPosStrnds, polRgnLens, excPosStrnds, excLens);
1695             
1696             <span class="comment">%return strands</span>
1697             <span class="keyword">if</span> dnaFtptBindingStrandedness == this.dnaStrandedness_dsDNA
1698                 rgnPosStrnds(:, 2) = 2 * rgnPosStrnds(:, 2) - 1;
1699             <span class="keyword">end</span>
1700             
1701             <span class="comment">%return only regions with length at least dnaFtpt</span>
1702             idx = find(rgnLens &gt;= dnaFtpt);
1703             rgnPosStrnds = rgnPosStrnds(idx, :);
1704             rgnLens = rgnLens(idx, :);
1705         <span class="keyword">end</span>
1706         
1707         <a name="_sub18" href="#_subfunctions" class="code">function value = getDamagedSites(this, includeBases, includeBonds, includeBase5Prime, includeBond5Prime, includeBase3Prime, includeBond3Prime, includeM6AD)</a>
1708             import edu.stanford.covert.util.CircularSparseMat;                        
1709             
1710             <span class="keyword">if</span> ~includeBases
1711                 value = CircularSparseMat([], [], size(this.gapSites), 1);
1712             <span class="keyword">else</span>
1713                 <span class="comment">%damaged based</span>
1714                 <span class="keyword">if</span> includeM6AD
1715                     value = this.damagedBases;
1716                 <span class="keyword">else</span>
1717                     [posStrnds, dmgs] = find(this.damagedBases);
1718                     posStrnds(dmgs == this.metabolite.m6ADIndexs, :) = [];
1719                     dmgs(dmgs == this.metabolite.m6ADIndexs, :) = [];
1720                     value = CircularSparseMat(posStrnds, dmgs, [this.sequenceLen this.nCompartments], 1);
1721                 <span class="keyword">end</span>
1722                 
1723                 <span class="keyword">if</span> nnz(this.gapSites)
1724                     value = value + this.gapSites;
1725                 <span class="keyword">end</span>
1726                 <span class="keyword">if</span> nnz(this.abasicSites)
1727                     value = value + this.abasicSites;
1728                 <span class="keyword">end</span>
1729                 <span class="keyword">if</span> nnz(this.damagedSugarPhosphates)
1730                     value = value + this.damagedSugarPhosphates;
1731                 <span class="keyword">end</span>
1732                 <span class="keyword">if</span> nnz(this.intrastrandCrossLinks)
1733                     value = value + this.intrastrandCrossLinks;
1734                     <span class="keyword">if</span> includeBase5Prime
1735                         value = value + this.intrastrandCrossLinks5;
1736                     <span class="keyword">end</span>
1737                     <span class="keyword">if</span> includeBase3Prime
1738                         value = value + this.intrastrandCrossLinks3;
1739                     <span class="keyword">end</span>
1740                 <span class="keyword">end</span>
1741             <span class="keyword">end</span>
1742             
1743             <span class="keyword">if</span> includeBonds
1744                 <span class="keyword">if</span> nnz(this.strandBreaks)
1745                     value = value + this.strandBreaks;
1746                     <span class="keyword">if</span> includeBond5Prime
1747                         value = value + this.strandBreaks5;
1748                     <span class="keyword">end</span>
1749                     <span class="keyword">if</span> includeBond3Prime
1750                         value = value + this.strandBreaks3;
1751                     <span class="keyword">end</span>
1752                 <span class="keyword">end</span>
1753                 <span class="keyword">if</span> nnz(this.hollidayJunctions)
1754                     value = value + this.hollidayJunctions;
1755                     <span class="keyword">if</span> includeBond5Prime
1756                         value = value + this.hollidayJunctions5;
1757                     <span class="keyword">end</span>
1758                     <span class="keyword">if</span> includeBond3Prime
1759                         value = value + this.hollidayJunctions3;
1760                     <span class="keyword">end</span>
1761                 <span class="keyword">end</span>
1762             <span class="keyword">end</span>
1763         <span class="keyword">end</span>
1764     <span class="keyword">end</span>
1765     
1766     <span class="comment">%additional methods which query, but do not modify state</span>
1767     <span class="comment">%unlike those above, these methods are very focused; they return information</span>
1768     <span class="comment">%about the Chromosome useful to only specific processes</span>
1769     methods
1770         <a name="_sub19" href="#_subfunctions" class="code">function [unmethylatedSites, hemimethylatedSites, methylatedSites, cleavedSites, inaccessibleRegions] = rmStatus(this, </a><span class="keyword">...</span>
1771                 sites, methylatedPositions, restrictionPositions, bindingMonomers, bindingComplexs)
1772             import edu.stanford.covert.util.SparseMat;
1773             
1774             warningState = warning(<span class="string">'query'</span>, <span class="string">'SparseMat:inefficient'</span>);
1775             warning(<span class="string">'off'</span>, <span class="string">'SparseMat:inefficient'</span>);
1776             
1777             <span class="keyword">if</span> nargin &lt; 5
1778                 bindingMonomers = [];
1779             <span class="keyword">end</span>
1780             <span class="keyword">if</span> nargin &lt; 6
1781                 bindingComplexs = [];
1782             <span class="keyword">end</span>
1783             
1784             nonmethylatedPositions = [
1785                 1:methylatedPositions(1)-1 methylatedPositions(1)+1:size(sites,2);
1786                 1:methylatedPositions(2)-1 methylatedPositions(2)+1:size(sites,2)]';
1787             nonRestrictionPositions = [
1788                 1:restrictionPositions(1)-1 restrictionPositions(1)+1:size(sites,2);
1789                 1:restrictionPositions(2)-1 restrictionPositions(2)+1:size(sites,2)]';
1790             
1791             sitesChromosomesPositions = [
1792                 size(sites, 1)
1793                 size(sites, 2)
1794                 size(this.damagedBases, 2)/2
1795                 size(this.damagedBases, 3)
1796                 ]';
1797             
1798             damagedRegions = <span class="keyword">...</span>
1799                 (                this.damagedBases(                  sites(:,methylatedPositions(1)),                   1:2:<span class="keyword">end</span>,:)~=this.metabolite.m6ADIndexs &gt;0 &amp; <span class="keyword">...</span>
1800                 this.damagedBases(                  sites(:,methylatedPositions(1)),                   1:2:<span class="keyword">end</span>,:)~=0                                       &gt;0)   | <span class="keyword">...</span>
1801                 (                this.damagedBases(                  sites(:,methylatedPositions(2)),                   2:2:<span class="keyword">end</span>,:)~=this.metabolite.m6ADIndexs &gt;0 &amp; <span class="keyword">...</span>
1802                 this.damagedBases(                  sites(:,methylatedPositions(2)),                   2:2:<span class="keyword">end</span>,:)~=0                                       &gt;0)   | <span class="keyword">...</span>
1803                 xor(             this.strandBreaks(                  sites(:,restrictionPositions(1)),                  1:2:<span class="keyword">end</span>,:), <span class="keyword">...</span>
1804                 this.strandBreaks(                  sites(:,restrictionPositions(2)),                  2:2:<span class="keyword">end</span>,:))                                               | <span class="keyword">...</span>
1805                 collapse(reshape(this.damagedBases(          reshape(sites(:,nonmethylatedPositions(:,1)),        [],1), 1:2:<span class="keyword">end</span>,:), sitesChromosomesPositions-[0 1 0 0]),2) &gt;0   | <span class="keyword">...</span>
1806                 collapse(reshape(this.damagedBases(          reshape(sites(:,nonmethylatedPositions(:,2)),        [],1), 2:2:<span class="keyword">end</span>,:), sitesChromosomesPositions-[0 1 0 0]),2) &gt;0   | <span class="keyword">...</span>
1807                 this.damagedBases(                  sites(:,methylatedPositions(1)),                   2:2:<span class="keyword">end</span>,:) ~=0                                            | <span class="keyword">...</span>
1808                 this.damagedBases(                  sites(:,methylatedPositions(2)),                   1:2:<span class="keyword">end</span>,:) ~=0                                            | <span class="keyword">...</span>
1809                 collapse(reshape(this.strandBreaks(          reshape(sites(:,nonRestrictionPositions(1:end-1,1)),[],1), 1:2:<span class="keyword">end</span>,:), sitesChromosomesPositions-[0 2 0 0]),2) &gt;0    | <span class="keyword">...</span>
1810                 collapse(reshape(this.strandBreaks(          reshape(sites(:,nonRestrictionPositions(2:<span class="keyword">end</span>  ,2)),[],1), 2:2:<span class="keyword">end</span>,:), sitesChromosomesPositions-[0 2 0 0]),2) &gt;0    | <span class="keyword">...</span>
1811                 this.strandBreaks(                  sites(:,restrictionPositions(1)),                  2:2:<span class="keyword">end</span>,:) ~=0                                            | <span class="keyword">...</span>
1812                 this.strandBreaks(                  sites(:,restrictionPositions(2)),                  1:2:<span class="keyword">end</span>,:) ~=0                                            | <span class="keyword">...</span>
1813                 collapse(reshape(this.intrastrandCrossLinks( reshape(sites,                                      [],1), 1:2:<span class="keyword">end</span>,:), sitesChromosomesPositions),2)           &gt;0    | <span class="keyword">...</span>
1814                 collapse(reshape(this.intrastrandCrossLinks( reshape(sites,                                      [],1), 2:2:<span class="keyword">end</span>,:), sitesChromosomesPositions),2)           &gt;0    | <span class="keyword">...</span>
1815                 collapse(reshape(this.damagedSugarPhosphates(reshape(sites,                                      [],1), 1:2:<span class="keyword">end</span>,:), sitesChromosomesPositions),2)           &gt;0    | <span class="keyword">...</span>
1816                 collapse(reshape(this.damagedSugarPhosphates(reshape(sites,                                      [],1), 2:2:<span class="keyword">end</span>,:), sitesChromosomesPositions),2)           &gt;0    | <span class="keyword">...</span>
1817                 collapse(reshape(this.abasicSites(           reshape(sites,                                      [],1), 1:2:<span class="keyword">end</span>,:), sitesChromosomesPositions),2)           &gt;0    | <span class="keyword">...</span>
1818                 collapse(reshape(this.abasicSites(           reshape(sites,                                      [],1), 2:2:<span class="keyword">end</span>,:), sitesChromosomesPositions),2)           &gt;0    | <span class="keyword">...</span>
1819                 collapse(reshape(this.gapSites(              reshape(sites,                                      [],1), 1:2:<span class="keyword">end</span>,:), sitesChromosomesPositions),2)           &gt;0    | <span class="keyword">...</span>
1820                 collapse(reshape(this.gapSites(              reshape(sites,                                      [],1), 2:2:<span class="keyword">end</span>,:), sitesChromosomesPositions),2)           &gt;0    | <span class="keyword">...</span>
1821                 collapse(reshape(this.hollidayJunctions(     reshape(sites(:,1:end-1),                           [],1), 1:2:<span class="keyword">end</span>,:), sitesChromosomesPositions-[0 1 0 0]),2) &gt;0    | <span class="keyword">...</span>
1822                 collapse(reshape(this.hollidayJunctions(     reshape(sites(:,2:end),                             [],1), 2:2:<span class="keyword">end</span>,:), sitesChromosomesPositions-[0 1 0 0]),2) &gt;0;
1823             
1824             methylatedSites = <span class="keyword">...</span>
1825                 this.damagedBases(sites(:, methylatedPositions(1)), 1:2:<span class="keyword">end</span>,:) == this.metabolite.m6ADIndexs &amp; <span class="keyword">...</span>
1826                 this.damagedBases(sites(:, methylatedPositions(2)), 2:2:<span class="keyword">end</span>,:) == this.metabolite.m6ADIndexs;
1827             
1828             hemimethylatedSites = xor(<span class="keyword">...</span>
1829                 this.damagedBases(sites(:, methylatedPositions(1)), 1:2:<span class="keyword">end</span>,:) == this.metabolite.m6ADIndexs, <span class="keyword">...</span>
1830                 this.damagedBases(sites(:, methylatedPositions(2)), 2:2:<span class="keyword">end</span>,:) == this.metabolite.m6ADIndexs);
1831             
1832             unmethylatedSites = <span class="keyword">...</span>
1833                 this.damagedBases(sites(:, methylatedPositions(1)), 1:2:<span class="keyword">end</span>,:) ~= this.metabolite.m6ADIndexs &amp; <span class="keyword">...</span>
1834                 this.damagedBases(sites(:, methylatedPositions(2)), 2:2:<span class="keyword">end</span>,:) ~= this.metabolite.m6ADIndexs;
1835             
1836             cleavedSites = <span class="keyword">...</span>
1837                 this.strandBreaks(sites(:, restrictionPositions(1)), 1:2:<span class="keyword">end</span>,:) &amp; <span class="keyword">...</span>
1838                 this.strandBreaks(sites(:, restrictionPositions(2)), 2:2:<span class="keyword">end</span>,:);
1839             
1840             siteLength = size(sites, 2);
1841             ignoreDamageFilter =  1:siteLength;
1842             sitesStrands = [
1843                 sites(:, 1)   ones(size(sites, 1), 1)
1844                 sites(:, 1) 3*ones(size(sites, 1), 1)];
1845             inaccessibleRegions = damagedRegions | <span class="keyword">...</span>
1846                 (cleavedSites &amp; ~unmethylatedSites) | <span class="keyword">...</span>
1847                 ~reshape(this.isRegionAccessible(sitesStrands, siteLength, bindingMonomers, bindingComplexs, true, ignoreDamageFilter, false, true), [], this.nCompartments / 2);
1848                         
1849             methylatedSites     = ~inaccessibleRegions &amp; methylatedSites;
1850             hemimethylatedSites = ~inaccessibleRegions &amp; hemimethylatedSites;
1851             unmethylatedSites   = ~inaccessibleRegions &amp; unmethylatedSites &amp; ~cleavedSites;
1852             cleavedSites        = ~inaccessibleRegions &amp; cleavedSites;            
1853             
1854             unmethylatedSites   = SparseMat(unmethylatedSites);
1855             hemimethylatedSites = SparseMat(hemimethylatedSites);
1856             methylatedSites     = SparseMat(methylatedSites);
1857             cleavedSites        = SparseMat(cleavedSites);
1858             inaccessibleRegions = SparseMat(inaccessibleRegions);
1859             
1860             <span class="keyword">if</span> strcmp(warningState.state, <span class="string">'on'</span>); warning(<span class="string">'on'</span>, <span class="string">'SparseMat:inefficient'</span>); <span class="keyword">end</span>;
1861         <span class="keyword">end</span>
1862     <span class="keyword">end</span>
1863 
1864     <span class="comment">%methods which modify the state of this class, and possibly request</span>
1865     <span class="comment">%modifications to other parts of the simulation's state</span>
1866     methods
1867         <a name="_sub20" href="#_subfunctions" class="code">function sideEffects = setRegionUnwound(this, positions, lengths)</a>
1868             sideEffects = edu.stanford.covert.cell.sim.SimulationStateSideEffect.empty(0, 1);
1869 
1870             <span class="keyword">if</span> ~isequal(size(positions, 1), size(lengths, 1))
1871                 throw(MException(<span class="string">'Chromosome:invalidInput'</span>, <span class="string">'positions and lengths must have same number of rows'</span>));
1872             <span class="keyword">end</span>
1873             <span class="keyword">if</span> size(positions, 2) ~= 1
1874                 throw(MException(<span class="string">'Chromosome:invalidInput'</span>, <span class="string">'positions must have 1 columns'</span>));
1875             <span class="keyword">end</span>
1876             <span class="keyword">if</span> size(lengths, 2) ~= 1
1877                 throw(MException(<span class="string">'Chromosome:invalidInput'</span>, <span class="string">'lengths must have 1 column'</span>));
1878             <span class="keyword">end</span>
1879             <span class="keyword">if</span> ~any(lengths)
1880                 <span class="keyword">return</span>;
1881             <span class="keyword">end</span>
1882             L = this.sequenceLen;
1883             <span class="keyword">if</span> any(positions &gt; L)
1884                 throw(MException(<span class="string">'Chromosome:invalidInput'</span>, <span class="string">'positions cannot wrap ORI'</span>));
1885             <span class="keyword">end</span>
1886             
1887             positions = positions(logical(lengths));
1888             lengths = lengths(logical(lengths));
1889             n = size(positions, 1);
1890             <span class="keyword">if</span> ~all(this.isRegionDoubleStranded([positions ones(n, 1)], lengths, false))
1891                 throw(MException(<span class="string">'Chromosome:invalidInput'</span>, <span class="string">'regions must be double-stranded'</span>));
1892             <span class="keyword">end</span>
1893             <span class="keyword">if</span> ~all(positions == 1 | positions == L | <span class="keyword">...</span>
1894                     this.isRegionSingleStranded([max(1, positions - 1) ones(n, 1)], 1, false) | <span class="keyword">...</span>
1895                     this.isRegionSingleStranded([min(L, positions + 1) ones(n, 1)], 1, false))
1896                 throw(MException(<span class="string">'Chromosome:invalidInput'</span>,<span class="keyword">...</span>
1897                     <span class="string">'unwinding must begin at either end of dsDNA or continue where it left off'</span>));
1898             <span class="keyword">end</span>
1899             <span class="keyword">if</span> ~all(this.isRegionNotPolymerized([
1900                     positions 3*ones(n, 1);
1901                     positions 4*ones(n, 1)],<span class="keyword">...</span>
1902                     [lengths; lengths], false))
1903                 throw(MException(<span class="string">'Chromosome:invalidInput'</span>,<span class="string">'chromosome 2 region cannot be polymerized'</span>));
1904             <span class="keyword">end</span>
1905             
1906             oldStrd = this.strandIndexs_ch1(2);
1907             newStrd = this.strandIndexs_ch2(2);
1908             
1909             directions = sign(lengths);
1910             positions = positions + min(0, lengths + 1);
1911             lengths = abs(lengths);
1912             
1913             <span class="keyword">for</span> i = 1:n
1914                 len = lengths(i);
1915                 pos = positions(i,1);
1916                 dir = directions(i);
1917                 
1918                 <span class="comment">%if necessary, move region of initial negative strand of</span>
1919                 <span class="comment">%chromosome 1 to chromosome 2</span>
1920                 this.monomerBoundSites      = this.shiftStrandToNewChromosome(this.monomerBoundSites,      pos, len, oldStrd, newStrd);
1921                 this.complexBoundSites      = this.shiftStrandToNewChromosome(this.complexBoundSites,      pos, len, oldStrd, newStrd);
1922                 this.gapSites               = this.shiftStrandToNewChromosome(this.gapSites,               pos, len, oldStrd, newStrd);
1923                 this.abasicSites            = this.shiftStrandToNewChromosome(this.abasicSites,            pos, len, oldStrd, newStrd);
1924                 this.damagedSugarPhosphates = this.shiftStrandToNewChromosome(this.damagedSugarPhosphates, pos, len, oldStrd, newStrd);
1925                 this.damagedBases           = this.shiftStrandToNewChromosome(this.damagedBases,           pos, len, oldStrd, newStrd);
1926                 this.intrastrandCrossLinks  = this.shiftStrandToNewChromosome(this.intrastrandCrossLinks,  pos, len, oldStrd, newStrd);
1927                 this.strandBreaks           = this.shiftStrandToNewChromosome(this.strandBreaks,           pos, len, oldStrd, newStrd);
1928                 this.hollidayJunctions      = this.shiftStrandToNewChromosome(this.hollidayJunctions,      pos, len, oldStrd, newStrd);                
1929                 
1930                 <span class="comment">%update region of chromosomes that have been polymerized</span>
1931                 [regionStartPositions, regionLengths] = find(this.polymerizedRegions(:, oldStrd));
1932                 regionStartPositions = regionStartPositions(:, 1);
1933                 idx = find(regionStartPositions &lt;= pos &amp; regionStartPositions + regionLengths &gt; pos);                
1934                 this.polymerizedRegions(regionStartPositions(idx), oldStrd) = pos - regionStartPositions(idx);
1935                 <span class="keyword">if</span> dir == 1
1936                     <span class="keyword">if</span> pos ~= regionStartPositions(idx)
1937                         throw(MException(<span class="string">'Chromosome:error'</span>, <span class="string">'programmer error: unwinding bad region'</span>));
1938                     <span class="keyword">end</span>
1939                     this.linkingNumbers(pos + len, 1:2) = this.linkingNumbers(pos, oldStrd);
1940                     this.linkingNumbers(pos, 1:2) = 0;
1941                 <span class="keyword">end</span>
1942                 <span class="keyword">if</span> (dir == 1 &amp;&amp; len == regionLengths(idx) || <span class="keyword">...</span>
1943                     dir == -1 &amp;&amp; pos == regionStartPositions(idx)) &amp;&amp; <span class="keyword">...</span>
1944                     abs(this.linkingNumbers([pos oldStrd])) &gt; 1e-6
1945                     throw(MException(<span class="string">'Chromosome:invalidInput'</span>,<span class="keyword">...</span>
1946                         <span class="string">'cannot completely unwind region with nonzero linking number'</span>));
1947                 <span class="keyword">end</span>
1948                 <span class="keyword">if</span> regionLengths(idx) - (pos - regionStartPositions(idx)) - len ~= 0
1949                     this.polymerizedRegions(pos+len, oldStrd) = <span class="keyword">...</span>
1950                         regionLengths(idx) - (pos - regionStartPositions(idx)) - len;
1951                 <span class="keyword">end</span>
1952                 this.polymerizedRegions(pos, newStrd) = len;
1953                 
1954                 this.mergeOwnAdjacentRegions();
1955             <span class="keyword">end</span>
1956         <span class="keyword">end</span>
1957                 
1958         <a name="_sub21" href="#_subfunctions" class="code">function spmat = shiftStrandToNewChromosome(~, spmat, pos, len, oldStrd, newStrd)</a>
1959             import edu.stanford.covert.util.CircularSparseMat;
1960             
1961             [subs, vals] = find(spmat);
1962             tfs = <span class="keyword">...</span>
1963                 subs(:, 1) &gt;= pos &amp; <span class="keyword">...</span>
1964                 subs(:, 1) &lt;= pos + len - 1 &amp; <span class="keyword">...</span>
1965                 subs(:, 2) == oldStrd;
1966             subs(tfs, 2) = newStrd;
1967             spmat = CircularSparseMat(subs, vals, size(spmat), 1);
1968         <span class="keyword">end</span>
1969         
1970         <a name="_sub22" href="#_subfunctions" class="code">function sideEffects = setRegionPolymerized(this, positionsStrands, lengths)</a>
1971             import edu.stanford.covert.cell.sim.SimulationStateSideEffect;
1972 
1973             L = this.sequenceLen;            
1974             <span class="keyword">if</span> ~all(positionsStrands(:,2) == 1 | positionsStrands(:,2) == 2)
1975                 throw(MException(<span class="string">'Chromosome:invalidInput'</span>, <span class="string">'positionsStrands must be a valid template strand (eg. 1 or 2)'</span>));
1976             <span class="keyword">end</span>
1977             <span class="keyword">if</span> any(positionsStrands(:,1) + lengths -1 &gt; L)
1978                 throw(MException(<span class="string">'Chromosome:invalidInput'</span>, <span class="string">'positionsStrands cannot wrap ORI'</span>));
1979             <span class="keyword">end</span>
1980             <span class="keyword">if</span> ~isequal(size(positionsStrands,1), size(lengths,1))
1981                 throw(MException(<span class="string">'Chromosome:invalidInput'</span>, <span class="string">'positionsStrands and lengths must have same number of rows'</span>));
1982             <span class="keyword">end</span>
1983             <span class="keyword">if</span> size(positionsStrands, 2) ~= 2
1984                 throw(MException(<span class="string">'Chromosome:invalidInput'</span>, <span class="string">'positionsStrands must have 2 columns'</span>));
1985             <span class="keyword">end</span>
1986             <span class="keyword">if</span> size(lengths, 2) ~= 1
1987                 throw(MException(<span class="string">'Chromosome:invalidInput'</span>, <span class="string">'lengths must have 1 column'</span>));
1988             <span class="keyword">end</span>
1989             
1990             positionsStrands(:, 1) = positionsStrands(: ,1) + min(0, lengths + 1);
1991             lengths = abs(lengths);
1992             
1993             <span class="keyword">for</span> i = 1:size(positionsStrands, 1)
1994                 len = lengths(i);
1995                 pos = positionsStrands(i,1);
1996                 tmpStrd = this.strandIndexs_template(positionsStrands(i,2), :);
1997                 nonTmpStrd = this.strandIndexs_nonTemplate(positionsStrands(i,2), :);
1998                 
1999                 <span class="comment">%if no polymerization requested, do nothing</span>
2000                 <span class="keyword">if</span> len == 0
2001                     <span class="keyword">continue</span>;
2002                 <span class="keyword">end</span>
2003 
2004                 <span class="comment">%check that template exists</span>
2005                 <span class="keyword">if</span> ~this.isRegionPolymerized([pos tmpStrd], len, false)
2006                     throw(MException(<span class="string">'Chromosome:error'</span>,<span class="string">'cannot polymerize a region without a template'</span>));
2007                 <span class="keyword">end</span>
2008 
2009                 <span class="comment">%check that strand hasn't been polymerized</span>
2010                 <span class="keyword">if</span> ~this.isRegionNotPolymerized([pos nonTmpStrd], len, false)
2011                     throw(MException(<span class="string">'Chromosome:error'</span>,<span class="string">'cannot polymerize a region that''s already been polymerized'</span>));
2012                 <span class="keyword">end</span>
2013 
2014                 <span class="comment">%set region polymerized</span>
2015                 this.polymerizedRegions([pos nonTmpStrd]) = len;
2016                 this.linkingNumbers([pos tmpStrd; pos nonTmpStrd]) = len / this.relaxedBasesPerTurn;
2017                 this.mergeOwnAdjacentRegions();
2018             <span class="keyword">end</span>
2019 
2020             <span class="comment">%side effects</span>
2021             sideEffects = SimulationStateSideEffect.empty(0, 1);
2022         <span class="keyword">end</span>
2023 
2024         <span class="comment">%lengths must be non-negative integers</span>
2025         <a name="_sub23" href="#_subfunctions" class="code">function [releasedMonomers, releasedComplexs, sideEffects, tfs, idxs, positionsStrands, lengths] = </a><span class="keyword">...</span>
2026                 setSiteProteinBound(this, positionsStrands, maxBindings, weights, binding_monomerIndexs, binding_complexIndexs, <span class="keyword">...</span>
2027                 mainEffects_monomerIndexs, mainEffects_complexIndexs, <span class="keyword">...</span>
2028                 isBindingStable, isPositionsStrandFootprintCentroid, lengths, isBindingProcessive, ignoreDamageFilter, checkRegionSupercoiled)
2029                 
2030             <span class="keyword">if</span> nargin &lt; 14
2031                 checkRegionSupercoiled = false;
2032             <span class="keyword">end</span>
2033             
2034             <span class="keyword">if</span> isBindingStable &amp;&amp; numel(binding_monomerIndexs) + numel(binding_complexIndexs) &gt; 1
2035                 throw(MException(<span class="string">'Chromosome:invalidInput'</span>, <span class="string">'Can only bind 1 protein at a time'</span>));
2036             <span class="keyword">end</span>
2037             <span class="keyword">if</span> isBindingStable &amp;&amp; ~isBindingProcessive &amp;&amp; ~all(lengths == 1)
2038                 throw(MException(<span class="string">'Chromosome:invalidInput'</span>,<span class="string">'If any(lengths~=1) then if binding is stable it must be processive'</span>));
2039             <span class="keyword">end</span>
2040             <span class="keyword">if</span> numel(lengths) == 1
2041                 lengths = lengths(ones(size(positionsStrands, 1), 1), 1);
2042             <span class="keyword">end</span>
2043             
2044             <span class="comment">%randomly select among accessible sites</span>
2045             [tfs, idxs, positionsStrands, lengths] = this.sampleAccessibleRegions(maxBindings, weights, positionsStrands, lengths, <span class="keyword">...</span>
2046                 binding_monomerIndexs, binding_complexIndexs, isPositionsStrandFootprintCentroid, ignoreDamageFilter, ~isBindingStable, isBindingProcessive, checkRegionSupercoiled);
2047             
2048             <span class="comment">%if positions are centroid, shift positions to start coordinate view</span>
2049             [footprint, footprint3Prime, footprint5Prime, footprintBindingStrandedness, footprintRegionStrandedness] = this.getDNAFootprint(binding_monomerIndexs, binding_complexIndexs);
2050             
2051             releasePositionsStrands = positionsStrands;
2052             releasePositionsStrands(:, 1) = releasePositionsStrands(:, 1) + min(0, lengths + 1);
2053             <span class="keyword">if</span> isPositionsStrandFootprintCentroid
2054                 releasePositionsStrands(mod(releasePositionsStrands(:,2),2)==1, 1) = releasePositionsStrands(mod(releasePositionsStrands(:,2),2)==1, 1) - footprint5Prime;
2055                 releasePositionsStrands(mod(releasePositionsStrands(:,2),2)==0, 1) = releasePositionsStrands(mod(releasePositionsStrands(:,2),2)==0, 1) - footprint3Prime;
2056             <span class="keyword">end</span>
2057             
2058             <span class="comment">%remove proteins currently bound to selected accessible sites</span>
2059             <span class="keyword">if</span> footprintRegionStrandedness == this.dnaStrandedness_xsDNA
2060                 [monomerPosStrands, monomers] = find(this.monomerBoundSites);
2061                 [complexPosStrands, complexs] = find(this.complexBoundSites);
2062                 [releasableMonomerIndexs, releasableComplexIndexs] = this.getReleasableProteins(binding_monomerIndexs, binding_complexIndexs);
2063                 
2064                 tmpIdxs = find(~ismembc(monomers, releasableMonomerIndexs));
2065                 monomerPosStrands = monomerPosStrands(tmpIdxs, :);
2066                 monomers = monomers(tmpIdxs, :);
2067                 
2068                 tmpIdxs = find(~ismembc(complexs, releasableComplexIndexs));
2069                 complexPosStrands = complexPosStrands(tmpIdxs, :);
2070                 complexs = complexs(tmpIdxs, :);
2071                 
2072                 [releasePositionsStrands, releaseLens] = this.excludeRegions([
2073                     releasePositionsStrands(:, 1)     ones(size(releasePositionsStrands, 1), 1)
2074                     releasePositionsStrands(:, 1) 2 * ones(size(releasePositionsStrands, 1), 1)
2075                     releasePositionsStrands(:, 1) 3 * ones(size(releasePositionsStrands, 1), 1)
2076                     releasePositionsStrands(:, 1) 4 * ones(size(releasePositionsStrands, 1), 1)], <span class="keyword">...</span>
2077                     repmat(footprint + abs(lengths) - 1, 4, 1), <span class="keyword">...</span>
2078                     [monomerPosStrands; complexPosStrands], [this.monomerDNAFootprints(monomers); this.complexDNAFootprints(complexs)]);
2079             <span class="keyword">else</span>
2080                 releaseLens = footprint + abs(lengths) - 1;
2081             <span class="keyword">end</span>
2082             [releasedMonomers, releasedComplexs, sideEffects] = <span class="keyword">...</span>
2083                 this.setRegionProteinUnbound(releasePositionsStrands, releaseLens, <span class="keyword">...</span>
2084                 mainEffects_monomerIndexs, mainEffects_complexIndexs, <span class="keyword">...</span><span class="comment">                </span>
2085                 footprintRegionStrandedness == this.dnaStrandedness_dsDNA, <span class="keyword">...</span>
2086                 footprintBindingStrandedness == this.dnaStrandedness_dsDNA, <span class="keyword">...</span>
2087                 false, false);
2088             
2089             <span class="comment">%if binding is stable, bind protein to selected accessible sites</span>
2090             <span class="keyword">if</span> isBindingStable
2091                 bindPositionsStrands = positionsStrands;
2092                 <span class="keyword">if</span> isBindingProcessive
2093                     bindPositionsStrands(:,1) = bindPositionsStrands(:,1) + lengths - sign(lengths);
2094                 <span class="keyword">end</span>
2095                 <span class="keyword">if</span> isPositionsStrandFootprintCentroid
2096                     bindPositionsStrands(mod(bindPositionsStrands(:,2),2)==1, 1) = bindPositionsStrands(mod(bindPositionsStrands(:,2),2)==1, 1) - footprint5Prime;
2097                     bindPositionsStrands(mod(bindPositionsStrands(:,2),2)==0, 1) = bindPositionsStrands(mod(bindPositionsStrands(:,2),2)==0, 1) - footprint3Prime;
2098                 <span class="keyword">end</span>
2099 
2100                 <span class="keyword">if</span> ~isempty(binding_monomerIndexs)
2101                     this.monomerBoundSites(bindPositionsStrands) = binding_monomerIndexs;
2102                     releasedMonomers(mainEffects_monomerIndexs == binding_monomerIndexs) = <span class="keyword">...</span>
2103                         releasedMonomers(mainEffects_monomerIndexs == binding_monomerIndexs) - <span class="keyword">...</span>
2104                         numel(idxs);
2105                 <span class="keyword">else</span>
2106                     this.complexBoundSites(bindPositionsStrands) = binding_complexIndexs;
2107                     releasedComplexs(mainEffects_complexIndexs == binding_complexIndexs) = <span class="keyword">...</span>
2108                         releasedComplexs(mainEffects_complexIndexs == binding_complexIndexs) - <span class="keyword">...</span>
2109                         numel(idxs);
2110                 <span class="keyword">end</span>
2111             <span class="keyword">end</span>
2112         <span class="keyword">end</span>
2113         
2114         <span class="comment">%change the identity of bound proteins</span>
2115         <a name="_sub24" href="#_subfunctions" class="code">function [releasedMonomers, releasedComplexs, sideEffects] = </a><span class="keyword">...</span>
2116                 modifyBoundProtein(this, positionsStrands, newMonomers, newComplexs, <span class="keyword">...</span>
2117                 mainEffects_monomerIndexs, mainEffects_complexIndexs)
2118                         
2119             import edu.stanford.covert.cell.sim.SimulationStateSideEffect;
2120             import edu.stanford.covert.cell.sim.SimulationStateSideEffectItem;
2121             import edu.stanford.covert.util.countUnique;
2122                     
2123             <span class="keyword">if</span> any(all([newMonomers newComplexs], 2))
2124                 throw(MException(<span class="string">'Only 1 protein can be bound at each site'</span>));
2125             <span class="keyword">end</span>
2126             
2127             <span class="comment">%get identities of currently bound proteins</span>
2128             oldMonomers = this.monomerBoundSites(positionsStrands);
2129             oldComplexs = this.complexBoundSites(positionsStrands);
2130             
2131             <span class="comment">%check that changing protein identify doesn't increase footprint</span>
2132             <span class="comment">%size (otherwise setSiteProteinBound should be used)</span>
2133             oldFootprints = zeros(size(positionsStrands, 1));
2134             oldFootprints(oldMonomers ~= 0) = this.monomerDNAFootprints(oldMonomers(oldMonomers~=0));
2135             oldFootprints(oldComplexs ~= 0) = this.complexDNAFootprints(oldComplexs(oldComplexs~=0));
2136             
2137             newFootprints = zeros(size(positionsStrands, 1));
2138             newFootprints(newMonomers ~= 0) = this.monomerDNAFootprints(newMonomers(newMonomers~=0));
2139             newFootprints(newComplexs ~= 0) = this.complexDNAFootprints(newComplexs(newComplexs~=0));
2140             
2141             <span class="keyword">if</span> any(newFootprints &gt; oldFootprints)
2142                 throw(MException(<span class="string">'New protein footprints cannot be larger that old ones'</span>));
2143             <span class="keyword">end</span>
2144             
2145             <span class="comment">%modify identities of bound proteins</span>
2146             this.monomerBoundSites(positionsStrands(newMonomers~=0, :)) = newMonomers(newMonomers~=0, :);
2147             this.complexBoundSites(positionsStrands(newComplexs~=0, :)) = newComplexs(newComplexs~=0, :);
2148             
2149             <span class="comment">%summarize bound/released monomers/complexs</span>
2150             releasedMonomers = zeros(size(mainEffects_monomerIndexs));
2151             releasedComplexs = zeros(size(mainEffects_complexIndexs));
2152             
2153             oldMonomers = oldMonomers(oldMonomers~=0);
2154             [tfs, idxs] = ismember(oldMonomers, mainEffects_monomerIndexs);
2155             <span class="keyword">if</span> ~all(tfs)
2156                 throw(MException(<span class="string">'Chromosome:invalidInput'</span>,<span class="string">'All binding/releasing proteins must be mainEffects'</span>));
2157             <span class="keyword">end</span>
2158             [idxs, counts] = countUnique(idxs);
2159             releasedMonomers(idxs) = releasedMonomers(idxs) + counts;
2160             
2161             newMonomers = newMonomers(newMonomers~=0);
2162             [tfs, idxs] = ismember(newMonomers, mainEffects_monomerIndexs);
2163             <span class="keyword">if</span> ~all(tfs)
2164                 throw(MException(<span class="string">'Chromosome:invalidInput'</span>,<span class="string">'All binding/releasing proteins must be mainEffects'</span>));
2165             <span class="keyword">end</span>
2166             [idxs, counts] = countUnique(idxs);
2167             releasedMonomers(idxs) = releasedMonomers(idxs) - counts;
2168             
2169             oldComplexs = oldComplexs(oldComplexs~=0);
2170             [tfs, idxs] = ismember(oldComplexs, mainEffects_complexIndexs);
2171             <span class="keyword">if</span> ~all(tfs)
2172                 throw(MException(<span class="string">'Chromosome:invalidInput'</span>,<span class="string">'All binding/releasing proteins must be mainEffects'</span>));
2173             <span class="keyword">end</span>
2174             [idxs, counts] = countUnique(idxs);
2175             releasedComplexs(idxs) = releasedComplexs(idxs) + counts;
2176             
2177             newComplexs = newComplexs(newComplexs~=0);
2178             [tfs, idxs] = ismember(newComplexs, mainEffects_complexIndexs);
2179             <span class="keyword">if</span> ~all(tfs)
2180                 throw(MException(<span class="string">'Chromosome:invalidInput'</span>,<span class="string">'All binding/releasing proteins must be mainEffects'</span>));
2181             <span class="keyword">end</span>
2182             [idxs, counts] = countUnique(idxs);
2183             releasedComplexs(idxs) = releasedComplexs(idxs) - counts;
2184                         
2185             sideEffects = SimulationStateSideEffect.empty(0, 1);
2186         <span class="keyword">end</span>
2187         
2188         <a name="_sub25" href="#_subfunctions" class="code">function [releasedMonomers, releasedComplexs, sideEffects] = setRegionProteinUnbound(this, </a><span class="keyword">...</span>
2189                 positionsStrands, lengths, mainEffects_monomerIndexs, mainEffects_complexIndexs, <span class="keyword">...</span>
2190                 regionBothStrands, bindingBothStrands, suspendExternalStateUpdating, proteinIsDegraded)
2191             import edu.stanford.covert.cell.sim.SimulationStateSideEffect;
2192             import edu.stanford.covert.cell.sim.SimulationStateSideEffectItem;
2193             import edu.stanford.covert.util.CircularSparseMat;
2194             import edu.stanford.covert.util.countUnique;
2195             
2196             startCoors = mod(positionsStrands(:, 1) + min(0, lengths+1) - 1, this.sequenceLen) + 1;
2197             endCoors = startCoors + abs(lengths) - 1;
2198             strndTimes = [positionsStrands(:, 2:end) ones(size(positionsStrands, 1), size(this.monomerBoundSites, 3) - size(positionsStrands,2))];
2199             <span class="keyword">if</span> bindingBothStrands
2200                 strndTimes(:, 1) = ceil(strndTimes(:, 1) / 2); 
2201             <span class="keyword">end</span>
2202             
2203             tmpIdxs = find(endCoors &gt; this.sequenceLen);
2204             startCoors = [startCoors; max(1, startCoors(tmpIdxs) - this.sequenceLen)];
2205             endCoors = [endCoors; endCoors(tmpIdxs) - this.sequenceLen];
2206             endCoors(tmpIdxs) = this.sequenceLen;
2207             strndTimes = [strndTimes; strndTimes(tmpIdxs, :)];
2208             
2209             tmpIdxs = find(startCoors &lt; 0);
2210             startCoors = [startCoors; startCoors(tmpIdxs) + this.sequenceLen];
2211             endCoors = [endCoors; min(this.sequenceLen, endCoors(tmpIdxs) + this.sequenceLen)];
2212             startCoors(tmpIdxs) = 1;
2213             strndTimes = [strndTimes; strndTimes(tmpIdxs, :)];
2214             
2215             <span class="comment">%bound monomers</span>
2216             [subs, vals] = find(this.monomerBoundSites);
2217             unbindingMonomers = false(size(vals));
2218             monomerStarts = subs(:, 1);
2219             monomerEnds   = monomerStarts + this.monomerDNAFootprints(vals, :) - 1;
2220             monomerStrndTimes = [subs(:, 2:end) ones(size(subs,1), size(strndTimes,2)-size(subs,2)+1)];
2221             idxs = (1:numel(vals))';
2222             <span class="keyword">if</span> bindingBothStrands
2223                 monomerStrndTimes(:, 1) = ceil(monomerStrndTimes(:, 1) / 2);
2224             <span class="keyword">elseif</span> regionBothStrands
2225                 tfs = this.monomerDNAFootprintBindingStrandedness(vals) == this.dnaStrandedness_dsDNA;
2226                 idxs = [idxs(~tfs); idxs(tfs); idxs(tfs)];
2227                 monomerStarts = [monomerStarts(~tfs); monomerStarts(tfs); monomerStarts(tfs)];
2228                 monomerEnds = [monomerEnds(~tfs); monomerEnds(tfs); monomerEnds(tfs)];
2229                 monomerStrndTimes = [
2230                     monomerStrndTimes(~tfs, :)
2231                     2*ceil(monomerStrndTimes(tfs, 1)/2)-1 monomerStrndTimes(tfs, 2:end)
2232                     2*ceil(monomerStrndTimes(tfs, 1)/2) monomerStrndTimes(tfs, 2:end)
2233                     ];
2234             <span class="keyword">end</span>
2235             
2236             tmpIdxs = find(monomerEnds &gt; this.sequenceLen);
2237             monomerStarts = [monomerStarts; ones(numel(tmpIdxs), 1)];
2238             monomerEnds   = [monomerEnds;   monomerEnds(tmpIdxs, :) - this.sequenceLen];
2239             monomerStrndTimes = [monomerStrndTimes; monomerStrndTimes(tmpIdxs, :)];
2240             idxs = [idxs; idxs(tmpIdxs, :)];
2241             
2242             <span class="keyword">for</span> i = 1:numel(startCoors)
2243                 monMask = <span class="keyword">...</span>
2244                     (monomerStarts &gt;= startCoors(i) &amp; monomerStarts &lt;= endCoors(i)) | <span class="keyword">...</span>
2245                     (monomerEnds &gt;= startCoors(i) &amp; monomerEnds &lt;= endCoors(i)) | <span class="keyword">...</span>
2246                     (monomerStarts &lt;= startCoors(i) &amp; monomerEnds &gt;= endCoors(i));
2247                 tmpIdxs = find(monMask);
2248                 <span class="keyword">if</span> isempty(tmpIdxs); <span class="keyword">continue</span>; <span class="keyword">end</span>;
2249                 
2250                 <span class="keyword">if</span> isvector(strndTimes)
2251                     tmpIdxs = tmpIdxs(monomerStrndTimes(monMask, 1) ==  strndTimes(i, 1));
2252                 <span class="keyword">elseif</span> isscalar(tmpIdxs)
2253                     tmpIdxs = tmpIdxs(all(monomerStrndTimes(monMask, :) == strndTimes(i, :)));
2254                 <span class="keyword">else</span>
2255                     tmpIdxs = tmpIdxs(ismember(monomerStrndTimes(monMask, :), strndTimes(i, :), <span class="string">'rows'</span>));
2256                 <span class="keyword">end</span>
2257                 <span class="keyword">if</span> isempty(tmpIdxs); <span class="keyword">continue</span>; <span class="keyword">end</span>;
2258                 
2259                 unbindingMonomers(idxs(tmpIdxs)) = true;
2260             <span class="keyword">end</span>            
2261             
2262             releasedMonomers = zeros(numel(mainEffects_monomerIndexs), 1);
2263             <span class="keyword">if</span> isempty(unbindingMonomers) || ~any(unbindingMonomers)
2264                 gblIdxs = [];
2265                 counts = [];                
2266             <span class="keyword">elseif</span> isscalar(unbindingMonomers)
2267                 gblIdxs = vals(unbindingMonomers);
2268                 counts = 1;
2269                 releasedMonomers(gblIdxs == mainEffects_monomerIndexs, 1) = 1;
2270             <span class="keyword">else</span>
2271                 [gblIdxs, counts] = countUnique(vals(unbindingMonomers, 1));
2272                 [tfs, lclIdxs] = ismember(gblIdxs, mainEffects_monomerIndexs);
2273                 
2274                 releasedMonomers(lclIdxs(tfs)) = counts(tfs);
2275                 
2276                 tfs = tfs | gblIdxs == 0;
2277                 gblIdxs = gblIdxs(~tfs);
2278                 counts = counts(~tfs);
2279             <span class="keyword">end</span>
2280 
2281             <span class="keyword">if</span> isempty(gblIdxs)
2282                 sideEffects_releasedMonomers = SimulationStateSideEffect.empty(0, 1);
2283             <span class="keyword">else</span>
2284                 sideEffects_releasedMonomers = SimulationStateSideEffect.empty(numel(gblIdxs), 0);
2285             <span class="keyword">end</span>
2286             <span class="keyword">for</span> i = 1:numel(gblIdxs)
2287                 sideEffects_releasedMonomers(i, 1) = SimulationStateSideEffect([<span class="keyword">...</span>
2288                     SimulationStateSideEffectItem(<span class="string">'ProteinMonomer'</span>, <span class="string">'counts'</span>, <span class="string">'matureIndexs'</span>, gblIdxs(i), this.compartment.cytosolIndexs,  counts(i)); <span class="keyword">...</span>
2289                     SimulationStateSideEffectItem(<span class="string">'ProteinMonomer'</span>, <span class="string">'counts'</span>, <span class="string">'boundIndexs'</span>,  gblIdxs(i), this.compartment.cytosolIndexs, -counts(i))]);
2290             <span class="keyword">end</span>
2291             
2292             unbindingMonomerSubs = subs(unbindingMonomers, :);
2293             unbindingMonomerVals = vals(unbindingMonomers, :);
2294             this.monomerBoundSites = CircularSparseMat(subs(~unbindingMonomers, :), vals(~unbindingMonomers, 1), [this.sequenceLen this.nCompartments], 1);
2295             
2296             <span class="comment">%bound complexes</span>
2297             [subs, vals] = find(this.complexBoundSites);
2298             unbindingComplexs = false(size(vals));
2299             complexStarts = subs(:, 1);
2300             complexEnds   = complexStarts + this.complexDNAFootprints(vals, :) - 1;
2301             complexStrndTimes = [subs(:, 2:end) ones(size(subs,1), size(strndTimes,2)-size(subs,2)+1)];
2302             idxs = (1:numel(vals))';
2303             <span class="keyword">if</span> bindingBothStrands
2304                 complexStrndTimes(:, 1) = ceil(complexStrndTimes(:, 1) / 2);
2305             <span class="keyword">elseif</span> regionBothStrands
2306                 tfs = this.complexDNAFootprintBindingStrandedness(vals) == this.dnaStrandedness_dsDNA;
2307                 idxs = [idxs(~tfs); idxs(tfs); idxs(tfs)];
2308                 complexStarts = [complexStarts(~tfs); complexStarts(tfs); complexStarts(tfs)];
2309                 complexEnds = [complexEnds(~tfs); complexEnds(tfs); complexEnds(tfs)];
2310                 complexStrndTimes = [
2311                     complexStrndTimes(~tfs, :)
2312                     2*ceil(complexStrndTimes(tfs, 1)/2)-1 complexStrndTimes(tfs, 2:end)
2313                     2*ceil(complexStrndTimes(tfs, 1)/2) complexStrndTimes(tfs, 2:end)
2314                     ];
2315             <span class="keyword">end</span>
2316             
2317             tmpIdxs = find(complexEnds &gt; this.sequenceLen);
2318             complexStarts = [complexStarts; ones(numel(tmpIdxs), 1)];
2319             complexEnds   = [complexEnds;   complexEnds(tmpIdxs, :) - this.sequenceLen];
2320             complexStrndTimes    = [complexStrndTimes; complexStrndTimes(tmpIdxs, :)];
2321             idxs = [idxs; idxs(tmpIdxs, :)];
2322             
2323             <span class="keyword">for</span> i = 1:numel(startCoors)
2324                 comMask = <span class="keyword">...</span>
2325                     (complexStarts &gt;= startCoors(i) &amp; complexStarts &lt;= endCoors(i)) | <span class="keyword">...</span>
2326                     (complexEnds &gt;= startCoors(i) &amp; complexEnds &lt;= endCoors(i)) | <span class="keyword">...</span>
2327                     (complexStarts &lt;= startCoors(i) &amp; complexEnds &gt;= endCoors(i));
2328                 tmpIdxs = find(comMask);
2329                 <span class="keyword">if</span> isempty(tmpIdxs); <span class="keyword">continue</span>; <span class="keyword">end</span>;
2330                 
2331                 <span class="keyword">if</span> isvector(strndTimes)
2332                     tmpIdxs = tmpIdxs(complexStrndTimes(comMask, 1) ==  strndTimes(i, 1));
2333                 <span class="keyword">elseif</span> isscalar(tmpIdxs)
2334                     tmpIdxs = tmpIdxs(all(complexStrndTimes(comMask, :) == strndTimes(i, :)));
2335                 <span class="keyword">else</span>
2336                     tmpIdxs = tmpIdxs(ismember(complexStrndTimes(comMask, :), strndTimes(i, :), <span class="string">'rows'</span>));
2337                 <span class="keyword">end</span>                
2338                 <span class="keyword">if</span> isempty(tmpIdxs); <span class="keyword">continue</span>; <span class="keyword">end</span>;
2339                 
2340                 unbindingComplexs(idxs(tmpIdxs)) = true;
2341             <span class="keyword">end</span>
2342             
2343             releasedComplexs = zeros(numel(mainEffects_complexIndexs), 1);
2344             <span class="keyword">if</span> isempty(unbindingComplexs) || ~any(unbindingComplexs)
2345                 gblIdxs = [];
2346                 counts = [];
2347             <span class="keyword">elseif</span> isscalar(unbindingComplexs)
2348                 gblIdxs = vals(unbindingComplexs);
2349                 counts = 1;
2350                 releasedComplexs(gblIdxs == mainEffects_complexIndexs, 1) = 1;
2351             <span class="keyword">else</span>
2352                 [gblIdxs, counts] = countUnique(vals(unbindingComplexs, 1));
2353                 [tfs, lclIdxs] = ismember(gblIdxs, mainEffects_complexIndexs);
2354                 
2355                 releasedComplexs(lclIdxs(tfs)) = counts(tfs);
2356                 
2357                 tfs = tfs | gblIdxs == 0;
2358                 gblIdxs = gblIdxs(~tfs);
2359                 counts = counts(~tfs);
2360             <span class="keyword">end</span>
2361             
2362             <span class="keyword">if</span> isempty(gblIdxs)
2363                 sideEffects_releasedComplexs = SimulationStateSideEffect.empty(0, 1);
2364             <span class="keyword">else</span>
2365                 sideEffects_releasedComplexs = SimulationStateSideEffect.empty(numel(gblIdxs), 0);
2366             <span class="keyword">end</span>
2367             <span class="keyword">for</span> i = 1:numel(gblIdxs)
2368                 sideEffects_releasedComplexs(i, 1) = SimulationStateSideEffect([<span class="keyword">...</span>
2369                     SimulationStateSideEffectItem(<span class="string">'ProteinComplex'</span>, <span class="string">'counts'</span>, <span class="string">'matureIndexs'</span>, gblIdxs(i), this.compartment.cytosolIndexs,  counts(i)); <span class="keyword">...</span>
2370                     SimulationStateSideEffectItem(<span class="string">'ProteinComplex'</span>, <span class="string">'counts'</span>, <span class="string">'boundIndexs'</span>,  gblIdxs(i), this.compartment.cytosolIndexs, -counts(i))]);
2371             <span class="keyword">end</span>
2372             
2373             unbindingComplexSubs = subs(unbindingComplexs, :);
2374             unbindingComplexVals = vals(unbindingComplexs, :);
2375             this.complexBoundSites = CircularSparseMat(subs(~unbindingComplexs, :), vals(~unbindingComplexs, 1), [this.sequenceLen this.nCompartments], 1);
2376             
2377             <span class="comment">%effects on other states</span>
2378             <span class="keyword">if</span> ~suspendExternalStateUpdating
2379                 this.updateExternalState(unbindingMonomerSubs, unbindingMonomerVals, unbindingComplexSubs, unbindingComplexVals, proteinIsDegraded);
2380             <span class="keyword">end</span>
2381             
2382             <span class="comment">%side effects</span>
2383             sideEffects = [
2384                 sideEffects_releasedMonomers;
2385                 sideEffects_releasedComplexs];
2386         <span class="keyword">end</span>
2387         
2388         <a name="_sub26" href="#_subfunctions" class="code">function [positionsStrands, sideEffects] = stochasticallySetProteinUnbound(this, monomerIndex, complexIndex, </a><span class="keyword">...</span>
2389                 rate, protectedPositionsStrands, protectedLengths, suspendExternalStateUpdating, proteinIsDegraded)
2390             import edu.stanford.covert.cell.sim.SimulationStateSideEffect;
2391             import edu.stanford.covert.util.CircularSparseMat;
2392             
2393             sideEffects = SimulationStateSideEffect.empty(0, 1);
2394             
2395             <span class="keyword">if</span> ~isempty(monomerIndex)
2396                 <span class="keyword">if</span> ~isempty(complexIndex)
2397                     throw(MException(<span class="string">'Chromosome:invalidInput'</span>, <span class="string">'Can only unbind one protein at a time'</span>));
2398                 <span class="keyword">end</span>
2399                 [positionsStrands, proteins] = find(this.monomerBoundSites);
2400                 unbinding = proteins == monomerIndex;
2401             <span class="keyword">elseif</span> ~isempty(complexIndex)
2402                 [positionsStrands, proteins] = find(this.complexBoundSites);
2403                 unbinding = proteins == complexIndex;
2404             <span class="keyword">else</span>
2405                 positionsStrands = zeros(0, 2);
2406                 <span class="keyword">return</span>;
2407             <span class="keyword">end</span>
2408             <span class="keyword">if</span> ~any(unbinding)
2409                 positionsStrands = zeros(0, 2);
2410                 <span class="keyword">return</span>;
2411             <span class="keyword">end</span>
2412             
2413             <span class="comment">%randomly select bound protein to release at specified rate</span>
2414             <span class="keyword">if</span> isfinite(rate)
2415                 unbinding(unbinding) = this.randStream.rand(sum(unbinding), 1) &lt; rate;
2416                 <span class="keyword">if</span> ~any(unbinding)
2417                     positionsStrands = zeros(0, 2);
2418                     <span class="keyword">return</span>;
2419                 <span class="keyword">end</span>
2420             <span class="keyword">end</span>
2421             
2422             <span class="comment">%exclude protected sites</span>
2423             <span class="keyword">if</span> ~isempty(protectedPositionsStrands)
2424                 footprint = this.getDNAFootprint(monomerIndex, complexIndex);
2425                 <span class="keyword">for</span> i = 1:size(protectedPositionsStrands, 1)
2426                     unbndPosStrnds = positionsStrands(unbinding, :);
2427                     
2428                     tfs = <span class="keyword">...</span>
2429                         (unbndPosStrnds(:, 1)                 &gt;= protectedPositionsStrands(i, 1) &amp; <span class="keyword">...</span>
2430                          unbndPosStrnds(:, 1)                 &lt;= protectedPositionsStrands(i, 1) + protectedLengths(i) - 1) | <span class="keyword">...</span>
2431                         (unbndPosStrnds(: ,1) + footprint - 1 &gt;= protectedPositionsStrands(i, 1) &amp; <span class="keyword">...</span>
2432                          unbndPosStrnds(:, 1) + footprint - 1 &lt;= protectedPositionsStrands(i, 1) + protectedLengths(i) - 1) | <span class="keyword">...</span>
2433                         (unbndPosStrnds(:, 1)                 &lt;= protectedPositionsStrands(i, 1) &amp; <span class="keyword">...</span>
2434                          unbndPosStrnds(:, 1) + footprint - 1 &gt;= protectedPositionsStrands(i, 1) + protectedLengths(i) - 1);
2435                     
2436                     tfs(tfs) = unbndPosStrnds(tfs, 2) == protectedPositionsStrands(i, 2);
2437                     
2438                     unbinding(unbinding) = ~tfs;
2439                     
2440                     <span class="keyword">if</span> all(tfs)
2441                         positionsStrands = zeros(0, 2);
2442                         <span class="keyword">return</span>;
2443                     <span class="keyword">end</span>
2444                 <span class="keyword">end</span>
2445             <span class="keyword">end</span>
2446             
2447             <span class="comment">%update bound proteins</span>
2448             <span class="keyword">if</span> ~isempty(monomerIndex)
2449                 unbindingMonomerSubs = positionsStrands(unbinding, :);
2450                 unbindingMonomerVals = proteins(unbinding, 1);
2451                 unbindingComplexSubs = zeros(0, 2);
2452                 unbindingComplexVals = zeros(0, 1);
2453                 this.monomerBoundSites = CircularSparseMat(positionsStrands(~unbinding, :), proteins(~unbinding, 1), [this.sequenceLen this.nCompartments], 1);
2454             <span class="keyword">else</span>
2455                 unbindingMonomerSubs = zeros(0, 2);
2456                 unbindingMonomerVals = zeros(0, 1);
2457                 unbindingComplexSubs = positionsStrands(unbinding, :);
2458                 unbindingComplexVals = proteins(unbinding, 1);
2459                 this.complexBoundSites = CircularSparseMat(positionsStrands(~unbinding, :), proteins(~unbinding, 1), [this.sequenceLen this.nCompartments], 1);
2460             <span class="keyword">end</span>
2461             positionsStrands = positionsStrands(unbinding, :);
2462             
2463             <span class="comment">%effects on other states</span>
2464             <span class="keyword">if</span> ~suspendExternalStateUpdating
2465                 this.updateExternalState(unbindingMonomerSubs, unbindingMonomerVals, unbindingComplexSubs, unbindingComplexVals, proteinIsDegraded);
2466             <span class="keyword">end</span>
2467         <span class="keyword">end</span>
2468         
2469         <a name="_sub27" href="#_subfunctions" class="code">function updateExternalState(this, ~, ~, unbindingComplexSubs, unbindingComplexVals, proteinIsDegraded)</a>
2470             posStrnds = unbindingComplexSubs(ismembc(unbindingComplexVals, this.complexIndexs_rnaPolymerase), :);
2471             <span class="keyword">if</span> ~isempty(posStrnds)
2472                 [~, footprint3Prime, footprint5Prime] = this.getDNAFootprint([], this.complexIndexs_rnaPolymerase);
2473                 posStrnds( isodd(posStrnds(:, 2)), 1) = posStrnds( isodd(posStrnds(:, 2)), 1) + footprint5Prime;
2474                 posStrnds(iseven(posStrnds(:, 2)), 1) = posStrnds(iseven(posStrnds(:, 2)), 1) + footprint3Prime;
2475                 this.rnaPolymerase.releasePolymerase(posStrnds, proteinIsDegraded);
2476             <span class="keyword">end</span>
2477         <span class="keyword">end</span>
2478         
2479         <a name="_sub28" href="#_subfunctions" class="code">function [positionsStrands, sideEffects] = setSiteDamaged(this, </a><span class="keyword">...</span>
2480                 damageType, damageSubType, probDamage, maxDamages, <span class="keyword">...</span>
2481                 vulnerableMotif, vulnerableMotifType)
2482             import edu.stanford.covert.cell.sim.SimulationStateSideEffect;
2483             
2484             <span class="comment">%side effects</span>
2485             sideEffects = SimulationStateSideEffect.empty(0, 1);
2486             positionsStrands = zeros(0, 2);
2487             
2488             <span class="comment">%return if probability of damage is 0</span>
2489             <span class="keyword">if</span> probDamage == 0 || maxDamages == 0
2490                 <span class="keyword">return</span>;
2491             <span class="keyword">end</span>
2492             
2493             <span class="comment">%sample vulnerable sites</span>
2494             <span class="keyword">if</span> ischar(vulnerableMotif)
2495                 positionsStrands = this.sampleAccessibleSites(probDamage, maxDamages, vulnerableMotif);
2496             <span class="keyword">else</span>
2497                 <span class="keyword">if</span> nnz(this.(vulnerableMotifType)) == 0
2498                     <span class="keyword">return</span>;
2499                 <span class="keyword">end</span>
2500                 positionsStrands = find( <span class="keyword">...</span>
2501                     vulnerableMotif == this.(vulnerableMotifType) &amp; <span class="keyword">...</span>
2502                     vulnerableMotif == this.damagedSites_nonRedundant);
2503                 <span class="keyword">if</span> isempty(positionsStrands)
2504                     <span class="keyword">return</span>;
2505                 <span class="keyword">end</span>
2506                 maxDamages = min(maxDamages, <span class="keyword">...</span>
2507                     this.randStream.stochasticRound(size(positionsStrands, 1) * probDamage));
2508                 <span class="keyword">if</span> maxDamages == 0
2509                     <span class="keyword">return</span>;
2510                 <span class="keyword">end</span>
2511                 positionsStrands = this.randStream.randomlySelectNRows(positionsStrands, maxDamages);
2512             <span class="keyword">end</span>
2513             <span class="keyword">if</span> isempty(positionsStrands)
2514                 <span class="keyword">return</span>;
2515             <span class="keyword">end</span>
2516             
2517             <span class="comment">%damage selected sites</span>
2518             this.(damageType)(positionsStrands) = damageSubType;
2519         <span class="keyword">end</span>
2520     <span class="keyword">end</span>
2521     
2522     <span class="comment">%private methods which modify this class' state, and possibly request</span>
2523     <span class="comment">%changes that of other parts of the simulation's state</span>
2524     methods
2525         <a name="_sub29" href="#_subfunctions" class="code">function mergeOwnAdjacentRegions(this)</a>
2526             import edu.stanford.covert.util.CircularSparseMat;
2527 
2528             <span class="keyword">if</span> nnz(this.polymerizedRegions) &lt;= 1
2529                 <span class="keyword">return</span>;
2530             <span class="keyword">end</span>
2531             
2532             <span class="comment">%% add linking numbers for adjacent double-stranded regions</span>
2533             
2534             <span class="comment">%convert from SparseMat to coordinates</span>
2535             [dsPosStrands, lengths] = find(this.doubleStrandedRegions);
2536             [lkPosStrands, oldLKNums] = find(this.linkingNumbers);
2537 
2538             <span class="comment">%combine linking numbers for adjacent double-stranded regions</span>
2539             lkNums = zeros(size(lengths));
2540             <span class="keyword">for</span> i = 1:size(lkPosStrands,1)
2541                 idx = find(<span class="keyword">...</span>
2542                     lkPosStrands(i, 1) &gt;= dsPosStrands(:, 1)           &amp; <span class="keyword">...</span>
2543                     lkPosStrands(i, 1) &lt;= dsPosStrands(:, 1) + lengths &amp; <span class="keyword">...</span>
2544                     lkPosStrands(i, 2) == dsPosStrands(:, 2));
2545                 lkNums(idx) = lkNums(idx) + oldLKNums(i);
2546             <span class="keyword">end</span>
2547             
2548             <span class="comment">%convert from coordinates to SparseMat</span>
2549             this.linkingNumbers = CircularSparseMat(<span class="keyword">...</span>
2550                 dsPosStrands, lkNums, size(this.linkingNumbers), 1);
2551 
2552             <span class="comment">%% merge adjacent regions</span>
2553             this.polymerizedRegions = this.mergeAdjacentRegions(this.polymerizedRegions);            
2554         <span class="keyword">end</span>
2555         
2556         <a name="_sub30" href="#_subfunctions" class="code">function polymerizedRegions = mergeAdjacentRegions(~, polymerizedRegions)</a>
2557             import edu.stanford.covert.util.CircularSparseMat;
2558 
2559             <span class="keyword">if</span> nnz(polymerizedRegions) &lt;= 1
2560                 <span class="keyword">return</span>;
2561             <span class="keyword">end</span>
2562 
2563             <span class="comment">%% merge adjacent regions</span>
2564             <span class="comment">%convert from SparseMat to coordinates</span>
2565             [positionsStrands, lengths] = find(polymerizedRegions);
2566             
2567             <span class="comment">%make sure that regions don't overlap</span>
2568             <span class="keyword">if</span> any(lengths &lt; 0) || <span class="keyword">...</span>
2569                any(diff(positionsStrands(:,1)) &lt; lengths(1:end-1) &amp; diff(positionsStrands(:,2)) == 0)
2570                 throw(MException(<span class="string">'Chromosome:error'</span>,<span class="string">'polymerizedRegions is corrupt'</span>))
2571             <span class="keyword">end</span>
2572             
2573             <span class="comment">%merge adjacent regions (except over OriC)</span>
2574             idxs = find(diff(positionsStrands(:,1)) == lengths(1:end-1) &amp; diff(positionsStrands(:,2)) == 0);
2575             <span class="keyword">for</span> i = numel(idxs):-1:1
2576                 j = idxs(i);
2577                 lengths(j, 1) = lengths(j, 1) + lengths(j+1, 1);
2578             <span class="keyword">end</span>
2579             positionsStrands(idxs+1, :) = [];
2580             lengths(idxs+1, :) = [];
2581 
2582             <span class="comment">%% convert from coordinates to SparseMat</span>
2583             polymerizedRegions = CircularSparseMat(positionsStrands, lengths, size(polymerizedRegions), 1);
2584         <span class="keyword">end</span>
2585 
2586         <a name="_sub31" href="#_subfunctions" class="code">function [rgnPosStrnds, rgnLens] = excludeRegions(this, incPosStrnds, incLens, excPosStrnds, excLens)</a>
2587             L = this.sequenceLen;
2588             
2589             <span class="comment">%options</span>
2590             <span class="keyword">if</span> isscalar(excLens)
2591                 excLens = excLens(ones(size(excPosStrnds,1), 1), 1);
2592             <span class="keyword">end</span>
2593             
2594             <span class="comment">%join included regions</span>
2595             [incPosStrnds, incLens] = this.joinSplitOverOriCRegions(incPosStrnds, incLens);
2596             
2597             <span class="comment">%exclude excluded regions</span>
2598             [excPosStrnds, excLens] = this.joinSplitRegions(excPosStrnds, excLens);            
2599             
2600             excPos = [
2601                 excPosStrnds(:, 1) - L;
2602                 excPosStrnds(:, 1);
2603                 excPosStrnds(:, 1) + L];
2604             excStrnds = [excPosStrnds(:, 2); excPosStrnds(:, 2); excPosStrnds(:, 2)];
2605             excLens = [excLens; excLens; excLens];
2606             
2607             rgnPos = zeros(0, 1);
2608             rgnEnds = zeros(0, 1);
2609             rgnStrnds = zeros(0, 1);
2610             <span class="keyword">for</span> j = 1:size(incPosStrnds, 1)
2611                 startCoor = incPosStrnds(j, 1);
2612                 endCoor = startCoor + incLens(j) - 1;
2613                 strnd = incPosStrnds(j, 2);
2614                 
2615                 excIdxs = find(<span class="keyword">...</span>
2616                     ((excPos &lt;= startCoor &amp; excPos + excLens-1 &gt;= startCoor) | <span class="keyword">...</span>
2617                     (excPos &lt;= endCoor &amp; excPos + excLens-1 &gt;= endCoor) | <span class="keyword">...</span>
2618                     (excPos &gt;= startCoor &amp; excPos + excLens-1 &lt;= endCoor)) &amp; <span class="keyword">...</span>
2619                     excStrnds == strnd);
2620                 
2621                 <span class="keyword">if</span> isempty(excIdxs)
2622                     addtlPos = startCoor;
2623                     addtlEnds = endCoor;
2624                 <span class="keyword">elseif</span> excPos(excIdxs(1)) &lt;= startCoor
2625                     <span class="keyword">if</span> excPos(excIdxs(end)) + excLens(end) - 1 &gt;= endCoor
2626                         addtlPos = excPos(excIdxs(1:end-1)) + excLens(excIdxs(1:end-1));
2627                         addtlEnds = excPos(excIdxs(2:end))-1;
2628                     <span class="keyword">else</span>
2629                         addtlPos = excPos(excIdxs) + excLens(excIdxs);
2630                         addtlEnds = [excPos(excIdxs(2:end))-1; endCoor];
2631                     <span class="keyword">end</span>
2632                 <span class="keyword">else</span>
2633                     <span class="keyword">if</span> excPos(excIdxs(end)) + excLens(end) - 1 &gt;= endCoor
2634                         addtlPos = [startCoor; excPos(excIdxs(1:end-1)) + excLens(excIdxs(1:end-1))];
2635                         addtlEnds = excPos(excIdxs)-1;
2636                     <span class="keyword">else</span>
2637                         addtlPos = [startCoor; excPos(excIdxs) + excLens(excIdxs)];
2638                         addtlEnds = [excPos(excIdxs)-1; endCoor];
2639                     <span class="keyword">end</span>
2640                 <span class="keyword">end</span>
2641                 
2642                 rgnPos = [
2643                     rgnPos;
2644                     addtlPos];
2645                 rgnEnds = [
2646                     rgnEnds;
2647                     addtlEnds];
2648                 rgnStrnds = [
2649                     rgnStrnds;
2650                     strnd(ones(size(addtlPos)), 1)];
2651             <span class="keyword">end</span>
2652             
2653             idx = find(rgnPos &gt; L);
2654             rgnPos(idx) = rgnPos(idx) - L;
2655             rgnEnds(idx) = rgnEnds(idx) - L;
2656             
2657             idx = find(rgnPos &gt; rgnEnds);
2658             rgnPos(idx,:) = [];
2659             rgnEnds(idx,:) = [];
2660             rgnStrnds(idx,:) = [];
2661             
2662             <span class="comment">%join split regions</span>
2663             [rgnPosStrnds, rgnLens] = this.joinSplitOverOriCRegions([rgnPos rgnStrnds], rgnEnds - rgnPos + 1);
2664             
2665             <span class="comment">%format output</span>
2666             rgnPosStrnds(:, 1) = mod(rgnPosStrnds(:, 1) - 1, L) + 1;
2667             [rgnPosStrnds, order] = edu.stanford.covert.util.SparseMat.sort_subs(rgnPosStrnds, [L this.nCompartments]);
2668             rgnLens = rgnLens(order, :);
2669         <span class="keyword">end</span>
2670 
2671         <span class="comment">%finds the intersection of two lists of regions</span>
2672         <a name="_sub32" href="#_subfunctions" class="code">function [posStrnds, lens] = intersectRegions(this, posStrndsA, lensA, posStrndsB, lensB)</a>
2673             [posStrndsA lensA] = this.splitOverOriC(posStrndsA, lensA);
2674             posStrndsA(:, 1) = mod(posStrndsA(:, 1) - 1, this.sequenceLen) + 1;
2675             [posStrndsA, idxs] = edu.stanford.covert.util.SparseMat.sort_subs(posStrndsA, [this.sequenceLen this.nCompartments]);
2676             lensA = lensA(idxs);
2677 
2678             [posStrndsB lensB] = this.splitOverOriC(posStrndsB, lensB);            
2679             posStrndsB(:, 1) = mod(posStrndsB(:, 1) - 1, this.sequenceLen) + 1;
2680             [posStrndsB, idxs] = edu.stanford.covert.util.SparseMat.sort_subs(posStrndsB, [this.sequenceLen this.nCompartments]);
2681             lensB = lensB(idxs);
2682 
2683             posStrnds = zeros(0, 2);
2684             lens = zeros(0, 1);
2685             <span class="keyword">for</span> strand = 1:this.nCompartments
2686                 rowsA = posStrndsA(:,2) == strand;
2687                 rowsB = posStrndsB(:,2) == strand;
2688                 posA = posStrndsA(rowsA, 1);
2689                 posB = posStrndsB(rowsB, 1);
2690                 lenA = lensA(rowsA, 1);
2691                 lenB = lensB(rowsB, 1);
2692                 iA = 1;
2693                 iB = 1;
2694                 <span class="keyword">while</span> iA &lt;= length(posA) &amp;&amp; iB &lt;= length(posB)
2695                     <span class="keyword">if</span> posA(iA) &lt;= posB(iB)
2696                         <span class="keyword">if</span> posA(iA) + lenA(iA) &gt; posB(iB)
2697                             posStrnds(end+1,:) = [posB(iB) strand];
2698                             <span class="keyword">if</span> posA(iA) + lenA(iA) &lt; posB(iB) + lenB(iB)
2699                                 lens(end+1,:) = posA(iA) + lenA(iA) - posB(iB);
2700                                 iA = iA + 1;
2701                             <span class="keyword">else</span>
2702                                 lens(end+1,:) = lenB(iB);
2703                                 iB = iB + 1;
2704                             <span class="keyword">end</span>
2705                         <span class="keyword">else</span>
2706                             iA = iA + 1;
2707                         <span class="keyword">end</span>
2708                     <span class="keyword">else</span>
2709                         <span class="keyword">if</span> posB(iB) + lenB(iB) &gt; posA(iA)
2710                             posStrnds(end+1,:) = [posA(iA) strand];
2711                             <span class="keyword">if</span> posB(iB) + lenB(iB) &lt; posA(iA) + lenA(iA)
2712                                 lens(end+1,:) = posB(iB) + lenB(iB) - posA(iA);
2713                                 iB = iB + 1;
2714                             <span class="keyword">else</span>
2715                                 lens(end+1,:) = lenA(iA);
2716                                 iA = iA + 1;
2717                             <span class="keyword">end</span>
2718                         <span class="keyword">else</span>
2719                             iB = iB + 1;
2720                         <span class="keyword">end</span>
2721                     <span class="keyword">end</span>
2722                 <span class="keyword">end</span>
2723             <span class="keyword">end</span>
2724 
2725             [posStrnds, lens] = this.joinSplitOverOriCRegions(posStrnds, lens);
2726         <span class="keyword">end</span>
2727 
2728         <span class="comment">%split regions into several splitLen sized pieces</span>
2729         <a name="_sub33" href="#_subfunctions" class="code">function [posStrnds, lens] = splitRegions(~, rgnPosStrnds, rgnLens, splitLen)</a>
2730             nPos = sum(floor(abs(rgnLens)/splitLen));
2731             posStrnds = zeros(nPos, 2);
2732             lens = repmat(splitLen, nPos, 1);
2733             
2734             j = 0;
2735             <span class="keyword">for</span> i = 1:size(rgnPosStrnds, 1)
2736                 nPos = floor(abs(rgnLens(i))/splitLen);
2737                 
2738                 posStrnds(j+(1:nPos), 1) = rgnPosStrnds(i, 1) + sign(rgnLens(i))*(0:nPos-1)*splitLen;
2739                 posStrnds(j+(1:nPos), 2) = rgnPosStrnds(i, 2);
2740                 
2741                 j = j + nPos;
2742             <span class="keyword">end</span>
2743         <span class="keyword">end</span>
2744 
2745         <a name="_sub34" href="#_subfunctions" class="code">function [posStrnds, lens] = splitOverOriC(this, posStrnds, lens)</a>
2746             idxs = find(posStrnds(:, 1) + lens - 1 &gt; this.sequenceLen);
2747             <span class="keyword">if</span> isempty(idxs)
2748                 <span class="keyword">return</span>;
2749             <span class="keyword">end</span>
2750             posStrnds = [posStrnds; ones(numel(idxs), 1) posStrnds(idxs, 2)];
2751             lens = [lens; posStrnds(idxs, 1) + reshape(lens(idxs), [], 1) - this.sequenceLen - 1];
2752             lens(idxs) = this.sequenceLen - posStrnds(idxs,1) + 1;
2753         <span class="keyword">end</span>
2754 
2755         <span class="comment">%join regions which have been split over the ORI</span>
2756         <a name="_sub35" href="#_subfunctions" class="code">function [posStrnds, lens] = joinSplitOverOriCRegions(this, posStrnds, lens)</a>
2757             pos = posStrnds(:, 1);
2758             strnds = posStrnds(:, 2);
2759             ends = pos + lens - 1;
2760             
2761             <span class="keyword">for</span> i = 1:max(strnds)
2762                 idx1 = find(pos == 1 &amp; strnds == i, 1, <span class="string">'first'</span>);
2763                 idx2 = find(ends == this.sequenceLen &amp; strnds == i, 1, <span class="string">'first'</span>);
2764                 
2765                 <span class="keyword">if</span> isempty(idx1) || isempty(idx2) || idx1 == idx2
2766                     <span class="keyword">continue</span>;
2767                 <span class="keyword">end</span>
2768                 
2769                 ends(idx2) = ends(idx2) + (ends(idx1) - pos(idx1) + 1);
2770                 pos(idx1, :) = [];
2771                 strnds(idx1, :) = [];
2772                 ends(idx1, :) = [];
2773             <span class="keyword">end</span>
2774             
2775             posStrnds = [pos strnds];
2776             lens = ends - pos + 1;
2777         <span class="keyword">end</span>
2778         
2779         <a name="_sub36" href="#_subfunctions" class="code">function [posStrnds, lens] = joinSplitRegions(this, posStrnds, lens)</a>
2780             <span class="comment">%sort</span>
2781             posStrnds(:, 1) = mod(posStrnds(:, 1) - 1, this.sequenceLen) + 1;
2782             [posStrnds, order] = edu.stanford.covert.util.SparseMat.sort_subs(posStrnds, [this.sequenceLen this.nCompartments]);
2783             lens = lens(order);
2784             
2785             <span class="comment">%join</span>
2786             starts = posStrnds(:, 1);
2787             ends = starts + lens - 1;
2788             strnds = posStrnds(:, 2);
2789             
2790             tfs = true(size(starts));
2791             <span class="keyword">for</span> i = 1:max(strnds)
2792                 idxs = find(strnds == i);
2793                 <span class="keyword">for</span> j = 1:numel(idxs)-1
2794                     <span class="keyword">if</span> ends(idxs(j))+1 &gt;= starts(idxs(j+1))
2795                         starts(idxs(j+1)) = starts(idxs(j));
2796                         ends(idxs(j+1)) = max(ends(idxs(j)), ends(idxs(j+1)));
2797                         tfs(idxs(j)) = false;
2798                     <span class="keyword">end</span>
2799                 <span class="keyword">end</span>
2800                 <span class="keyword">if</span> numel(idxs) &gt;= 2
2801                     idx = idxs(find(tfs(idxs), 1, <span class="string">'first'</span>));
2802                     <span class="keyword">if</span> ends(idxs(end))+1 &gt;= starts(idx)+this.sequenceLen
2803                         ends(idxs(end)) = this.sequenceLen;
2804                         starts(idx) = 1;
2805                     <span class="keyword">end</span>
2806                 <span class="keyword">end</span>
2807             <span class="keyword">end</span>
2808             
2809             <span class="comment">%format output</span>
2810             posStrnds = [starts(tfs) strnds(tfs)];
2811             lens = ends(tfs) - starts(tfs) + 1;
2812         <span class="keyword">end</span>
2813         
2814         <a name="_sub37" href="#_subfunctions" class="code">function [idxs, newIdxs] = excludeOverlappingRegions(this, </a><span class="keyword">...</span>
2815                 idxs, newIdxs, positionsStrands, lengths, <span class="keyword">...</span>
2816                 footprint, footprint3Prime, footprint5Prime, isPositionsStrandFootprintCentroid, <span class="keyword">...</span>
2817                 eitherStrand)
2818             
2819             tmpPositionsStrands = positionsStrands([idxs; newIdxs], :);
2820             tmpLengths = lengths([idxs; newIdxs], 1);
2821             
2822             startCoors = tmpPositionsStrands(:, 1) + min(0, tmpLengths + 1);
2823             <span class="keyword">if</span> isPositionsStrandFootprintCentroid
2824                 startCoors(mod(tmpPositionsStrands(:, 2), 2) == 1) = <span class="keyword">...</span>
2825                     startCoors(mod(tmpPositionsStrands(:, 2), 2) == 1) - footprint5Prime;
2826                 startCoors(mod(tmpPositionsStrands(:, 2), 2) == 0) = <span class="keyword">...</span>
2827                     startCoors(mod(tmpPositionsStrands(:, 2), 2) == 0) - footprint3Prime;
2828             <span class="keyword">end</span>
2829             endCoors = startCoors + (abs(tmpLengths) - 1) + (footprint - 1);
2830             <span class="keyword">if</span> eitherStrand
2831                 strnds = ceil(tmpPositionsStrands(:, 2) / 2);
2832             <span class="keyword">else</span>
2833                 strnds = tmpPositionsStrands(:, 2);
2834             <span class="keyword">end</span>
2835             tmpIdxs = [zeros(size(idxs)); (1:numel(newIdxs))'];
2836             
2837             tmp = find(startCoors &lt; 0);
2838             startCoors = [startCoors; startCoors(tmp, :) + this.sequenceLen];
2839             endCoors   = [endCoors; min(this.sequenceLen, endCoors(tmp, :) + this.sequenceLen)];
2840             strnds       = [strnds; strnds(tmp, :)];
2841             tmpIdxs    = [tmpIdxs; tmpIdxs(tmp, :)];
2842             
2843             tmp = find(endCoors &gt; this.sequenceLen);
2844             startCoors = [startCoors; max(1, startCoors(tmp, :) - this.sequenceLen)];
2845             endCoors   = [endCoors; endCoors(tmp, :) - this.sequenceLen];
2846             strnds       = [strnds; strnds(tmp, :)];
2847             tmpIdxs    = [tmpIdxs; tmpIdxs(tmp, :)];
2848             
2849             tmpTfs = true(size(newIdxs));
2850             <span class="keyword">for</span> i = numel(tmpIdxs):-1:2
2851                 <span class="keyword">if</span> tmpIdxs(i) &lt;= numel(idxs)
2852                     <span class="keyword">continue</span>; 
2853                 <span class="keyword">end</span>
2854                 tmpTfs(tmpIdxs(i)) = tmpTfs(tmpIdxs(i)) &amp;&amp; ~any((<span class="keyword">...</span>
2855                     startCoors(1:i-1) &lt;= startCoors(i) &amp; startCoors(i) &lt;= endCoors(1:i-1) | <span class="keyword">...</span>
2856                     startCoors(1:i-1) &lt;= endCoors(i)   &amp; endCoors(  i) &lt;= endCoors(1:i-1)) &amp; <span class="keyword">...</span>
2857                     strnds(i) == strnds(1:i-1));
2858             <span class="keyword">end</span>
2859             newIdxs = newIdxs(tmpTfs);
2860         <span class="keyword">end</span>
2861     <span class="keyword">end</span>
2862     
2863     <span class="comment">%setters</span>
2864     methods        
2865         <span class="comment">%integers [positions x strands] indicating the start positions of</span>
2866         <span class="comment">%polymerized regions of strands and their lengths</span>
2867         <a name="_sub38" href="#_subfunctions" class="code">function set.polymerizedRegions(this, value)</a>
2868             <span class="keyword">if</span> isequal(this.polymerizedRegions, value)
2869                 <span class="keyword">return</span>;
2870             <span class="keyword">end</span>
2871             this.polymerizedRegions = value;
2872             this.validated = this.validated  + 1;
2873             this.validated_polymerizedRegions = this.validated; <span class="comment">%#ok&lt;*MCSUP&gt;</span>
2874         <span class="keyword">end</span>
2875         
2876         <span class="comment">%integers [positions x strands] indicating the current linking number of</span>
2877         <span class="comment">%each double-stranded region</span>
2878         <a name="_sub39" href="#_subfunctions" class="code">function set.linkingNumbers(this, value)</a>
2879             <span class="comment">%NOTE: performance likely better here without checking if new value</span>
2880             <span class="comment">%is different than old</span>
2881             this.linkingNumbers = value;
2882             this.validated = this.validated  + 1;
2883             this.validated_linkingNumbers = this.validated;
2884         <span class="keyword">end</span>
2885         
2886         <span class="comment">%indices [positions x strands] indicating start positions of protein</span>
2887         <span class="comment">%monomers bound to DNA bases</span>
2888         <a name="_sub40" href="#_subfunctions" class="code">function set.monomerBoundSites(this, value)</a>
2889             <span class="comment">%NOTE: performance likely better here without checking if new value</span>
2890             <span class="comment">%is different than old</span>
2891             this.monomerBoundSites = value;
2892             this.validated = this.validated  + 1;
2893             this.validated_proteinBoundSites = this.validated;
2894         <span class="keyword">end</span>
2895         
2896         <span class="comment">%indices [positions x strands] indicating start positions of</span>
2897         <span class="comment">%macromolecular complexes bound to DNA bases</span>
2898         <a name="_sub41" href="#_subfunctions" class="code">function set.complexBoundSites(this, value)</a>
2899             <span class="comment">%NOTE: performance likely better here without checking if new value</span>
2900             <span class="comment">%is different than old</span>
2901             this.complexBoundSites = value;
2902             this.validated = this.validated  + 1;
2903             this.validated_proteinBoundSites = this.validated;
2904         <span class="keyword">end</span>
2905         
2906         <span class="comment">%boolean [positions x strands] indicating positions of gap sites</span>
2907         <a name="_sub42" href="#_subfunctions" class="code">function set.gapSites(this, value)</a>
2908             <span class="keyword">if</span> isequal(this.gapSites, value)
2909                 <span class="keyword">return</span>;
2910             <span class="keyword">end</span>
2911             this.gapSites = value;
2912             this.validated = this.validated  + 1;
2913             this.validated_damaged = this.validated;
2914             this.validated_gapSites = this.validated;
2915         <span class="keyword">end</span>
2916         
2917         <span class="comment">%boolean [positions x strands] indicating positions of abasic sites</span>
2918         <a name="_sub43" href="#_subfunctions" class="code">function set.abasicSites(this, value)</a>
2919             <span class="keyword">if</span> isequal(this.abasicSites, value)
2920                 <span class="keyword">return</span>;
2921             <span class="keyword">end</span>
2922             this.abasicSites = value;
2923             this.validated = this.validated  + 1;
2924             this.validated_damaged = this.validated;
2925             this.validated_abasicSites = this.validated;
2926         <span class="keyword">end</span>
2927         
2928         <span class="comment">%indices [positions x strands] indicating metabolite identity of damaged</span>
2929         <span class="comment">%sugar-phosphates</span>
2930         <a name="_sub44" href="#_subfunctions" class="code">function set.damagedSugarPhosphates(this, value)</a>
2931             <span class="keyword">if</span> isequal(this.damagedSugarPhosphates, value)
2932                 <span class="keyword">return</span>;
2933             <span class="keyword">end</span>
2934             this.damagedSugarPhosphates = value;
2935             this.validated = this.validated  + 1;
2936             this.validated_damaged = this.validated;
2937             this.validated_damagedSugarPhosphates = this.validated;
2938         <span class="keyword">end</span>
2939         
2940         <span class="comment">%indices [positions x strands] indicating metabolite identity of damaged</span>
2941         <span class="comment">%bases</span>
2942         <a name="_sub45" href="#_subfunctions" class="code">function set.damagedBases(this, value)</a>
2943             <span class="keyword">if</span> isequal(this.damagedBases, value)
2944                 <span class="keyword">return</span>;
2945             <span class="keyword">end</span>
2946             this.damagedBases = value;
2947             this.validated = this.validated  + 1;
2948             this.validated_damaged = this.validated;
2949             this.validated_damagedBases = this.validated;
2950         <span class="keyword">end</span>
2951         
2952         <span class="comment">%boolean [positions x strands] indicating metabolite identity of</span>
2953         <span class="comment">%intrastrand cross links in DNA</span>
2954         <a name="_sub46" href="#_subfunctions" class="code">function set.intrastrandCrossLinks(this, value)</a>
2955             <span class="keyword">if</span> isequal(this.intrastrandCrossLinks, value)
2956                 <span class="keyword">return</span>;
2957             <span class="keyword">end</span>
2958             this.intrastrandCrossLinks = value;
2959             this.validated = this.validated  + 1;
2960             this.validated_damaged = this.validated;
2961             this.validated_intrastrandCrossLinks = this.validated;
2962         <span class="keyword">end</span>
2963         
2964         <span class="comment">%boolean [positions x strands] indicating positions of strand breaks in</span>
2965         <span class="comment">%strands of DNA</span>
2966         <a name="_sub47" href="#_subfunctions" class="code">function set.strandBreaks(this, value)</a>
2967             <span class="keyword">if</span> isequal(this.strandBreaks, value)
2968                 <span class="keyword">return</span>;
2969             <span class="keyword">end</span>
2970             this.strandBreaks = value;
2971             this.validated = this.validated  + 1;
2972             this.validated_damaged = this.validated;
2973             this.validated_strandBreaks = this.validated;
2974         <span class="keyword">end</span>
2975         
2976         <span class="comment">%boolean [positions x strands] indicating positions of holliday</span>
2977         <span class="comment">%junctions</span>
2978         <a name="_sub48" href="#_subfunctions" class="code">function set.hollidayJunctions(this, value)</a>
2979             <span class="keyword">if</span> isequal(this.hollidayJunctions, value)
2980                 <span class="keyword">return</span>;
2981             <span class="keyword">end</span>
2982             this.hollidayJunctions = value;
2983             this.validated = this.validated  + 1;
2984             this.validated_damaged = this.validated;
2985             this.validated_hollidayJunctions = this.validated;
2986         <span class="keyword">end</span>
2987         
2988         <span class="comment">%boolean indicating whether or not the chromsomes are segregated</span>
2989         <a name="_sub49" href="#_subfunctions" class="code">function set.segregated(this, value)</a>
2990             <span class="keyword">if</span> isequal(this.segregated, value)
2991                 <span class="keyword">return</span>;
2992             <span class="keyword">end</span>
2993             this.segregated = value;
2994             this.validated = this.validated  + 1;
2995             this.validated_segregated = this.validated;
2996         <span class="keyword">end</span>
2997     <span class="keyword">end</span>
2998     
2999     <span class="comment">%getters for alternative views of state</span>
3000     methods
3001         <a name="_sub50" href="#_subfunctions" class="code">function invalidate(this)</a>
3002             this.validated = uint32(1);
3003             
3004             this.validated_polymerizedRegions     = this.validated;
3005             this.validated_linkingNumbers         = this.validated;
3006             this.validated_proteinBoundSites      = this.validated;
3007             this.validated_damaged                = this.validated;
3008             this.validated_abasicSites            = this.validated;
3009             this.validated_gapSites               = this.validated;
3010             this.validated_damagedSugarPhosphates = this.validated;
3011             this.validated_damagedBases           = this.validated;
3012             this.validated_strandBreaks           = this.validated;
3013             this.validated_intrastrandCrossLinks  = this.validated;
3014             this.validated_hollidayJunctions      = this.validated;
3015             this.validated_segregated             = this.validated;
3016             
3017             this.validated_unpolymerizedRegions          = uint32(0);
3018             this.validated_singleStrandedRegions         = uint32(0);
3019             this.validated_doubleStrandedRegions         = uint32(0);
3020             this.validated_geneCopyNumbers               = uint32(0);
3021             this.validated_ploidy                        = uint32(0);
3022             this.validated_polymerizedGenes              = uint32(0);
3023             this.validated_transcriptionUnitCopyNumbers  = uint32(0);
3024             this.validated_polymerizedTranscriptionUnits = uint32(0);
3025             this.validated_geneCopyNumbers_Accessible    = uint32(0);
3026             this.validated_transcriptionUnitCopyNumbers_Accessible = uint32(0);
3027             this.validated_accessibleGenes               = uint32(0);
3028             this.validated_accessibleTranscriptionUnits  = uint32(0);            
3029             this.validated_linkingNumbers_minFreeEnergy  = uint32(0);
3030             this.validated_supercoils                    = uint32(0);
3031             this.validated_superhelicalDensity           = uint32(0);
3032             this.validated_supercoiled                   = uint32(0);
3033             this.validated_damagedSites                  = uint32(0);
3034             this.validated_damagedSites_shifted_incm6AD  = uint32(0);
3035             this.validated_damagedSites_nonRedundant     = uint32(0);
3036             this.validated_damagedSites_excm6AD          = uint32(0);
3037             this.validated_gapSites3                     = uint32(0);
3038             this.validated_gapSites5                     = uint32(0);
3039             this.validated_abasicSites3                  = uint32(0);
3040             this.validated_abasicSites5                  = uint32(0);
3041             this.validated_damagedSugarPhosphates3       = uint32(0);
3042             this.validated_damagedSugarPhosphates5       = uint32(0);
3043             this.validated_damagedBases3                 = uint32(0);
3044             this.validated_damagedBases5                 = uint32(0);
3045             this.validated_strandBreaks3                 = uint32(0);
3046             this.validated_strandBreaks5                 = uint32(0);
3047             this.validated_intrastrandCrossLinks3        = uint32(0);
3048             this.validated_intrastrandCrossLinks5        = uint32(0);
3049             this.validated_hollidayJunctions3            = uint32(0);
3050             this.validated_hollidayJunctions5            = uint32(0);
3051             this.validated_singleStrandBreaks            = uint32(0);
3052             this.validated_doubleStrandBreaks            = uint32(0);
3053             this.validated_strandBreakClassification     = uint32(0);
3054             this.validated_munIRMSiteMethylationStatus   = uint32(0);
3055             this.validated_munIRMSiteRestrictionStatus   = uint32(0);
3056             this.validated_dryWeight                     = uint32(0);
3057         <span class="keyword">end</span>
3058         
3059         <span class="comment">%integers indicating the start positions of unpolymerized regions (ie.</span>
3060         <span class="comment">%not yet replicated) of strands and their lengths</span>
3061         <a name="_sub51" href="#_subfunctions" class="code">function value = get.unpolymerizedRegions(this)</a>
3062             <span class="keyword">if</span> this.validated_polymerizedRegions &gt; this.validated_unpolymerizedRegions
3063                 this.unpolymerizedRegions = this.calcUnpolymerizedRegions();
3064                 this.validated_unpolymerizedRegions = this.validated;
3065             <span class="keyword">end</span>
3066                 
3067             value = this.unpolymerizedRegions;
3068         <span class="keyword">end</span>
3069                 
3070         <a name="_sub52" href="#_subfunctions" class="code">function value = calcUnpolymerizedRegions(this)</a>
3071             import edu.stanford.covert.util.CircularSparseMat;
3072             
3073             [polPosStrndsTimes, polLens] = find(this.polymerizedRegions);
3074             polPos = polPosStrndsTimes(:, 1);
3075             polStrnd = polPosStrndsTimes(:, 2);
3076             polTimes = polPosStrndsTimes(:, 3:end);
3077             <span class="keyword">if</span> isempty(polTimes)
3078                 polTimes = ones(size(polPos));
3079             <span class="keyword">end</span>
3080             
3081             unpolPos = [];
3082             unpolStrnds = [];
3083             unpolTimes = [];
3084             unpolLens = [];
3085             
3086             <span class="keyword">for</span> i = 1:this.nCompartments
3087                 idxs = find(polStrnd == i);
3088                 
3089                 <span class="keyword">for</span> j = 1:size(this.polymerizedRegions, 3)
3090                     idxs2 = idxs(polTimes(idxs) == j);
3091                     <span class="keyword">if</span> isempty(idxs2)
3092                         unpolPos = [unpolPos; 1];
3093                         unpolLens = [unpolLens; this.sequenceLen];
3094                         unpolStrnds = [unpolStrnds; i];
3095                         unpolTimes = [unpolTimes; j];
3096                         <span class="keyword">continue</span>;
3097                     <span class="keyword">end</span>
3098                     
3099                     unpolPos = [
3100                         unpolPos;
3101                         1;
3102                         polPos(idxs2) + polLens(idxs2)]; <span class="comment">%#ok&lt;*AGROW&gt;</span>
3103                     unpolLens = [
3104                         unpolLens;
3105                         polPos(idxs2(1))-1;
3106                         polPos(idxs2(2:end)) - (polPos(idxs2(1:end-1)) + polLens(idxs2(1:end-1)));
3107                         this.sequenceLen - (polPos(idxs2(end)) + polLens(idxs2(end))) + 1;
3108                         ]; <span class="comment">%#ok&lt;*AGROW&gt;</span>
3109                     unpolStrnds = [
3110                         unpolStrnds;
3111                         i(ones(numel(idxs2) + 1, 1), 1)]; <span class="comment">%#ok&lt;*AGROW&gt;</span>
3112                     unpolTimes = [
3113                         unpolTimes;
3114                         j(ones(numel(idxs2)+1, 1), 1)]; <span class="comment">%#ok&lt;*AGROW&gt;</span>
3115                 <span class="keyword">end</span>
3116             <span class="keyword">end</span>
3117             
3118             idxs = find(unpolLens &gt; 0);            
3119             value = CircularSparseMat([unpolPos(idxs) unpolStrnds(idxs) unpolTimes(idxs)], unpolLens(idxs), size(this.polymerizedRegions), 1);            
3120         <span class="keyword">end</span>
3121                 
3122         <a name="_sub53" href="#_subfunctions" class="code">function value = get.singleStrandedRegions(this)</a>
3123             <span class="keyword">if</span> this.validated_polymerizedRegions &gt; this.validated_singleStrandedRegions
3124                 this.singleStrandedRegions = this.calcSingleStrandedRegions();
3125                 this.validated_singleStrandedRegions = this.validated;
3126             <span class="keyword">end</span>
3127                 
3128             value = this.singleStrandedRegions;
3129         <span class="keyword">end</span>
3130         
3131         <a name="_sub54" href="#_subfunctions" class="code">function value = calcSingleStrandedRegions(this)</a>
3132             import edu.stanford.covert.util.CircularSparseMat;
3133             
3134             [positionsStrandsTimes, lengths] = find(this.polymerizedRegions);
3135             strnd = positionsStrandsTimes(:, 2);
3136             oppStrnd = strnd;
3137             oppStrnd(mod(strnd, 2) == 0, 1) = strnd(mod(strnd, 2) == 0, 1) - 1;
3138             oppStrnd(mod(strnd, 2) == 1, 1) = strnd(mod(strnd, 2) == 1, 1) + 1;
3139             
3140             starts = mod([
3141                 positionsStrandsTimes(:,1);
3142                 positionsStrandsTimes(:,1) + lengths] <span class="keyword">...</span>
3143                 - 1, this.sequenceLen) + 1;
3144             strandsTimes = [
3145                 strnd positionsStrandsTimes(:, 3:end);
3146                 oppStrnd positionsStrandsTimes(:, 3:end)];
3147             oppStrandsTimes = [
3148                 oppStrnd positionsStrandsTimes(:, 3:end);
3149                 strnd positionsStrandsTimes(:, 3:end)];
3150             lengths = [
3151                 lengths;
3152                 repmat(max(lengths), size(lengths))];
3153             
3154             [~, ~, ~, extents1] = this.isRegionPolymerized([starts strandsTimes], lengths, true);
3155             [~, ~, ~, extents2] = this.isRegionNotPolymerized([starts oppStrandsTimes], lengths, true);
3156             extents = min(abs(extents1), abs(extents2));
3157             idxs = find(extents &gt; 0);
3158             
3159             <span class="keyword">if</span> size(strandsTimes, 2) == 1
3160                 tmp = edu.stanford.covert.util.SparseMat.unique_subs(<span class="keyword">...</span>
3161                     [starts(idxs, :) strandsTimes(idxs, :) extents(idxs)], <span class="keyword">...</span>
3162                     [this.sequenceLen this.nCompartments this.sequenceLen]);
3163             <span class="keyword">else</span>
3164                 tmp = edu.stanford.covert.util.SparseMat.unique_subs(<span class="keyword">...</span>
3165                     [starts(idxs, :) strandsTimes(idxs, :) extents(idxs)], <span class="keyword">...</span>
3166                     [this.sequenceLen this.nCompartments size(this.polymerizedRegions, 3) this.sequenceLen]);
3167             <span class="keyword">end</span>
3168             
3169             <span class="keyword">for</span> i = size(tmp, 1):-1:1
3170                 <span class="keyword">if</span> tmp(i, 1) == 1
3171                     idx = find(tmp(:, 1) + tmp(:, 3) - 1 &gt; this.sequenceLen &amp; tmp(:, 2) == tmp(i, 2));                    
3172                     <span class="keyword">if</span> ~isempty(idx)
3173                         tmp(idx, 3) = max(tmp(idx, 3), (this.sequenceLen - tmp(idx,1) + 1) + tmp(i, 3));
3174                         tmp(i, :) = [];
3175                     <span class="keyword">end</span>
3176                 <span class="keyword">end</span>
3177             <span class="keyword">end</span>
3178             
3179             posStrnds = tmp(:, 1:end-1);
3180             lens = tmp(:, end);
3181             [posStrnds, lens] = this.splitOverOriC(posStrnds, lens);
3182             value = this.mergeAdjacentRegions(CircularSparseMat(posStrnds, lens, size(this.polymerizedRegions), 1));
3183         <span class="keyword">end</span>
3184                 
3185         <a name="_sub55" href="#_subfunctions" class="code">function value = get.doubleStrandedRegions(this)</a>
3186             <span class="keyword">if</span> this.validated_polymerizedRegions &gt; this.validated_doubleStrandedRegions
3187                 this.doubleStrandedRegions = this.calcDoubleStrandedRegions();
3188                 this.validated_doubleStrandedRegions = this.validated;
3189             <span class="keyword">end</span>
3190                 
3191             value = this.doubleStrandedRegions;
3192         <span class="keyword">end</span>
3193         
3194         <a name="_sub56" href="#_subfunctions" class="code">function value = calcDoubleStrandedRegions(this)</a>
3195             import edu.stanford.covert.util.CircularSparseMat;
3196             
3197             [positionsStrandsTimes, lengths] = find(this.polymerizedRegions);
3198             
3199                         
3200             <span class="keyword">if</span> size(positionsStrandsTimes, 2) == 2
3201                 tmp = edu.stanford.covert.util.SparseMat.unique_subs([
3202                     positionsStrandsTimes(:, 1) ceil(positionsStrandsTimes(:, 2)/2) lengths;
3203                     ], [this.sequenceLen this.nCompartments this.sequenceLen]);
3204                 
3205                 [~, ~, ~, extents1] = this.isRegionPolymerized([tmp(:, 1) 2*tmp(:,2)-1], tmp(:, end), true);
3206                 [~, ~, ~, extents2] = this.isRegionPolymerized([tmp(:, 1) 2*tmp(:,2)  ], tmp(:, end), true);
3207                 extents = min(abs(extents1), abs(extents2));
3208                 idxs = find(extents &gt; 0);
3209                 
3210                 tmp = edu.stanford.covert.util.SparseMat.unique_subs([
3211                     tmp(idxs, 1) 2*tmp(idxs, 2)-1 extents(idxs)
3212                     tmp(idxs, 1) 2*tmp(idxs, 2)   extents(idxs)
3213                     ], [this.sequenceLen this.nCompartments this.sequenceLen]);
3214             <span class="keyword">else</span>
3215                 tmp = edu.stanford.covert.util.SparseMat.unique_subs([
3216                     positionsStrandsTimes(:, 1) ceil(positionsStrandsTimes(:, 2)/2) positionsStrandsTimes(:, 3:end) lengths;
3217                     ], [this.sequenceLen this.nCompartments size(this.polymerizedRegions, 3) this.sequenceLen]);
3218                 
3219                 [~, ~, ~, extents1] = this.isRegionPolymerized([tmp(:, 1) 2*tmp(:,2)-1 tmp(:,3:end-1)], tmp(:, end), true);
3220                 [~, ~, ~, extents2] = this.isRegionPolymerized([tmp(:, 1) 2*tmp(:,2)   tmp(:,3:end-1)], tmp(:, end), true);
3221                 extents = min(abs(extents1), abs(extents2));
3222                 idxs = find(extents &gt; 0);
3223                 
3224                 tmp = edu.stanford.covert.util.SparseMat.unique_subs([
3225                     tmp(idxs, 1) 2*tmp(idxs, 2)-1 tmp(idxs, 3:end-1) extents(idxs)
3226                     tmp(idxs, 1) 2*tmp(idxs, 2)   tmp(idxs, 3:end-1) extents(idxs)
3227                     ], [this.sequenceLen this.nCompartments size(this.polymerizedRegions, 3) this.sequenceLen]);
3228             <span class="keyword">end</span>
3229             
3230             <span class="keyword">for</span> i = size(tmp, 1):-1:1
3231                 <span class="keyword">if</span> tmp(i, 1) == 1
3232                     idx = find(tmp(:, 1) + tmp(:, 3) - 1 &gt; this.sequenceLen &amp; tmp(:, 2) == tmp(i, 2));
3233                     <span class="keyword">if</span> ~isempty(idx)
3234                         tmp(idx, 3) = max(tmp(idx, 3), (this.sequenceLen - tmp(idx,1) + 1) + tmp(i, 3));
3235                         tmp(i, :) = [];
3236                     <span class="keyword">end</span>
3237                 <span class="keyword">end</span>
3238             <span class="keyword">end</span>
3239             
3240             posStrnds = tmp(:, 1:end-1);
3241             lens = tmp(:, end);
3242             [posStrnds, lens] = this.splitOverOriC(posStrnds, lens);
3243             value = this.mergeAdjacentRegions(CircularSparseMat(posStrnds, lens, size(this.polymerizedRegions), 1));
3244         <span class="keyword">end</span>
3245         
3246         
3247         <a name="_sub57" href="#_subfunctions" class="code">function value = get.geneCopyNumbers(this)</a>
3248             <span class="keyword">if</span> this.validated_polymerizedRegions &gt; this.validated_geneCopyNumbers
3249                 this.geneCopyNumbers = this.calcGeneCopyNumbers();
3250                 this.validated_geneCopyNumbers = this.validated;
3251             <span class="keyword">end</span>
3252                 
3253             value = this.geneCopyNumbers;
3254         <span class="keyword">end</span>
3255         
3256         <span class="comment">%number of copies of each gene that have been polymerized (Nx1)</span>
3257         <a name="_sub58" href="#_subfunctions" class="code">function value = calcGeneCopyNumbers(this)</a>
3258             value = sum(this.polymerizedGenes, 2);
3259         <span class="keyword">end</span>
3260         
3261         <a name="_sub59" href="#_subfunctions" class="code">function value = get.ploidy(this)</a>
3262             <span class="keyword">if</span> this.validated_polymerizedRegions &gt; this.validated_ploidy
3263                 this.ploidy = this.calcPloidy();
3264                 this.validated_ploidy = this.validated;
3265             <span class="keyword">end</span>
3266             
3267             value = this.ploidy;
3268         <span class="keyword">end</span>
3269         
3270         <a name="_sub60" href="#_subfunctions" class="code">function value = calcPloidy(this)</a>
3271             value = collapse(this.polymerizedRegions)/(2*this.sequenceLen);
3272         <span class="keyword">end</span>
3273         
3274         <a name="_sub61" href="#_subfunctions" class="code">function value = get.polymerizedGenes(this)</a>
3275             <span class="keyword">if</span> this.validated_polymerizedRegions &gt; this.validated_polymerizedGenes
3276                 this.polymerizedGenes = this.calcPolymerizedGenes();
3277                 this.validated_polymerizedGenes = this.validated;
3278             <span class="keyword">end</span>
3279                 
3280             value = this.polymerizedGenes;
3281         <span class="keyword">end</span>
3282 
3283         <span class="comment">%whether each copy of each gene has been polymerized (Nx2)</span>
3284         <a name="_sub62" href="#_subfunctions" class="code">function value = calcPolymerizedGenes(this)</a>
3285             value = this.isRegionPolymerized(<span class="keyword">...</span>
3286                 [this.gene.startCoordinates this.gene.strands;
3287                  this.gene.startCoordinates this.gene.strands+2],<span class="keyword">...</span>
3288                 [this.gene.lengths; this.gene.lengths], false);
3289             value = reshape(value, [], 2);
3290         <span class="keyword">end</span>
3291         
3292         
3293         <a name="_sub63" href="#_subfunctions" class="code">function value = get.transcriptionUnitCopyNumbers(this)</a>
3294             <span class="keyword">if</span> this.validated_polymerizedRegions &gt; this.validated_transcriptionUnitCopyNumbers
3295                 this.transcriptionUnitCopyNumbers = this.getTranscriptionUnitCopyNumbers();
3296                 this.validated_transcriptionUnitCopyNumbers = this.validated;
3297             <span class="keyword">end</span>
3298                 
3299             value = this.transcriptionUnitCopyNumbers;
3300         <span class="keyword">end</span>
3301 
3302         <span class="comment">%number of copies of each transcription unit that have been polymerized (Nx1)</span>
3303         <a name="_sub64" href="#_subfunctions" class="code">function value = getTranscriptionUnitCopyNumbers(this)</a>
3304             value = sum(this.polymerizedTranscriptionUnits, 2);
3305         <span class="keyword">end</span>
3306 
3307         
3308         <a name="_sub65" href="#_subfunctions" class="code">function value = get.polymerizedTranscriptionUnits(this)</a>
3309             <span class="keyword">if</span> this.validated_polymerizedRegions &gt; this.validated_polymerizedTranscriptionUnits
3310                 this.polymerizedTranscriptionUnits = this.calcPolymerizedTranscriptionUnits();
3311                 this.validated_polymerizedTranscriptionUnits = this.validated;
3312             <span class="keyword">end</span>
3313                 
3314             value = this.polymerizedTranscriptionUnits;
3315         <span class="keyword">end</span>
3316         
3317         <span class="comment">%whether each copy of each transcription unit has been polymerized (Nx2)</span>
3318         <a name="_sub66" href="#_subfunctions" class="code">function value = calcPolymerizedTranscriptionUnits(this)</a>
3319             value = this.isRegionPolymerized(<span class="keyword">...</span>
3320                 [this.transcriptionUnitStartCoordinates this.transcriptionUnitStrands;
3321                  this.transcriptionUnitStartCoordinates this.transcriptionUnitStrands+2],<span class="keyword">...</span>
3322                 [this.transcriptionUnitLengths; this.transcriptionUnitLengths], false);
3323             value = reshape(value, [], 2);
3324         <span class="keyword">end</span>
3325         
3326         
3327         <a name="_sub67" href="#_subfunctions" class="code">function value = get.geneCopyNumbers_Accessible(this)</a>
3328             val = max([
3329                 this.validated_polymerizedRegions; 
3330                 this.validated_damaged;
3331                 this.validated_proteinBoundSites]);
3332             <span class="keyword">if</span> val &gt; this.validated_geneCopyNumbers_Accessible
3333                 this.geneCopyNumbers_Accessible = this.calcCopyNumbers_Accessible();
3334                 this.validated_geneCopyNumbers_Accessible = this.validated;
3335             <span class="keyword">end</span>
3336                 
3337             value = this.geneCopyNumbers_Accessible;
3338         <span class="keyword">end</span>
3339 
3340         <span class="comment">%number of copies of each gene that are accessible</span>
3341         <a name="_sub68" href="#_subfunctions" class="code">function value = calcCopyNumbers_Accessible(this)</a>
3342             value = sum(this.accessibleGenes, 2);
3343         <span class="keyword">end</span>
3344         
3345         
3346         <a name="_sub69" href="#_subfunctions" class="code">function value = get.transcriptionUnitCopyNumbers_Accessible(this)</a>
3347             val = max([
3348                 this.validated_polymerizedRegions; 
3349                 this.validated_damaged;
3350                 this.validated_proteinBoundSites]);
3351             <span class="keyword">if</span> val &gt; this.validated_transcriptionUnitCopyNumbers_Accessible
3352                 this.transcriptionUnitCopyNumbers_Accessible = this.calcTranscriptionUnitCopyNumbers_Accessible();
3353                 this.validated_transcriptionUnitCopyNumbers_Accessible = this.validated;
3354             <span class="keyword">end</span>
3355                 
3356             value = this.transcriptionUnitCopyNumbers_Accessible;
3357         <span class="keyword">end</span>
3358                 
3359         <span class="comment">%number of copies of each transcription unit that are accessible</span>
3360         <a name="_sub70" href="#_subfunctions" class="code">function value = calcTranscriptionUnitCopyNumbers_Accessible(this)</a>
3361             value = sum(this.accessibleTranscriptionUnits, 2);
3362         <span class="keyword">end</span>
3363         
3364         
3365         <a name="_sub71" href="#_subfunctions" class="code">function value = get.accessibleGenes(this)</a>
3366             val = max([
3367                 this.validated_polymerizedRegions; 
3368                 this.validated_damaged;
3369                 this.validated_proteinBoundSites]);
3370             <span class="keyword">if</span> val &gt; this.validated_accessibleGenes
3371                 this.accessibleGenes = this.calcAccessibleGenes();
3372                 this.validated_accessibleGenes = this.validated;
3373             <span class="keyword">end</span>
3374                 
3375             value = this.accessibleGenes;
3376         <span class="keyword">end</span>
3377         
3378         <span class="comment">%boolean indicator of undamaged, unoccupied genes</span>
3379         <span class="comment">%true  ==&gt; gene is accessible</span>
3380         <span class="comment">%false ==&gt; gene is inaccessible</span>
3381         <a name="_sub72" href="#_subfunctions" class="code">function value = calcAccessibleGenes(this)</a>
3382             value = reshape(this.isRegionAccessible([<span class="keyword">...</span>
3383                 this.gene.startCoordinates this.gene.strands
3384                 this.gene.startCoordinates this.gene.strands+2], <span class="keyword">...</span>
3385                 [this.gene.lengths; this.gene.lengths], [], [], true, [], false, true), [], this.nCompartments/2);
3386         <span class="keyword">end</span>
3387         
3388         
3389         <a name="_sub73" href="#_subfunctions" class="code">function value = get.accessibleTranscriptionUnits(this)</a>
3390             val = max([
3391                 this.validated_polymerizedRegions; 
3392                 this.validated_damaged;
3393                 this.validated_proteinBoundSites]);
3394             <span class="keyword">if</span> val &gt; this.validated_accessibleTranscriptionUnits
3395                 this.accessibleTranscriptionUnits = this.calcAccessibleTranscriptionUnits();
3396                 this.validated_accessibleTranscriptionUnits = this.validated;
3397             <span class="keyword">end</span>
3398                 
3399             value = this.accessibleTranscriptionUnits;
3400         <span class="keyword">end</span>
3401         
3402         <span class="comment">%boolean indicator of undamaged, unoccupied transcription units</span>
3403         <span class="comment">%true  ==&gt; transcription unit is accessible</span>
3404         <span class="comment">%false ==&gt; transcription unit is inaccessible</span>
3405         <a name="_sub74" href="#_subfunctions" class="code">function value = calcAccessibleTranscriptionUnits(this)</a>
3406             value = reshape(this.isRegionAccessible([<span class="keyword">...</span>
3407                 this.transcriptionUnitStartCoordinates this.transcriptionUnitStrands;
3408                 this.transcriptionUnitStartCoordinates this.transcriptionUnitStrands+2], <span class="keyword">...</span>
3409                 [this.transcriptionUnitLengths; this.transcriptionUnitLengths], [], [], true, [], false, true), <span class="keyword">...</span>
3410                 [], this.nCompartments/2);
3411         <span class="keyword">end</span>
3412         
3413         <a name="_sub75" href="#_subfunctions" class="code">function value = get.strandBreakClassification(this)</a>
3414             <span class="keyword">if</span> max(this.validated_polymerizedRegions, this.validated_damaged) &gt; this.validated_strandBreakClassification
3415                 this.strandBreakClassification = this.calcStrandBreakClassification();
3416                 this.validated_strandBreakClassification = this.validated;
3417             <span class="keyword">end</span>
3418                 
3419             value = this.strandBreakClassification;
3420         <span class="keyword">end</span>
3421         
3422         <span class="comment">%numbers of each class of strand break (SSB, SSB+, 2SSB, DSB, DSB+,</span>
3423         <span class="comment">%DSB++) in DNA</span>
3424         <a name="_sub76" href="#_subfunctions" class="code">function value = calcStrandBreakClassification(this)</a>
3425             import edu.stanford.covert.util.CircularSparseMat;
3426             import edu.stanford.covert.util.countUnique;
3427             
3428             <span class="comment">%parameters</span>
3429             segmentLength = this.strandBreakClassification_segmentLength;
3430             dsbSep = this.strandBreakClassification_doubleStrandBreakSeparation;
3431             genomeLength = this.sequenceLen;
3432             numStrands = this.nCompartments;
3433             numTime = size(this.strandBreaks, 3);
3434             numSegments = ceil(genomeLength / segmentLength);
3435             
3436             <span class="comment">%damaged Sites</span>
3437             [polymerizedPositionsStrands, polymerizedLengths] = find(this.polymerizedRegions);
3438             idxs = find(polymerizedPositionsStrands(:,1) &lt;= segmentLength * numSegments - genomeLength);
3439             polymerizedPositionsStrands = [polymerizedPositionsStrands; polymerizedPositionsStrands(idxs, 1) + this.sequenceLen polymerizedPositionsStrands(idxs, 2:end)];
3440             polymerizedLengths = [polymerizedLengths; polymerizedLengths(idxs, :)];
3441             idxs = find(polymerizedPositionsStrands(:,1) + polymerizedLengths - 1 &gt; segmentLength * numSegments);
3442             polymerizedLengths(idxs,:) = segmentLength * numSegments - polymerizedPositionsStrands(idxs, 1) + 1;
3443             [polymerizedPositionsStrands, polymerizedLengths] = find(this.mergeAdjacentRegions(<span class="keyword">...</span>
3444                 CircularSparseMat(polymerizedPositionsStrands, polymerizedLengths, [segmentLength * numSegments numStrands numTime], 1)));
3445             
3446             <span class="keyword">if</span> numTime == 1
3447                 polymerizedPositionsStrands = [polymerizedPositionsStrands ones(size(polymerizedPositionsStrands,1), 1)];
3448             <span class="keyword">end</span>
3449             
3450             polymerizedStrands = [];
3451             <span class="keyword">for</span> i = 1:size(polymerizedPositionsStrands, 1)
3452                 regions = ceil((polymerizedPositionsStrands(i,1)-1) / segmentLength)+1 : floor((polymerizedPositionsStrands(i,1) + polymerizedLengths(i,1) -1) / segmentLength);
3453                 polymerizedStrands = [polymerizedStrands;
3454                     regions' <span class="keyword">...</span>
3455                     repmat(ceil(polymerizedPositionsStrands(i,2)/2), numel(regions), 1) <span class="keyword">...</span>
3456                     repmat(polymerizedPositionsStrands(i,3), numel(regions), 1)];
3457             <span class="keyword">end</span>
3458             [polymerizedRegions, ~, idxs]= unique(polymerizedStrands, <span class="string">'rows'</span>); <span class="comment">%#ok&lt;PROP&gt;</span>
3459             [idxs, counts] = countUnique(idxs);
3460             polymerizeTimes = polymerizedRegions(idxs(counts == 2), 3:end); <span class="comment">%#ok&lt;PROP&gt;</span>
3461             
3462             numPolymerizedSegments = zeros(1, 1, numTime);
3463             [idxs, counts] = countUnique(polymerizeTimes);
3464             numPolymerizedSegments(idxs) = counts;
3465             
3466             <span class="comment">%initialize classification</span>
3467             dmgSites = [this.strandBreaks; this.strandBreaks(1:segmentLength * numSegments - genomeLength, :, :)];
3468             
3469             subs = find(permute(reshape(dmgSites, [], numSegments, numStrands, numTime), [3 1 2 4])); <span class="comment">%[strands X positions X segments X time]</span>
3470             <span class="keyword">if</span> numTime == 1; subs = [subs ones(size(subs,1), 1)]; <span class="keyword">end</span>
3471             segmentTimeInds = sub2ind([numSegments numTime], subs(:, 3), subs(:, 4));
3472             
3473             value = zeros(this.strandBreakClassification_index_DSB__, 1, numTime);
3474             
3475             <span class="comment">%classify segments</span>
3476             <span class="keyword">while</span> ~isempty(subs)
3477                 <span class="comment">%time</span>
3478                 time = subs(1, 4);
3479                 
3480                 <span class="comment">%find extent of segment</span>
3481                 endIdx = find(<span class="keyword">...</span>
3482                     segmentTimeInds(1) ~= segmentTimeInds | <span class="keyword">...</span>
3483                     ceil(subs(1,1)/2) ~= ceil(subs(:,1)/2), <span class="keyword">...</span>
3484                     1, <span class="string">'first'</span>) - 1;
3485                 <span class="keyword">if</span> isempty(endIdx)
3486                     endIdx = size(subs, 1);
3487                 <span class="keyword">end</span>
3488                 
3489                 <span class="keyword">if</span> ~this.isRegionDoubleStranded([(subs(:,3)-1)*segmentLength+1 subs(:,1) subs(:,4)], segmentLength, false);
3490                     <span class="keyword">continue</span>;
3491                 <span class="keyword">end</span>
3492                 
3493                 <span class="comment">%classify damaged segment</span>
3494                 <span class="keyword">if</span> endIdx == 1
3495                     classification = this.strandBreakClassification_index_SSB;
3496                 <span class="keyword">else</span>
3497                     strands   = subs(1:endIdx, 1);
3498                     positions = subs(1:endIdx, 2);
3499                     <span class="keyword">if</span> ~isempty(strands) &amp;&amp; all(strands == strands(1))
3500                         classification = this.strandBreakClassification_index_SSB_;
3501                     <span class="keyword">else</span>
3502                         dsbIdx = find(diff(positions) &lt; dsbSep &amp; diff(strands));
3503                         <span class="keyword">if</span> isempty(dsbIdx)
3504                             classification = this.strandBreakClassification_index_2SSB;
3505                         <span class="keyword">else</span>
3506                             <span class="keyword">if</span> numel(dsbIdx)&gt;1 &amp;&amp; diff(positions(dsbIdx([1 end]))) &gt;= dsbSep
3507                                 classification = this.strandBreakClassification_index_DSB__;
3508                             <span class="keyword">elseif</span> numel(dsbIdx)&gt;1 || <span class="keyword">...</span>
3509                                     (dsbIdx&gt;1 &amp;&amp; diff(positions([dsbIdx - 1 dsbIdx])) &lt; dsbSep) || <span class="keyword">...</span>
3510                                     (dsbIdx&lt;numel(positions) - 1 &amp;&amp; diff(positions([dsbIdx + 1 dsbIdx + 2])) &lt; dsbSep)
3511                                 classification = this.strandBreakClassification_index_DSB_;
3512                             <span class="keyword">else</span>
3513                                 classification = this.strandBreakClassification_index_DSB;
3514                             <span class="keyword">end</span>
3515                         <span class="keyword">end</span>
3516                     <span class="keyword">end</span>
3517                 <span class="keyword">end</span>
3518                 
3519                 <span class="comment">%update counts of classified segments</span>
3520                 value(classification, 1, time) = value(classification, 1, time) + 1;
3521                 
3522                 <span class="comment">%shrink subs</span>
3523                 subs(1:endIdx, :) = [];
3524                 segmentTimeInds(1:endIdx, :) = [];
3525             <span class="keyword">end</span>
3526             
3527             <span class="comment">%compute numbers of segments without damage</span>
3528             value(this.strandBreakClassification_index_NB, 1, :) =  numPolymerizedSegments - sum(value,1);
3529         <span class="keyword">end</span>
3530         
3531         <span class="comment">%</span>
3532         <a name="_sub77" href="#_subfunctions" class="code">function value = get.linkingNumbers_minFreeEnergy(this)</a>
3533             <span class="keyword">if</span> this.validated_polymerizedRegions &gt; this.validated_linkingNumbers_minFreeEnergy
3534                 this.linkingNumbers_minFreeEnergy = this.calcLinkingNumbers_minFreeEnergy();
3535                 this.validated_linkingNumbers_minFreeEnergy = this.validated;
3536             <span class="keyword">end</span>
3537             
3538             value = this.linkingNumbers_minFreeEnergy;
3539         <span class="keyword">end</span>
3540         
3541         <a name="_sub78" href="#_subfunctions" class="code">function value = calcLinkingNumbers_minFreeEnergy(this)</a>
3542             import edu.stanford.covert.util.CircularSparseMat;
3543             
3544             [posStrands, lens] = find(this.doubleStrandedRegions);
3545             
3546             value = CircularSparseMat(posStrands, lens / this.relaxedBasesPerTurn, size(this.linkingNumbers), 1);
3547         <span class="keyword">end</span>
3548         
3549         <span class="comment">%</span>
3550         <a name="_sub79" href="#_subfunctions" class="code">function value = get.supercoils(this)</a>
3551             <span class="keyword">if</span> any([this.validated_polymerizedRegions; this.validated_linkingNumbers] &gt; this.validated_supercoils)
3552                 this.supercoils = this.calcSupercoils();
3553                 this.validated_supercoils = this.validated;
3554             <span class="keyword">end</span>
3555             
3556             value = this.supercoils;
3557         <span class="keyword">end</span>
3558         
3559         <a name="_sub80" href="#_subfunctions" class="code">function value = calcSupercoils(this)            </a>
3560             value = this.linkingNumbers - this.linkingNumbers_minFreeEnergy;
3561         <span class="keyword">end</span>
3562         
3563         <span class="comment">%</span>
3564         <a name="_sub81" href="#_subfunctions" class="code">function value = get.superhelicalDensity(this)</a>
3565             <span class="keyword">if</span> any([this.validated_polymerizedRegions; this.validated_linkingNumbers] &gt; this.validated_superhelicalDensity)
3566                 this.superhelicalDensity = this.calcSuperhelicalDensity();
3567                 this.validated_superhelicalDensity = this.validated;
3568             <span class="keyword">end</span>
3569             
3570             value = this.superhelicalDensity;
3571         <span class="keyword">end</span>
3572         
3573         <a name="_sub82" href="#_subfunctions" class="code">function value = calcSuperhelicalDensity(this)           </a>
3574             import edu.stanford.covert.util.CircularSparseMat;
3575             
3576             lkNums_min = this.linkingNumbers_minFreeEnergy;
3577             [posStrnds, deltas] = find(this.linkingNumbers - lkNums_min);
3578             value = CircularSparseMat(posStrnds, deltas ./ lkNums_min(posStrnds), size(this.linkingNumbers), 1);
3579         <span class="keyword">end</span>
3580         
3581         <span class="comment">%check if superhelical density within tolerance of equilbrium value</span>
3582         <a name="_sub83" href="#_subfunctions" class="code">function value = get.supercoiled(this)</a>
3583             <span class="keyword">if</span> any([this.validated_polymerizedRegions; this.validated_linkingNumbers] &gt; this.validated_supercoiled)
3584                 this.supercoiled = this.calcSupercoiled();
3585                 this.validated_supercoiled = this.validated;
3586             <span class="keyword">end</span>
3587             
3588             value = this.supercoiled;
3589         <span class="keyword">end</span>
3590         
3591         <a name="_sub84" href="#_subfunctions" class="code">function value = calcSupercoiled(this)</a>
3592             import edu.stanford.covert.util.CircularSparseMat;
3593             
3594             siz = [this.sequenceLen this.nCompartments];
3595             
3596             [posStrnds, lens] = find(this.doubleStrandedRegions);
3597             lks = this.linkingNumbers(posStrnds);
3598             
3599             lk0s = lens / this.relaxedBasesPerTurn;
3600             sigmas = (lks - lk0s) ./ lk0s;
3601             tfs = abs(sigmas - this.equilibriumSuperhelicalDensity) &lt; this.supercoiledSuperhelicalDensityTolerance;
3602             
3603             value = CircularSparseMat(posStrnds, tfs, siz, 1);
3604         <span class="keyword">end</span>
3605         
3606         <a name="_sub85" href="#_subfunctions" class="code">function value = get.damagedSites(this)</a>
3607             <span class="keyword">if</span> this.validated_damaged &gt; this.validated_damagedSites
3608                 this.damagedSites = this.calcDamagedSites();
3609                 this.validated_damagedSites = this.validated;
3610             <span class="keyword">end</span>
3611             
3612             value = this.damagedSites;
3613         <span class="keyword">end</span>
3614         
3615         <a name="_sub86" href="#_subfunctions" class="code">function value = calcDamagedSites(this)</a>
3616             value = this.getDamagedSites(true, true, true, true, false, true, false);
3617         <span class="keyword">end</span>
3618         
3619         <a name="_sub87" href="#_subfunctions" class="code">function value = get.damagedSites_shifted_incm6AD(this)</a>
3620             <span class="keyword">if</span> this.validated_damaged &gt; this.validated_damagedSites_shifted_incm6AD
3621                 this.damagedSites_shifted_incm6AD = this.calcDamagedSites_shifted_incm6AD();
3622                 this.validated_damagedSites_shifted_incm6AD = this.validated;
3623             <span class="keyword">end</span>
3624             
3625             value = this.damagedSites_shifted_incm6AD;
3626         <span class="keyword">end</span>
3627         
3628         <a name="_sub88" href="#_subfunctions" class="code">function value = calcDamagedSites_shifted_incm6AD(this)</a>
3629             value = this.getDamagedSites(true, true, true, true, false, true, true);
3630         <span class="keyword">end</span>
3631         
3632         <a name="_sub89" href="#_subfunctions" class="code">function value = get.damagedSites_nonRedundant(this)</a>
3633             <span class="keyword">if</span> this.validated_damaged &gt; this.validated_damagedSites_nonRedundant
3634                 this.damagedSites_nonRedundant = this.calcDamagedSites_nonRedundant();
3635                 this.validated_damagedSites_nonRedundant = this.validated;
3636             <span class="keyword">end</span>
3637             
3638             value = this.damagedSites_nonRedundant;
3639         <span class="keyword">end</span>
3640         
3641         <a name="_sub90" href="#_subfunctions" class="code">function value = calcDamagedSites_nonRedundant(this)</a>
3642             value = this.getDamagedSites(true, true, false, false, false, false, true);
3643         <span class="keyword">end</span>
3644         
3645         <a name="_sub91" href="#_subfunctions" class="code">function value = get.damagedSites_excm6AD(this)</a>
3646             <span class="keyword">if</span> this.validated_damaged &gt; this.validated_damagedSites_excm6AD
3647                 this.damagedSites_excm6AD = this.calcDamagedSites_excm6AD();
3648                 this.validated_damagedSites_excm6AD = this.validated;
3649             <span class="keyword">end</span>
3650             
3651             value = this.damagedSites_excm6AD;
3652         <span class="keyword">end</span>
3653         
3654         <a name="_sub92" href="#_subfunctions" class="code">function value = calcDamagedSites_excm6AD(this)</a>
3655             value = this.getDamagedSites(true, true, false, false, false, false, false);
3656         <span class="keyword">end</span>
3657         
3658         <span class="comment">%boolean (genome length x 2) indicating positions of gap sites 3'</span>
3659         <span class="comment">%to bases</span>
3660         <a name="_sub93" href="#_subfunctions" class="code">function value = get.gapSites3(this)</a>
3661             <span class="keyword">if</span> this.validated_gapSites &gt; this.validated_gapSites3
3662                 this.gapSites3 = this.calcGapSites3();
3663                 this.validated_gapSites3 = this.validated;
3664             <span class="keyword">end</span>
3665             
3666             value = this.gapSites3;
3667         <span class="keyword">end</span>
3668         
3669         <a name="_sub94" href="#_subfunctions" class="code">function value = calcGapSites3(this)</a>
3670             value = this.shiftCircularSparseMatBase5Prime(this.gapSites);
3671         <span class="keyword">end</span>
3672         
3673         <span class="comment">%boolean (genome length x 2) indicating positions of gap sites 5'</span>
3674         <span class="comment">%to bases</span>
3675         <a name="_sub95" href="#_subfunctions" class="code">function value = get.gapSites5(this)</a>
3676             <span class="keyword">if</span> this.validated_gapSites &gt; this.validated_gapSites5
3677                 this.gapSites5 = this.calcGapSites5();
3678                 this.validated_gapSites5 = this.validated;
3679             <span class="keyword">end</span>
3680             
3681             value = this.gapSites5;
3682         <span class="keyword">end</span>
3683         
3684         <a name="_sub96" href="#_subfunctions" class="code">function value = calcGapSites5(this)</a>
3685             value = this.shiftCircularSparseMatBase3Prime(this.gapSites);
3686         <span class="keyword">end</span>
3687         
3688         <span class="comment">%boolean (genome length x 2) indicating positions of abasic sites 3'</span>
3689         <span class="comment">%to bases</span>
3690         <a name="_sub97" href="#_subfunctions" class="code">function value = get.abasicSites3(this)</a>
3691             <span class="keyword">if</span> this.validated_abasicSites &gt; this.validated_abasicSites3
3692                 this.abasicSites3 = this.calcAbasicSites3();
3693                 this.validated_abasicSites3 = this.validated;
3694             <span class="keyword">end</span>
3695             
3696             value = this.abasicSites3;
3697         <span class="keyword">end</span>
3698         
3699         <a name="_sub98" href="#_subfunctions" class="code">function value = calcAbasicSites3(this)</a>
3700             value = this.shiftCircularSparseMatBase5Prime(this.abasicSites);
3701         <span class="keyword">end</span>
3702         
3703         <span class="comment">%boolean (genome length x 2) indicating positions of abasic sites 5'</span>
3704         <span class="comment">%to bases</span>
3705         <a name="_sub99" href="#_subfunctions" class="code">function value = get.abasicSites5(this)</a>
3706             <span class="keyword">if</span> this.validated_abasicSites &gt; this.validated_abasicSites5
3707                 this.abasicSites5 = this.calcAbasicSites5();
3708                 this.validated_abasicSites5 = this.validated;
3709             <span class="keyword">end</span>
3710             
3711             value = this.abasicSites5;
3712         <span class="keyword">end</span>
3713         
3714         <a name="_sub100" href="#_subfunctions" class="code">function value = calcAbasicSites5(this)</a>
3715             value = this.shiftCircularSparseMatBase3Prime(this.abasicSites);
3716         <span class="keyword">end</span>
3717         
3718         <span class="comment">%integer (genome length x 2) indicating indices of damaged sugar</span>
3719         <span class="comment">%phosphates 3' to bases</span>
3720         <a name="_sub101" href="#_subfunctions" class="code">function value = get.damagedSugarPhosphates3(this)</a>
3721             <span class="keyword">if</span> this.validated_damagedSugarPhosphates &gt; this.validated_damagedSugarPhosphates3
3722                 this.damagedSugarPhosphates3 = this.calcDamagedSugarPhosphates3();
3723                 this.validated_damagedSugarPhosphates3 = this.validated;
3724             <span class="keyword">end</span>
3725             
3726             value = this.damagedSugarPhosphates3;
3727         <span class="keyword">end</span>
3728         
3729         <a name="_sub102" href="#_subfunctions" class="code">function value = calcDamagedSugarPhosphates3(this)</a>
3730             value = this.shiftCircularSparseMatBase5Prime(this.damagedSugarPhosphates);
3731         <span class="keyword">end</span>
3732         
3733         <span class="comment">%integer (genome length x 2) indicating indices of damaged sugar</span>
3734         <span class="comment">%phosphates 5' to bases</span>
3735         <a name="_sub103" href="#_subfunctions" class="code">function value = get.damagedSugarPhosphates5(this)</a>
3736             <span class="keyword">if</span> this.validated_damagedSugarPhosphates &gt; this.validated_damagedSugarPhosphates5
3737                 this.damagedSugarPhosphates5 = this.calcDamagedSugarPhosphates5();
3738                 this.validated_damagedSugarPhosphates5 = this.validated;
3739             <span class="keyword">end</span>
3740             
3741             value = this.damagedSugarPhosphates5;
3742         <span class="keyword">end</span>
3743         
3744         <a name="_sub104" href="#_subfunctions" class="code">function value = calcDamagedSugarPhosphates5(this)</a>
3745             value = this.shiftCircularSparseMatBase3Prime(this.damagedSugarPhosphates);
3746         <span class="keyword">end</span>
3747         
3748         <span class="comment">%integer (genome length x 2) indicating indices of damaged bases 3' to bases</span>
3749         <a name="_sub105" href="#_subfunctions" class="code">function value = get.damagedBases3(this)</a>
3750             <span class="keyword">if</span> this.validated_damagedBases &gt; this.validated_damagedBases3
3751                 this.damagedBases3 = this.calcDamagedBases3();
3752                 this.validated_damagedBases3 = this.validated;
3753             <span class="keyword">end</span>
3754             
3755             value = this.damagedBases3;
3756         <span class="keyword">end</span>
3757         
3758         <a name="_sub106" href="#_subfunctions" class="code">function value = calcDamagedBases3(this)</a>
3759             value = this.shiftCircularSparseMatBase5Prime(this.damagedBases);
3760         <span class="keyword">end</span>
3761         
3762         <span class="comment">%integer (genome length x 2) indicating indices of damaged bases 5' to bases</span>
3763         <a name="_sub107" href="#_subfunctions" class="code">function value = get.damagedBases5(this)</a>
3764             <span class="keyword">if</span> this.validated_damagedBases &gt; this.validated_damagedBases5
3765                 this.damagedBases5 = this.calcDamagedBases5();
3766                 this.validated_damagedBases5 = this.validated;
3767             <span class="keyword">end</span>
3768             
3769             value = this.damagedBases5;
3770         <span class="keyword">end</span>
3771         
3772         <a name="_sub108" href="#_subfunctions" class="code">function value = calcDamagedBases5(this)</a>
3773             value = this.shiftCircularSparseMatBase3Prime(this.damagedBases);
3774         <span class="keyword">end</span>
3775         
3776         <span class="comment">%boolean (genome length x 2) indicating positions of intrastrand cross</span>
3777         <span class="comment">%links 3' to bases</span>
3778         <a name="_sub109" href="#_subfunctions" class="code">function value = get.intrastrandCrossLinks3(this)</a>
3779             <span class="keyword">if</span> this.validated_intrastrandCrossLinks &gt; this.validated_intrastrandCrossLinks3
3780                 this.intrastrandCrossLinks3 = this.calcIntrastrandCrossLinks3();
3781                 this.validated_intrastrandCrossLinks3 = this.validated;
3782             <span class="keyword">end</span>
3783             
3784             value = this.intrastrandCrossLinks3;
3785         <span class="keyword">end</span>
3786         
3787         <a name="_sub110" href="#_subfunctions" class="code">function value = calcIntrastrandCrossLinks3(this)</a>
3788             value = this.shiftCircularSparseMatBase5Prime(this.intrastrandCrossLinks);
3789         <span class="keyword">end</span>
3790         
3791         <span class="comment">%boolean (genome length x 2) indicating positions of intrastrand cross</span>
3792         <span class="comment">%links 5' to bases</span>
3793         <a name="_sub111" href="#_subfunctions" class="code">function value = get.intrastrandCrossLinks5(this)</a>
3794             <span class="keyword">if</span> this.validated_intrastrandCrossLinks &gt; this.validated_intrastrandCrossLinks5
3795                 this.intrastrandCrossLinks5 = this.calcIntrastrandCrossLinks5();
3796                 this.validated_intrastrandCrossLinks5 = this.validated;
3797             <span class="keyword">end</span>
3798             
3799             value = this.intrastrandCrossLinks5;
3800         <span class="keyword">end</span>
3801         
3802         <a name="_sub112" href="#_subfunctions" class="code">function value = calcIntrastrandCrossLinks5(this)</a>
3803             value = this.shiftCircularSparseMatBase3Prime(this.intrastrandCrossLinks);
3804         <span class="keyword">end</span>
3805         
3806         <span class="comment">%boolean (genome length x 2) indicating positions of strand breaks</span>
3807         <span class="comment">%3' to bases</span>
3808         <a name="_sub113" href="#_subfunctions" class="code">function value = get.strandBreaks3(this)</a>
3809             <span class="keyword">if</span> this.validated_strandBreaks &gt; this.validated_strandBreaks3
3810                 this.strandBreaks3 = this.calcStrandBreaks3();
3811                 this.validated_strandBreaks3 = this.validated;
3812             <span class="keyword">end</span>
3813             
3814             value = this.strandBreaks3;
3815         <span class="keyword">end</span>
3816         
3817         <a name="_sub114" href="#_subfunctions" class="code">function value = calcStrandBreaks3(this)</a>
3818             value = this.unshiftCircularSparseMatBond3Prime(this.strandBreaks);
3819         <span class="keyword">end</span>
3820         
3821         <span class="comment">%boolean (genome length x 2) indicating positions of strand breaks</span>
3822         <span class="comment">%5' to bases</span>
3823         <a name="_sub115" href="#_subfunctions" class="code">function value = get.strandBreaks5(this)</a>
3824             <span class="keyword">if</span> this.validated_strandBreaks &gt; this.validated_strandBreaks5
3825                 this.strandBreaks5 = this.calcStrandBreaks5();
3826                 this.validated_strandBreaks5 = this.validated;
3827             <span class="keyword">end</span>
3828             
3829             value = this.strandBreaks5;
3830         <span class="keyword">end</span>
3831         
3832         <a name="_sub116" href="#_subfunctions" class="code">function value = calcStrandBreaks5(this)</a>
3833             value = this.unshiftCircularSparseMatBond5Prime(this.strandBreaks);
3834         <span class="keyword">end</span>
3835         
3836         <span class="comment">%boolean (genome length x 2) indicating positions of holliday junctions</span>
3837         <span class="comment">%3' to bases</span>
3838         <a name="_sub117" href="#_subfunctions" class="code">function value = get.hollidayJunctions3(this)</a>
3839             <span class="keyword">if</span> this.validated_hollidayJunctions &gt; this.validated_hollidayJunctions3
3840                 this.hollidayJunctions3 = this.calcHollidayJunctions3();
3841                 this.validated_hollidayJunctions3 = this.validated;
3842             <span class="keyword">end</span>
3843             
3844             value = this.hollidayJunctions3;
3845         <span class="keyword">end</span>
3846         
3847         <a name="_sub118" href="#_subfunctions" class="code">function value = calcHollidayJunctions3(this)</a>
3848             value = this.shiftCircularSparseMatBond5Prime(this.hollidayJunctions);
3849         <span class="keyword">end</span>
3850         
3851         <span class="comment">%boolean (genome length x 2) indicating positions of holliday junctions</span>
3852         <span class="comment">%5' to bases</span>
3853         <a name="_sub119" href="#_subfunctions" class="code">function value = get.hollidayJunctions5(this)</a>
3854             <span class="keyword">if</span> this.validated_hollidayJunctions &gt; this.validated_hollidayJunctions5
3855                 this.hollidayJunctions5 = this.calcHollidayJunctions5();
3856                 this.validated_hollidayJunctions5 = this.validated;
3857             <span class="keyword">end</span>
3858             
3859             value = this.hollidayJunctions5;
3860         <span class="keyword">end</span>
3861         
3862         <a name="_sub120" href="#_subfunctions" class="code">function value = calcHollidayJunctions5(this)</a>
3863             value = this.shiftCircularSparseMatBond3Prime(this.hollidayJunctions);
3864         <span class="keyword">end</span>
3865         
3866         <span class="comment">%boolean (genome length x 2) indicating positions of single</span>
3867         <span class="comment">%strand breaks -- strand breaks excluding</span>
3868         <span class="comment">%- double strand breaks that are part of double strand breaks</span>
3869         <span class="comment">%- strand breaks adjacent to gap sites</span>
3870         <a name="_sub121" href="#_subfunctions" class="code">function value = get.singleStrandBreaks(this)</a>
3871             <span class="keyword">if</span> this.validated_damaged &gt; this.validated_singleStrandBreaks
3872                 this.singleStrandBreaks = this.calcSingleStrandBreaks();
3873                 this.validated_singleStrandBreaks = this.validated;
3874             <span class="keyword">end</span>
3875             
3876             value = this.singleStrandBreaks;
3877         <span class="keyword">end</span>
3878         
3879         <a name="_sub122" href="#_subfunctions" class="code">function value = calcSingleStrandBreaks(this)           </a>
3880             value = this.strandBreaks;
3881             
3882             <span class="comment">%exclude strand breaks that are part of double strand breaks</span>
3883             value(find(this.doubleStrandBreaks)) = 0; <span class="comment">%#ok&lt;FNDSB&gt;</span>
3884             
3885             <span class="comment">%exclude strand breaks adjacent to other damage (except holliday</span>
3886             <span class="comment">%junctions)</span>
3887             otherDamages = this.getDamagedSites(true, false, true, true, false, false, false);
3888             value(find( <span class="keyword">...</span>
3889                 this.shiftCircularSparseMatBond3Prime(otherDamages) | <span class="keyword">...</span>
3890                 this.shiftCircularSparseMatBond5Prime(otherDamages) <span class="keyword">...</span>
3891                 )) = 0; <span class="comment">%#ok&lt;FNDSB&gt;</span>
3892             
3893             <span class="comment">%cast to logical sparse mat</span>
3894             value = valueCast(value, <span class="string">'logical'</span>);
3895         <span class="keyword">end</span>
3896         
3897         <a name="_sub123" href="#_subfunctions" class="code">function value = get.doubleStrandBreaks(this)</a>
3898             <span class="keyword">if</span> this.validated_strandBreaks &gt; this.validated_doubleStrandBreaks
3899                 this.doubleStrandBreaks = this.calcDoubleStrandBreaks();
3900                 this.validated_doubleStrandBreaks = this.validated;
3901             <span class="keyword">end</span>
3902             
3903             value = this.doubleStrandBreaks;
3904         <span class="keyword">end</span>
3905         
3906         <a name="_sub124" href="#_subfunctions" class="code">function value = calcDoubleStrandBreaks(this)</a>
3907             import edu.stanford.covert.util.CircularSparseMat;
3908             
3909             <span class="keyword">if</span> this.doubleStrandBreakSeparation ~= 1
3910                 throw(MException(<span class="string">'DNARepair:error'</span>,<span class="string">'Simulation only valid for doubleStrandBreakSeparation equal 1'</span>));
3911             <span class="keyword">end</span>
3912             
3913             value = this.strandBreaks(:, 1:2:<span class="keyword">end</span>, :) &amp; this.strandBreaks(:, 2:2:<span class="keyword">end</span>, :);
3914             value = [value(:,1) value(:,1) value(:,2) value(:,2)];
3915         <span class="keyword">end</span>
3916                 
3917         <a name="_sub125" href="#_subfunctions" class="code">function value = get.restrictableMunIRMSites(this)</a>
3918             <span class="keyword">if</span> <span class="keyword">...</span>
3919                     this.validated_damagedBases &gt; this.validated_munIRMSiteRestrictionStatus || <span class="keyword">...</span>
3920                     this.validated_strandBreaks &gt; this.validated_munIRMSiteRestrictionStatus
3921                 this.restrictableMunIRMSites = this.calcRestrictableMunIRMSites();
3922                 this.validated_munIRMSiteRestrictionStatus = this.validated;
3923             <span class="keyword">end</span>
3924             
3925             value = this.restrictableMunIRMSites;
3926         <span class="keyword">end</span>
3927         
3928         <a name="_sub126" href="#_subfunctions" class="code">function value = get.hemiunmethylatedMunIRMSites(this)</a>
3929             <span class="keyword">if</span> this.validated_damagedBases &gt; this.validated_munIRMSiteMethylationStatus
3930                 this.hemiunmethylatedMunIRMSites = this.calcHemiunmethylatedMunIRMSites();
3931                 this.validated_munIRMSiteMethylationStatus = this.validated;
3932             <span class="keyword">end</span>
3933             
3934             value = this.hemiunmethylatedMunIRMSites;
3935         <span class="keyword">end</span>
3936         
3937         <a name="_sub127" href="#_subfunctions" class="code">function value = calcRestrictableMunIRMSites(this)</a>
3938             import edu.stanford.covert.util.CircularSparseMat;
3939             
3940             dr = this.dnaRepair;
3941             nSites = size(dr.RM_MunI_RecognitionSites, 1);
3942             methylationPosStrnds = [
3943                 dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_MethylatedPositions(1))   ones(nSites, 1);
3944                 dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_MethylatedPositions(1)) 3*ones(nSites, 1);
3945                 dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_MethylatedPositions(2)) 2*ones(nSites, 1);
3946                 dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_MethylatedPositions(2)) 4*ones(nSites, 1)];
3947             restrictionPosStrnds = [
3948                 dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_RestrictionPositions(1))   ones(nSites, 1);
3949                 dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_RestrictionPositions(1)) 3*ones(nSites, 1);
3950                 dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_RestrictionPositions(2)) 2*ones(nSites, 1);
3951                 dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_RestrictionPositions(2)) 4*ones(nSites, 1)];
3952             
3953             isPositionMethylated = reshape(this.damagedBases(methylationPosStrnds), [], 2) == this.metabolite.m6ADIndexs;
3954             isPositionDamaged = [
3955                 cat(3, <span class="keyword">...</span>
3956                     reshape(this.damagedSites_shifted_incm6AD([dr.RM_MunI_RecognitionSites(:)   ones(6*nSites, 1)]), [], 6), <span class="keyword">...</span>
3957                     reshape(this.damagedSites_shifted_incm6AD([dr.RM_MunI_RecognitionSites(:) 2*ones(6*nSites, 1)]), [], 6))
3958                 cat(3, <span class="keyword">...</span>
3959                     reshape(this.damagedSites_shifted_incm6AD([dr.RM_MunI_RecognitionSites(:) 3*ones(6*nSites, 1)]), [], 6), <span class="keyword">...</span>
3960                     reshape(this.damagedSites_shifted_incm6AD([dr.RM_MunI_RecognitionSites(:) 4*ones(6*nSites, 1)]), [], 6))];
3961             isPositionStrandBreaks = [
3962                 cat(3, <span class="keyword">...</span>
3963                     this.strandBreaks([reshape(dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_RestrictionPositions(1)), [], 1),   ones(nSites, 1)]),<span class="keyword">...</span>
3964                     this.strandBreaks([reshape(dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_RestrictionPositions(2)), [], 1), 2*ones(nSites, 1)])), <span class="keyword">...</span>
3965                 cat(3, <span class="keyword">...</span>
3966                     this.strandBreaks([reshape(dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_RestrictionPositions(1)), [], 1), 3*ones(nSites, 1)]),<span class="keyword">...</span>
3967                     this.strandBreaks([reshape(dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_RestrictionPositions(2)), [], 1), 4*ones(nSites, 1)]))];
3968             isPositionDamaged(isPositionStrandBreaks) = 0;
3969             isSiteUndamaged = ~any(any(isPositionDamaged, 2), 3);
3970             
3971             isSiteUnmethylated = ~any(isPositionMethylated, 2);
3972             isSitePolymerized = this.isRegionPolymerized(restrictionPosStrnds, 1, false, false, false);
3973             
3974             value = CircularSparseMat(<span class="keyword">...</span>
3975                 restrictionPosStrnds([isSiteUnmethylated; isSiteUnmethylated] &amp; [isSiteUndamaged; isSiteUndamaged] &amp; isSitePolymerized, :), <span class="keyword">...</span>
3976                 true, [this.sequenceLen this.nCompartments], 1);
3977         <span class="keyword">end</span>
3978         
3979         <a name="_sub128" href="#_subfunctions" class="code">function value = calcHemiunmethylatedMunIRMSites(this)</a>
3980             import edu.stanford.covert.util.CircularSparseMat;
3981             
3982             dr = this.dnaRepair;
3983             nSites = size(dr.RM_MunI_RecognitionSites, 1);
3984             methylationPosStrnds = [
3985                 dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_MethylatedPositions(1))   ones(nSites, 1);
3986                 dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_MethylatedPositions(1)) 3*ones(nSites, 1);
3987                 dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_MethylatedPositions(2)) 2*ones(nSites, 1);
3988                 dr.RM_MunI_RecognitionSites(:, dr.RM_MunI_MethylatedPositions(2)) 4*ones(nSites, 1)];
3989             
3990             isPositionMethylated = reshape(this.damagedBases(methylationPosStrnds), [], 2) == this.metabolite.m6ADIndexs;
3991             
3992             isSiteMethylated = all(isPositionMethylated, 2);
3993             isSiteUnmethylated = ~any(isPositionMethylated, 2);
3994             isSiteHemimethylated = ~isSiteMethylated &amp; ~isSiteUnmethylated;
3995             
3996             value = CircularSparseMat(<span class="keyword">...</span>
3997                 methylationPosStrnds([isSiteHemimethylated; isSiteHemimethylated] &amp; ~isPositionMethylated(:), :),  <span class="keyword">...</span>
3998                 1, [this.sequenceLen this.nCompartments], 1);
3999         <span class="keyword">end</span>
4000                 
4001         <a name="_sub129" href="#_subfunctions" class="code">function value = get.dryWeight(this)</a>
4002             <span class="keyword">if</span> max(this.validated_polymerizedRegions, this.validated_damaged) &gt; this.validated_dryWeight
4003                 this.dryWeight = this.calcDryWeight();
4004                 this.validated_dryWeight = this.validated;
4005             <span class="keyword">end</span>
4006            
4007             value = this.dryWeight;
4008         <span class="keyword">end</span>
4009         
4010         <a name="_sub130" href="#_subfunctions" class="code">function value = calcDryWeight(this)</a>
4011             import edu.stanford.covert.util.ConstantUtil;
4012             
4013             <span class="comment">%time</span>
4014             numTime = size(this.abasicSites, 3);
4015             
4016             <span class="comment">%mass of undamaged DNA</span>
4017             baseCounts = zeros(4, numTime);
4018             bonds = zeros(1, numTime);
4019             [positionsStrandTimes, lengths] = find(this.getStrandView(<span class="string">'polymerizedRegions'</span>));
4020             positionsStrandTimes = [positionsStrandTimes ones(size(positionsStrandTimes, 1), 3 - size(positionsStrandTimes, 2))];
4021             
4022             <span class="keyword">for</span> i = 1:size(positionsStrandTimes, 1)
4023                 <span class="keyword">if</span> lengths(i) == this.sequenceLen
4024                     baseCounts(:, positionsStrandTimes(i, 3)) = <span class="keyword">...</span>
4025                         baseCounts(:, positionsStrandTimes(i, 3)) + <span class="keyword">...</span>
4026                         getBaseCounts(this.sequence, positionsStrandTimes(i, 2));
4027                 <span class="keyword">else</span>
4028                     baseCounts(:, positionsStrandTimes(i, 3)) = <span class="keyword">...</span>
4029                         baseCounts(:, positionsStrandTimes(i, 3)) + <span class="keyword">...</span>
4030                         this.sequence.subsequenceBaseCounts(positionsStrandTimes(i,1) + (0:lengths(i)-1)', positionsStrandTimes(i, 2));
4031                 <span class="keyword">end</span>
4032                 bonds(1, positionsStrandTimes(i,3)) = <span class="keyword">...</span>
4033                     bonds(1, positionsStrandTimes(i,3)) + lengths(i) - 1;
4034                 
4035                 <span class="keyword">if</span> <span class="keyword">...</span>
4036                         lengths(i) == this.sequenceLen || <span class="keyword">...</span>
4037                         (positionsStrandTimes(i, 1) + lengths(i) - 1 == this.sequenceLen &amp;&amp; <span class="keyword">...</span>
4038                         ismember([1 positionsStrandTimes(i, 2:end)], positionsStrandTimes, <span class="string">'rows'</span>))
4039                     bonds(1, positionsStrandTimes(i,3)) = <span class="keyword">...</span>
4040                         bonds(1, positionsStrandTimes(i,3)) + 1;
4041                 <span class="keyword">end</span>
4042             <span class="keyword">end</span>
4043             
4044             value = this.metabolite.molecularWeights(this.metabolite.dnmpIndexs)' * baseCounts <span class="keyword">...</span>
4045                 - (ConstantUtil.elements.H + ConstantUtil.elements.O) * bonds;
4046             
4047             <span class="comment">%mass represented by damage</span>
4048             <span class="keyword">for</span> k = 1:numTime
4049                 <span class="comment">%gap sites</span>
4050                 value(:,k) = value(:,k) - <span class="keyword">...</span>
4051                     (this.metabolite.molecularWeights(this.metabolite.dr5pIndexs) - <span class="keyword">...</span>
4052                     2 * ConstantUtil.elements.H) * collapse(this.gapSites(:,:,k));
4053                 
4054                 <span class="comment">%abasic sites</span>
4055                 [position, index] = find(this.abasicSites(:,:,k));
4056                 value(:,k) = value(:,k) - <span class="keyword">...</span>
4057                     length(index) * this.metabolite.molecularWeights(this.metabolite.waterIndexs) - <span class="keyword">...</span>
4058                     this.sequence.subsequenceBaseCounts(position)' * <span class="keyword">...</span>
4059                     this.metabolite.molecularWeights(this.metabolite.dnmpIndexs);
4060                 
4061                 <span class="comment">%damaged sugar-phosphates</span>
4062                 [~, index] = find(this.damagedSugarPhosphates(:,:,k));
4063                 value(:,k) = value(:,k) + <span class="keyword">...</span>
4064                     sum(this.metabolite.molecularWeights(index)) - <span class="keyword">...</span>
4065                     length(index) * this.metabolite.molecularWeights(this.metabolite.dr5pIndexs);
4066                 
4067                 <span class="comment">%damaged bases</span>
4068                 [position, index] = find(this.damagedBases(:,:,k));
4069                 value(:,k) = value(:,k) + <span class="keyword">...</span>
4070                     sum(this.metabolite.molecularWeights(index)) - <span class="keyword">...</span>
4071                     this.sequence.subsequenceBaseCounts(position)' * <span class="keyword">...</span>
4072                     this.metabolite.molecularWeights(this.metabolite.unmodifiedBaseIndexs);
4073                 
4074                 <span class="comment">%intrastrand cross links</span>
4075                 [position, index] = find(this.intrastrandCrossLinks(:,:,k));
4076                 value(:,k) = value(:,k) + <span class="keyword">...</span>
4077                     sum(this.metabolite.molecularWeights(index)) - <span class="keyword">...</span>
4078                     this.sequence.subsequenceBaseCounts([position(:,1) position(:,1) + 1], position(:,2))' * <span class="keyword">...</span>
4079                     this.metabolite.molecularWeights(this.metabolite.dnmpIndexs);
4080                 
4081                 <span class="comment">%strand breaks</span>
4082                 value(:,k) = value(:,k) + <span class="keyword">...</span>
4083                     (ConstantUtil.elements.H + ConstantUtil.elements.O)*<span class="keyword">...</span>
4084                     collapse(this.strandBreaks(:,:,k));
4085             <span class="keyword">end</span>
4086             
4087             value = permute(value, [1 3 2]);
4088             value = value / ConstantUtil.nAvogadro;
4089         <span class="keyword">end</span>
4090     <span class="keyword">end</span>
4091     
4092     <span class="comment">%helper methods</span>
4093     methods (Static)
4094         <a name="_sub131" href="#_subfunctions" class="code">function value = shiftCircularSparseMatBase3Prime(sparseMat, varargin)</a>
4095             import edu.stanford.covert.cell.sim.state.Chromosome;
4096             import edu.stanford.covert.util.CircularSparseMat;
4097             
4098             <span class="keyword">if</span> ~isa(sparseMat,<span class="string">'CircularSparseMat'</span>) || ~isDimCircular(sparseMat, 1)
4099                 throw(MException(<span class="string">'Chromosome:error'</span>,<span class="string">'sparseMat must be a circular sparse mat with a circular first dimension'</span>));
4100             <span class="keyword">end</span>
4101             
4102             [subs, vals] = find(sparseMat);
4103             subs = Chromosome.shiftPositionsStrandsBase3Prime(subs, varargin{:});
4104             value = CircularSparseMat(subs, vals, size(sparseMat), 1);
4105         <span class="keyword">end</span>
4106         
4107         <a name="_sub132" href="#_subfunctions" class="code">function value = shiftCircularSparseMatBase5Prime(sparseMat, varargin)</a>
4108             import edu.stanford.covert.cell.sim.state.Chromosome;
4109             import edu.stanford.covert.util.CircularSparseMat;
4110             
4111             <span class="keyword">if</span> ~isa(sparseMat,<span class="string">'CircularSparseMat'</span>) || ~isDimCircular(sparseMat, 1)
4112                 throw(MException(<span class="string">'Chromosome:error'</span>,<span class="string">'sparseMat must be a circular sparse mat with a circular first dimension'</span>));
4113             <span class="keyword">end</span>
4114             
4115             [subs, vals] = find(sparseMat);
4116             subs = Chromosome.shiftPositionsStrandsBase5Prime(subs, varargin{:});
4117             value = CircularSparseMat(subs, vals, size(sparseMat), 1);
4118         <span class="keyword">end</span>
4119         
4120         <a name="_sub133" href="#_subfunctions" class="code">function value = shiftCircularSparseMatBond3Prime(sparseMat, varargin)</a>
4121             import edu.stanford.covert.cell.sim.state.Chromosome;
4122             import edu.stanford.covert.util.CircularSparseMat;
4123             
4124             <span class="keyword">if</span> ~isa(sparseMat,<span class="string">'CircularSparseMat'</span>) || ~isDimCircular(sparseMat, 1)
4125                 throw(MException(<span class="string">'Chromosome:error'</span>,<span class="string">'sparseMat must be a circular sparse mat with a circular first dimension'</span>));
4126             <span class="keyword">end</span>
4127             
4128             [subs, vals] = find(sparseMat);
4129             subs = Chromosome.shiftPositionsStrandsBond3Prime(subs, varargin{:});
4130             value = CircularSparseMat(subs, vals, size(sparseMat), 1);
4131         <span class="keyword">end</span>
4132         
4133         <a name="_sub134" href="#_subfunctions" class="code">function value = unshiftCircularSparseMatBond3Prime(sparseMat, varargin)</a>
4134             import edu.stanford.covert.cell.sim.state.Chromosome;
4135             import edu.stanford.covert.util.CircularSparseMat;
4136             
4137             <span class="keyword">if</span> ~isa(sparseMat,<span class="string">'CircularSparseMat'</span>) || ~isDimCircular(sparseMat, 1)
4138                 throw(MException(<span class="string">'Chromosome:error'</span>,<span class="string">'sparseMat must be a circular sparse mat with a circular first dimension'</span>));
4139             <span class="keyword">end</span>
4140             
4141             [subs, vals] = find(sparseMat);
4142             subs = Chromosome.unshiftPositionsStrandsBond3Prime(subs, varargin{:});
4143             value = CircularSparseMat(subs, vals, size(sparseMat), 1);
4144         <span class="keyword">end</span>
4145         
4146         <a name="_sub135" href="#_subfunctions" class="code">function value = shiftCircularSparseMatBond5Prime(sparseMat, varargin)</a>
4147             import edu.stanford.covert.cell.sim.state.Chromosome;
4148             import edu.stanford.covert.util.CircularSparseMat;
4149             
4150             <span class="keyword">if</span> ~isa(sparseMat,<span class="string">'CircularSparseMat'</span>) || ~isDimCircular(sparseMat, 1)
4151                 throw(MException(<span class="string">'Chromosome:error'</span>,<span class="string">'sparseMat must be a circular sparse mat with a circular first dimension'</span>));
4152             <span class="keyword">end</span>
4153             
4154             [subs, vals] = find(sparseMat);
4155             subs = Chromosome.shiftPositionsStrandsBond5Prime(subs, varargin{:});
4156             value = CircularSparseMat(subs, vals, size(sparseMat), 1);
4157         <span class="keyword">end</span>
4158         
4159         <a name="_sub136" href="#_subfunctions" class="code">function value = unshiftCircularSparseMatBond5Prime(sparseMat, varargin)</a>
4160             import edu.stanford.covert.cell.sim.state.Chromosome;
4161             import edu.stanford.covert.util.CircularSparseMat;
4162             
4163             <span class="keyword">if</span> ~isa(sparseMat,<span class="string">'CircularSparseMat'</span>) || ~isDimCircular(sparseMat, 1)
4164                 throw(MException(<span class="string">'Chromosome:error'</span>,<span class="string">'sparseMat must be a circular sparse mat with a circular first dimension'</span>));
4165             <span class="keyword">end</span>
4166             
4167             [subs, vals] = find(sparseMat);
4168             subs = Chromosome.unshiftPositionsStrandsBond5Prime(subs, varargin{:});
4169             value = CircularSparseMat(subs, vals, size(sparseMat), 1);
4170         <span class="keyword">end</span>
4171         
4172         <a name="_sub137" href="#_subfunctions" class="code">function positionsStrands = shiftPositionsStrandsBase3Prime(positionsStrands, lengths)</a>
4173             <span class="keyword">if</span> nargin &lt; 2
4174                 lengths = 1; 
4175             <span class="keyword">end</span>
4176             
4177             positionsStrands(mod(positionsStrands(:,2),2)==1, 1) = <span class="keyword">...</span>
4178                 positionsStrands(mod(positionsStrands(:,2),2)==1, 1) + lengths;
4179             positionsStrands(mod(positionsStrands(:,2),2)==0, 1) = <span class="keyword">...</span>
4180                 positionsStrands(mod(positionsStrands(:,2),2)==0, 1) - lengths;
4181         <span class="keyword">end</span>
4182         
4183         <a name="_sub138" href="#_subfunctions" class="code">function positionsStrands = shiftPositionsStrandsBase5Prime(positionsStrands, lengths)</a>
4184             <span class="keyword">if</span> nargin &lt; 2
4185                 lengths = 1; 
4186             <span class="keyword">end</span>
4187             
4188             positionsStrands(mod(positionsStrands(:,2),2)==1, 1) = <span class="keyword">...</span>
4189                 positionsStrands(mod(positionsStrands(:,2),2)==1, 1) - lengths;
4190             positionsStrands(mod(positionsStrands(:,2),2)==0, 1) = <span class="keyword">...</span>
4191                 positionsStrands(mod(positionsStrands(:,2),2)==0, 1) + lengths;
4192         <span class="keyword">end</span>
4193         
4194         <a name="_sub139" href="#_subfunctions" class="code">function positionsStrands = shiftPositionsStrandsBond3Prime(positionsStrands, lengths)</a>
4195             <span class="keyword">if</span> nargin &lt; 2
4196                 lengths = 1; 
4197             <span class="keyword">end</span>
4198             
4199             positionsStrands(mod(positionsStrands(:,2),2)==0, 1) = <span class="keyword">...</span>
4200                 positionsStrands(mod(positionsStrands(:,2),2)==0, 1) - lengths;
4201         <span class="keyword">end</span>
4202         
4203         <a name="_sub140" href="#_subfunctions" class="code">function positionsStrands = unshiftPositionsStrandsBond3Prime(positionsStrands, lengths)</a>
4204             <span class="keyword">if</span> nargin &lt; 2
4205                 lengths = 1; 
4206             <span class="keyword">end</span>
4207             
4208             positionsStrands(mod(positionsStrands(:,2),2)==0, 1) = <span class="keyword">...</span>
4209                 positionsStrands(mod(positionsStrands(:,2),2)==0, 1) + lengths;
4210         <span class="keyword">end</span>
4211         
4212         <a name="_sub141" href="#_subfunctions" class="code">function positionsStrands = shiftPositionsStrandsBond5Prime(positionsStrands, lengths)</a>
4213             <span class="keyword">if</span> nargin &lt; 2
4214                 lengths = 1;
4215             <span class="keyword">end</span>
4216             
4217             positionsStrands(mod(positionsStrands(:,2),2)==1, 1) = <span class="keyword">...</span>
4218                 positionsStrands(mod(positionsStrands(:,2),2)==1, 1) - lengths;
4219         <span class="keyword">end</span>
4220         
4221         <a name="_sub142" href="#_subfunctions" class="code">function positionsStrands = unshiftPositionsStrandsBond5Prime(positionsStrands, lengths)</a>
4222             <span class="keyword">if</span> nargin &lt; 2
4223                 lengths = 1;
4224             <span class="keyword">end</span>
4225             
4226             positionsStrands(mod(positionsStrands(:,2),2)==1, 1) = <span class="keyword">...</span>
4227                 positionsStrands(mod(positionsStrands(:,2),2)==1, 1) + lengths;
4228         <span class="keyword">end</span>
4229         
4230         <a name="_sub143" href="#_subfunctions" class="code">function [footprint3Prime, footprint5Prime] = calculateFootprintOverhangs(footprint)</a>
4231             footprint5Prime = ceil((footprint-1)/2);
4232             footprint3Prime = footprint - 1 - footprint5Prime;
4233         <span class="keyword">end</span>
4234     <span class="keyword">end</span>
4235     
4236     <span class="comment">%printing</span>
4237     methods
4238         <span class="comment">%print state</span>
4239         <a name="_sub144" href="#_subfunctions" class="code">function disp(this)</a>
4240             <span class="comment">%superclass method</span>
4241             this.disp@edu.stanford.covert.cell.sim.CellState();
4242 
4243             <span class="comment">%numbers of DNA damages</span>
4244             fprintf(<span class="string">'%24s\t%4s\n'</span>,<span class="string">'Damage Type'</span>,<span class="string">'No.'</span>);
4245             fprintf(<span class="string">'%24s\t%4s\n'</span>,repmat(<span class="string">'='</span>,1,24), repmat(<span class="string">'='</span>,1,4));
4246             fprintf(<span class="string">'%24s\t%4d\n'</span>,<span class="string">'Gap Sites'</span>,               collapse(this.gapSites));
4247             fprintf(<span class="string">'%24s\t%4d\n'</span>,<span class="string">'Abasic Sites'</span>,            collapse(this.abasicSites));
4248             fprintf(<span class="string">'%24s\t%4d\n'</span>,<span class="string">'Damaged sugar phosphates'</span>,collapse(this.damagedSugarPhosphates));
4249             fprintf(<span class="string">'%24s\t%4d\n'</span>,<span class="string">'Damaged bases'</span>,           collapse(this.damagedBases));
4250             fprintf(<span class="string">'%24s\t%4d\n'</span>,<span class="string">'Intrastrand cross links'</span>, collapse(this.intrastrandCrossLinks));
4251             fprintf(<span class="string">'%24s\t%4d\n'</span>,<span class="string">'Strand breaks'</span>,           collapse(this.strandBreaks));
4252             fprintf(<span class="string">'%24s\t%4d\n'</span>,<span class="string">'Holliday junctions'</span>,      collapse(this.hollidayJunctions));
4253             fprintf(<span class="string">'\n'</span>);
4254             
4255             <span class="comment">%strand break classification used in track structure models</span>
4256             sbc = this.strandBreakClassification();
4257             fprintf(<span class="string">'%24s\t%4s\n'</span>,<span class="string">'Strand Break'</span>,<span class="string">'No.'</span>)
4258             fprintf(<span class="string">'%24s\t%4s\n'</span>,repmat(<span class="string">'='</span>,1,24), repmat(<span class="string">'='</span>,1,4))
4259             fprintf(<span class="string">'%24s\t%4d\n'</span>,<span class="string">'NB'</span>,    sbc(this.strandBreakClassification_index_NB));
4260             fprintf(<span class="string">'%24s\t%4d\n'</span>,<span class="string">'SSB'</span>,   sbc(this.strandBreakClassification_index_SSB));
4261             fprintf(<span class="string">'%24s\t%4d\n'</span>,<span class="string">'SSB+'</span>,  sbc(this.strandBreakClassification_index_SSB_));
4262             fprintf(<span class="string">'%24s\t%4d\n'</span>,<span class="string">'2SSB'</span>,  sbc(this.strandBreakClassification_index_2SSB));
4263             fprintf(<span class="string">'%24s\t%4d\n'</span>,<span class="string">'DSB'</span>,   sbc(this.strandBreakClassification_index_DSB));
4264             fprintf(<span class="string">'%24s\t%4d\n'</span>,<span class="string">'DSB+'</span>,  sbc(this.strandBreakClassification_index_DSB_));
4265             fprintf(<span class="string">'%24s\t%4d\n'</span>,<span class="string">'DSB++'</span>, sbc(this.strandBreakClassification_index_DSB__));
4266             fprintf(<span class="string">'\n'</span>);
4267             
4268             <span class="comment">%list of damaged genes</span>
4269             fprintf(<span class="string">'%13s\n'</span>,<span class="string">'Damaged Genes'</span>);
4270             fprintf(<span class="string">'%13s\n'</span>,repmat(<span class="string">'='</span>,1,13));
4271             damagedGeneWholeCellModelIDs = this.gene.wholeCellModelIDs(~all(this.accessibleGenes,2));
4272             damagedGeneWholeCellNames    = this.gene.names(~all(this.accessibleGenes,2));
4273             <span class="keyword">for</span> i=1:length(damagedGeneWholeCellModelIDs);
4274                 damagedGeneWholeCellModelID = damagedGeneWholeCellModelIDs{i};
4275                 damagedGeneWholeCellName    = damagedGeneWholeCellNames{i};
4276                 <span class="keyword">if</span> length(damagedGeneWholeCellModelID)&gt;12; damagedGeneWholeCellModelID=[damagedGeneWholeCellModelID(1:8) <span class="string">' ...'</span>]; <span class="keyword">end</span>;
4277                 <span class="keyword">if</span> length(damagedGeneWholeCellName)&gt;32; damagedGeneWholeCellName=[damagedGeneWholeCellName(1:28) <span class="string">' ...'</span>]; <span class="keyword">end</span>;
4278                 fprintf(<span class="string">'%12s\t%32s\n'</span>,damagedGeneWholeCellModelID,damagedGeneWholeCellName);
4279             <span class="keyword">end</span>
4280             fprintf(<span class="string">'\n'</span>);
4281             
4282             <span class="comment">%list of damaged transcription units</span>
4283             fprintf(<span class="string">'%27s\n'</span>,<span class="string">'Damaged Transcription Units'</span>);
4284             fprintf(<span class="string">'%27s\n'</span>,repmat(<span class="string">'='</span>,1,27));
4285             damagedTranscriptionUnitWholeCellModelIDs = this.transcriptionUnitWholeCellModelIDs(~all(this.accessibleTranscriptionUnits,2));
4286             damagedTranscriptionUnitWholeCellNames    = this.transcriptionUnitNames(~all(this.accessibleTranscriptionUnits,2));
4287             <span class="keyword">for</span> i=1:length(damagedTranscriptionUnitWholeCellModelIDs);
4288                 damagedTranscriptionUnitWholeCellModelID = damagedTranscriptionUnitWholeCellModelIDs{i};
4289                 damagedTranscriptionUnitWholeCellName    = damagedTranscriptionUnitWholeCellNames{i};
4290                 <span class="keyword">if</span> length(damagedTranscriptionUnitWholeCellModelID)&gt;12; damagedTranscriptionUnitWholeCellModelID=[damagedTranscriptionUnitWholeCellModelID(1:8) <span class="string">' ...'</span>]; <span class="keyword">end</span>;
4291                 <span class="keyword">if</span> length(damagedTranscriptionUnitWholeCellName)&gt;32; damagedTranscriptionUnitWholeCellName=[damagedTranscriptionUnitWholeCellName(1:28) <span class="string">' ...'</span>]; <span class="keyword">end</span>;
4292                 fprintf(<span class="string">'%12s\t%32s\n'</span>,damagedTranscriptionUnitWholeCellModelID,damagedTranscriptionUnitWholeCellName);
4293             <span class="keyword">end</span>
4294             fprintf(<span class="string">'\n'</span>);
4295         <span class="keyword">end</span>
4296     <span class="keyword">end</span>
4297 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 19-Jul-2012 18:32:13 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>