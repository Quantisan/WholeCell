<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of linearProgramming</title>
  <meta name="keywords" content="linearProgramming">
  <meta name="description" content="Provides a common interface to several linear programming solvers.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../../../../../index.html">Home</a> &gt;  <a href="../../../../../../index.html">simulation</a> &gt; <a href="#">src</a> &gt; <a href="#">+edu</a> &gt; <a href="#">+stanford</a> &gt; <a href="#">+covert</a> &gt; <a href="../index.html">+util</a> &gt; <a href="index.html">@ComputationUtil</a> &gt; linearProgramming.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../../../../../index.html"><img alt="<" border="0" src="../../../../../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for simulation/src/+edu/+stanford/+covert/+util/@ComputationUtil&nbsp;<img alt=">" border="0" src="../../../../../../../right.png"></a></td></tr></table>-->

<h1>linearProgramming
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../../../../up.png"></a></h2>
<div class="box"><strong>Provides a common interface to several linear programming solvers.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../../../../up.png"></a></h2>
<div class="box"><strong>function varargout = linearProgramming(maximizeFlag, f, A, b, lb, ub, constraintTypes, variableTypes, options) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Provides a common interface to several linear programming solvers.
 Checks each solver for errors.

 That is it solves the problem:
   max f'*x
   subject to A*x~b, lb&lt;=x&lt;=ub
 where &quot;~&quot; can be equality, or double or single-sided inequality
 constraints if the chosen linear programming solver supports those
 types of constraints. Additionally the variables, x, can, if the chosen
 linear programming solver supports it, either continuous, integer, and
 boolean valued.

 Constraint Types: etiher a single value, or a column vector or values:
   'F' Free (unbounded) variable (the constraint is ignored).
   'U' Variable with upper bound ( A(i,:)*x &lt;= b(i)).
   'S' Fixed Variable (A(i,:)*x = b(i)).
   'L' Variable with lower bound (A(i,:)*x &gt;= b(i)).
   'D' Double-bounded variable (A(i,:)*x &gt;= -b(i) and A(i,:)*x &lt;= b(i)).

 Variable Types: either a single value, or a column vector or values:
   'C' Continuous variable.
   'I' Integer variable
   'B' Binary variable

 Output
  x
  lambda, 
  fopt
  errorFlag
  errorMsg
  extra

 Requirements: at least one of the following linear programing solvers
 - glpk -- GNU Linear programming kit, to solve linear programming problems
   http://sourceforge.net/projects/glpkmex/
 - lp_solve -- open source solve linear programming solver
   http://sourceforge.net/projects/lpsolve
 - clp -- open source solve linear programming solver
   http://control.ee.ethz.ch/~joloef/mexclp.zip
 - bpmpd -- open source solve linear programming solver
   http://www.pserc.cornell.edu/bpmpd/
 - qsopt -- open source solve linear programming solver
   http://control.ee.ethz.ch/~joloef/mexqsopt.msql
 - Optimization Toolbox - has linprog, MATLAB's linear programming
   solver. Note: linprog is not vevy good. We suggest you use another
   solver instead.
   http://www.mathworks.com/products/optimization/

 Author: Jonathan Karr
 Affiliation: Covert Lab, Department of Bioengineering, Stanford University
 Last updated: 10/31/2008</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../../../../../matlabicon.gif)">
<li><a href="ComputationUtil.html" class="code" title="">ComputationUtil</a>	Utility functions for various computations:</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../../../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../../../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [x, lambda, fopt, errorFlag, errorMsg, extra] = runlinprog(f, A, b, lb, ub, sense, constraintTypes, variableTypes, options)</a></li><li><a href="#_sub2" class="code">function [x, lambda, fopt, errorFlag, errorMsg, extra] = runglpk(f, A, b, lb, ub, sense, constraintTypes, variableTypes, options)</a></li><li><a href="#_sub3" class="code">function [x, lambda, fopt, errorFlag, errorMsg, extra] = runlpsolve(f, A, b, lb, ub, sense, constraintTypes, variableTypes, options)</a></li><li><a href="#_sub4" class="code">function [x, lambda, fopt, errorFlag, errorMsg, extra] = runqsopt(f, A, b, lb, ub, sense, constraintTypes, variableTypes, options)</a></li><li><a href="#_sub5" class="code">function [x, lambda, fopt, errorFlag, errorMsg, extra] = runclp(f, A, b, lb, ub, sense, constraintTypes, variableTypes, options)</a></li><li><a href="#_sub6" class="code">function [x, lambda, fopt, errorFlag, errorMsg, extra] = runbpmpd(f, A, b, lb, ub, sense, constraintTypes, variableTypes, ~)</a></li><li><a href="#_sub7" class="code">function [x, lambda, fopt, errorFlag, errorMsg, extra] = runtomlab( f, A, b, lb, ub, sense, constraintTypes, ~, options)</a></li><li><a href="#_sub8" class="code">function [x, lambda, fopt, errorFlag, errorMsg, extra] = runcplex( f, A, b, lb, ub, sense, constraintTypes, variableTypes, options)</a></li><li><a href="#_sub9" class="code">function [x, lambda, fopt, errorFlag, errorMsg, extra] = rungurobi( f, A, b, lb, ub, sense, constraintTypes, variableTypes, options)</a></li><li><a href="#_sub10" class="code">function [x, lambda, fopt, errorFlag, errorMsg, extra] = runmosek( f, A, b, lb, ub, sense, constraintTypes, ~, options)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function varargout = linearProgramming(maximizeFlag, f, A, b, lb, ub, constraintTypes, variableTypes, options)</a>
0002 <span class="comment">% Provides a common interface to several linear programming solvers.</span>
0003 <span class="comment">% Checks each solver for errors.</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% That is it solves the problem:</span>
0006 <span class="comment">%   max f'*x</span>
0007 <span class="comment">%   subject to A*x~b, lb&lt;=x&lt;=ub</span>
0008 <span class="comment">% where &quot;~&quot; can be equality, or double or single-sided inequality</span>
0009 <span class="comment">% constraints if the chosen linear programming solver supports those</span>
0010 <span class="comment">% types of constraints. Additionally the variables, x, can, if the chosen</span>
0011 <span class="comment">% linear programming solver supports it, either continuous, integer, and</span>
0012 <span class="comment">% boolean valued.</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% Constraint Types: etiher a single value, or a column vector or values:</span>
0015 <span class="comment">%   'F' Free (unbounded) variable (the constraint is ignored).</span>
0016 <span class="comment">%   'U' Variable with upper bound ( A(i,:)*x &lt;= b(i)).</span>
0017 <span class="comment">%   'S' Fixed Variable (A(i,:)*x = b(i)).</span>
0018 <span class="comment">%   'L' Variable with lower bound (A(i,:)*x &gt;= b(i)).</span>
0019 <span class="comment">%   'D' Double-bounded variable (A(i,:)*x &gt;= -b(i) and A(i,:)*x &lt;= b(i)).</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% Variable Types: either a single value, or a column vector or values:</span>
0022 <span class="comment">%   'C' Continuous variable.</span>
0023 <span class="comment">%   'I' Integer variable</span>
0024 <span class="comment">%   'B' Binary variable</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% Output</span>
0027 <span class="comment">%  x</span>
0028 <span class="comment">%  lambda,</span>
0029 <span class="comment">%  fopt</span>
0030 <span class="comment">%  errorFlag</span>
0031 <span class="comment">%  errorMsg</span>
0032 <span class="comment">%  extra</span>
0033 <span class="comment">%</span>
0034 <span class="comment">% Requirements: at least one of the following linear programing solvers</span>
0035 <span class="comment">% - glpk -- GNU Linear programming kit, to solve linear programming problems</span>
0036 <span class="comment">%   http://sourceforge.net/projects/glpkmex/</span>
0037 <span class="comment">% - lp_solve -- open source solve linear programming solver</span>
0038 <span class="comment">%   http://sourceforge.net/projects/lpsolve</span>
0039 <span class="comment">% - clp -- open source solve linear programming solver</span>
0040 <span class="comment">%   http://control.ee.ethz.ch/~joloef/mexclp.zip</span>
0041 <span class="comment">% - bpmpd -- open source solve linear programming solver</span>
0042 <span class="comment">%   http://www.pserc.cornell.edu/bpmpd/</span>
0043 <span class="comment">% - qsopt -- open source solve linear programming solver</span>
0044 <span class="comment">%   http://control.ee.ethz.ch/~joloef/mexqsopt.msql</span>
0045 <span class="comment">% - Optimization Toolbox - has linprog, MATLAB's linear programming</span>
0046 <span class="comment">%   solver. Note: linprog is not vevy good. We suggest you use another</span>
0047 <span class="comment">%   solver instead.</span>
0048 <span class="comment">%   http://www.mathworks.com/products/optimization/</span>
0049 <span class="comment">%</span>
0050 <span class="comment">% Author: Jonathan Karr</span>
0051 <span class="comment">% Affiliation: Covert Lab, Department of Bioengineering, Stanford University</span>
0052 <span class="comment">% Last updated: 10/31/2008</span>
0053 
0054 <span class="comment">%- A is non-empty</span>
0055 <span class="comment">%- b is real column vector of length ncols(A)</span>
0056 <span class="comment">%- lb, ub are real column vectors of length nrows(A)</span>
0057 validateattributes(A, {<span class="string">'numeric'</span>}, {<span class="string">'nonempty'</span>});
0058 validateattributes(b, {<span class="string">'numeric'</span>}, {<span class="string">'real'</span>, <span class="string">'size'</span>, [size(A, 1) 1]});
0059 <span class="keyword">if</span> isempty(lb)
0060     lb = -Inf(size(A, 2), 1);
0061 <span class="keyword">else</span>
0062     validateattributes(lb, {<span class="string">'numeric'</span>}, {<span class="string">'real'</span>, <span class="string">'size'</span>, [size(A, 2) 1]});
0063 <span class="keyword">end</span>
0064 <span class="keyword">if</span> isempty(ub)
0065     ub = -Inf(size(A, 2), 1);
0066 <span class="keyword">else</span>
0067     validateattributes(ub, {<span class="string">'numeric'</span>}, {<span class="string">'real'</span>, <span class="string">'size'</span>, [size(A, 2) 1]});
0068 <span class="keyword">end</span>
0069 
0070 <span class="comment">%error check length sizes of contraint and variable types, expand if</span>
0071 <span class="comment">%necessary</span>
0072 <span class="keyword">if</span> isscalar(constraintTypes)
0073     <span class="keyword">if</span> ~ismembc(constraintTypes, <span class="string">'DFLSUdflsu'</span>)
0074         throw(MException(<span class="string">'ComputationUtil:LinearProgramming'</span>, <span class="string">'linear programming: invalid constraints types'</span>));
0075     <span class="keyword">end</span>
0076     constraintTypes = constraintTypes(ones(length(b), 1), 1);
0077 <span class="keyword">elseif</span> length(constraintTypes) ~= length(b)
0078     throw(MException(<span class="string">'ComputationUtil:LinearProgramming'</span>, <span class="string">'linear programming: invalid constraints types'</span>));
0079 <span class="keyword">elseif</span> ~all(ismembc(constraintTypes, <span class="string">'DFLSUdflsu'</span>))
0080     throw(MException(<span class="string">'ComputationUtil:LinearProgramming'</span>, <span class="string">'linear programming: invalid constraints types'</span>));
0081 <span class="keyword">end</span>
0082 
0083 <span class="keyword">if</span> isscalar(variableTypes)
0084     <span class="keyword">if</span> ~ismembc(variableTypes, <span class="string">'BCIbci'</span>)
0085         throw(MException(<span class="string">'ComputationUtil:LinearProgramming'</span>, <span class="string">'linear programming: invalid variable types'</span>));
0086     <span class="keyword">end</span>
0087     variableTypes = variableTypes(ones(size(A, 2), 1), 1);
0088 <span class="keyword">elseif</span> length(variableTypes) ~= length(lb)
0089     throw(MException(<span class="string">'ComputationUtil:LinearProgramming'</span>, <span class="string">'linear programming: invalid variable types'</span>));
0090 <span class="keyword">elseif</span> ~all(ismembc(variableTypes, <span class="string">'BCIbci'</span>))
0091     throw(MException(<span class="string">'ComputationUtil:LinearProgramming'</span>, <span class="string">'linear programming: invalid variable types'</span>));
0092 <span class="keyword">end</span>
0093 
0094 <span class="comment">%compute sense from maximizeFlag</span>
0095 <span class="comment">%if maximize='maximize'-&gt;sense=-1</span>
0096 <span class="comment">%otherwise-&gt;sense=1</span>
0097 sense = 1 - 2 *strcmp(maximizeFlag, <span class="string">'maximize'</span>);
0098 
0099 <span class="comment">%solver linear programming problem using chosen solver</span>
0100 varargout = cell(max(nargout, 1), 1);
0101 <span class="keyword">switch</span> options.solver(1:2)
0102     <span class="keyword">case</span> <span class="string">'gl'</span>; [varargout{:}] = <a href="#_sub2" class="code" title="subfunction [x, lambda, fopt, errorFlag, errorMsg, extra] = runglpk(f, A, b, lb, ub, sense, constraintTypes, variableTypes, options)">runglpk</a>(   f, A, b, lb, ub, sense, constraintTypes, variableTypes, options);
0103     <span class="keyword">case</span> <span class="string">'li'</span>; [varargout{:}] = <a href="#_sub1" class="code" title="subfunction [x, lambda, fopt, errorFlag, errorMsg, extra] = runlinprog(f, A, b, lb, ub, sense, constraintTypes, variableTypes, options)">runlinprog</a>(f, A, b, lb, ub, sense, constraintTypes, variableTypes, options);    
0104     <span class="keyword">case</span> <span class="string">'bp'</span>; [varargout{:}] = <a href="#_sub6" class="code" title="subfunction [x, lambda, fopt, errorFlag, errorMsg, extra] = runbpmpd(f, A, b, lb, ub, sense, constraintTypes, variableTypes, ~)">runbpmpd</a>(  f, A, b, lb, ub, sense, constraintTypes, variableTypes, options);
0105     <span class="keyword">case</span> <span class="string">'cl'</span>; [varargout{:}] = <a href="#_sub5" class="code" title="subfunction [x, lambda, fopt, errorFlag, errorMsg, extra] = runclp(f, A, b, lb, ub, sense, constraintTypes, variableTypes, options)">runclp</a>(    f, A, b, lb, ub, sense, constraintTypes, variableTypes, options);
0106     <span class="keyword">case</span> <span class="string">'lp'</span>; [varargout{:}] = <a href="#_sub3" class="code" title="subfunction [x, lambda, fopt, errorFlag, errorMsg, extra] = runlpsolve(f, A, b, lb, ub, sense, constraintTypes, variableTypes, options)">runlpsolve</a>(f, A, b, lb, ub, sense, constraintTypes, variableTypes, options);
0107     <span class="keyword">case</span> <span class="string">'qs'</span>; [varargout{:}] = <a href="#_sub4" class="code" title="subfunction [x, lambda, fopt, errorFlag, errorMsg, extra] = runqsopt(f, A, b, lb, ub, sense, constraintTypes, variableTypes, options)">runqsopt</a>(  f, A, b, lb, ub, sense, constraintTypes, variableTypes, options);
0108     <span class="keyword">case</span> <span class="string">'to'</span>; [varargout{:}] = <a href="#_sub7" class="code" title="subfunction [x, lambda, fopt, errorFlag, errorMsg, extra] = runtomlab( f, A, b, lb, ub, sense, constraintTypes, ~, options)">runtomlab</a>( f, A, b, lb, ub, sense, constraintTypes, variableTypes, options);
0109     <span class="keyword">case</span> <span class="string">'cp'</span>; [varargout{:}] = <a href="#_sub8" class="code" title="subfunction [x, lambda, fopt, errorFlag, errorMsg, extra] = runcplex( f, A, b, lb, ub, sense, constraintTypes, variableTypes, options)">runcplex</a>(  f, A, b, lb, ub, sense, constraintTypes, variableTypes, options);
0110     <span class="keyword">case</span> <span class="string">'gu'</span>; [varargout{:}] = <a href="#_sub9" class="code" title="subfunction [x, lambda, fopt, errorFlag, errorMsg, extra] = rungurobi( f, A, b, lb, ub, sense, constraintTypes, variableTypes, options)">rungurobi</a>( f, A, b, lb, ub, sense, constraintTypes, variableTypes, options);
0111     <span class="keyword">case</span> <span class="string">'mo'</span>; [varargout{:}] = <a href="#_sub10" class="code" title="subfunction [x, lambda, fopt, errorFlag, errorMsg, extra] = runmosek( f, A, b, lb, ub, sense, constraintTypes, ~, options)">runmosek</a>(  f, A, b, lb, ub, sense, constraintTypes, variableTypes, options);
0112     <span class="keyword">otherwise</span>; throw(MException(<span class="string">'ComputationUtil:LinearProgramming'</span>, <span class="string">'Support for %s not implemented'</span>, options.solver));
0113 <span class="keyword">end</span>
0114 
0115 <a name="_sub1" href="#_subfunctions" class="code">function [x, lambda, fopt, errorFlag, errorMsg, extra] = runlinprog(f, A, b, lb, ub, sense, constraintTypes, variableTypes, options)</a>
0116 
0117 <span class="comment">%setup equality, inequality constraints based on constraint types</span>
0118 Aeq = [];
0119 beq = [];
0120 <span class="keyword">if</span> sum(constraintTypes == <span class="string">'S'</span>) == length(constraintTypes)
0121     Aeq = A;
0122     A = [];
0123     beq = b;
0124     b = [];
0125 <span class="keyword">elseif</span> sum(constraintTypes == <span class="string">'U'</span>) == length(constraintTypes)
0126 <span class="keyword">elseif</span> sum(constraintTypes == <span class="string">'L'</span>) == length(constraintTypes)
0127     A = -A;
0128     b = -b;
0129 <span class="keyword">else</span>
0130     throw(MException(<span class="string">'ComputationUtil:LinearProgramming'</span>, <span class="string">'linprog: constraint types invalid'</span>));
0131 <span class="keyword">end</span>
0132 
0133 <span class="comment">%throw error if integer or boolean variable types requested, linprog</span>
0134 <span class="comment">%doesn't have this capability</span>
0135 <span class="keyword">if</span> sum(variableTypes == <span class="string">'C'</span>) ~= length(variableTypes)
0136     throw(MException(<span class="string">'ComputationUtil:LinearProgramming'</span>, <span class="string">'linprog: variable types invalid'</span>));
0137 <span class="keyword">end</span>
0138 
0139 <span class="comment">%linprog options</span>
0140 <span class="keyword">if</span> isfield(options.solverOptions, <span class="string">'linprog'</span>)
0141     linprogoptions = options.solverOptions.linprog;
0142 <span class="keyword">else</span>
0143     linprogoptions = struct;
0144 <span class="keyword">end</span>
0145 
0146 <span class="keyword">try</span>
0147     [x, fopt, exitflag, ~, lambda] = linprog(sense * f, A, b, Aeq, beq, lb, ub, [], linprogoptions);
0148  
0149     lambda = struct(<span class="string">'reducedCosts'</span>, NaN(size(A, 2), 1), <span class="string">'shadowPrices'</span>, lambda);    
0150     fopt = fopt * sense;
0151     errorFlag = exitflag ~= 1;
0152     <span class="keyword">switch</span> exitflag
0153         <span class="keyword">case</span>  1; errorMsg = <span class="string">'Function converged to a solution x.'</span>;
0154         <span class="keyword">case</span>  0; errorMsg = <span class="string">'Number of iterations exceeded options.MaxIter.'</span>;
0155         <span class="keyword">case</span> -2; errorMsg = <span class="string">'No feasible point was found.'</span>;
0156         <span class="keyword">case</span> -3; errorMsg = <span class="string">'Problem is unbounded.'</span>;
0157         <span class="keyword">case</span> -4; errorMsg = <span class="string">'NaN value was encountered during execution of the algorithm.'</span>;
0158         <span class="keyword">case</span> -5; errorMsg = <span class="string">'Both primal and dual problems are infeasible.'</span>;
0159         <span class="keyword">case</span> -7; errorMsg = <span class="string">'Search direction became too small. No further progress could be made.'</span>;
0160     <span class="keyword">end</span>
0161 <span class="keyword">catch</span> exception
0162     errorFlag = 1;
0163     errorMsg = exception.message;
0164     x = NaN(size(lb));
0165     lambda = struct(<span class="string">'reducedCosts'</span>, NaN(size(A, 2), 1), <span class="string">'shadowPrices'</span>, NaN(size(A, 1), 1));
0166     fopt = NaN;    
0167 <span class="keyword">end</span>
0168 
0169 extra = struct;
0170 
0171 <a name="_sub2" href="#_subfunctions" class="code">function [x, lambda, fopt, errorFlag, errorMsg, extra] = runglpk(f, A, b, lb, ub, sense, constraintTypes, variableTypes, options)</a>
0172 
0173 <span class="comment">%make structure of glpk options</span>
0174 <span class="keyword">if</span> isfield(options.solverOptions, <span class="string">'glpk'</span>)
0175     glpkoptions = options.solverOptions.glpk;
0176 <span class="keyword">else</span>
0177     glpkoptions = struct;
0178 <span class="keyword">end</span>
0179 
0180 <span class="comment">%call glpk</span>
0181 <span class="keyword">try</span>
0182     [x, fopt, status, extra] = glpkcc(f, A, b, lb, ub, constraintTypes, variableTypes, sense, glpkoptions);
0183     lambda = struct(<span class="string">'reducedCosts'</span>, extra.redcosts, <span class="string">'shadowPrices'</span>, extra.lambda);
0184     errorFlag = ~(status == 5 || status == 2);
0185     <span class="keyword">switch</span> status
0186         <span class="comment">%General Errors</span>
0187         <span class="keyword">case</span> 5; errorMsg = <span class="string">'Solution is optimal'</span>;
0188         <span class="keyword">case</span> 2; errorMsg = <span class="string">'Solution is feasible'</span>;
0189         <span class="keyword">case</span> 1; errorMsg = <span class="string">'Solution is undefined'</span>;
0190         <span class="keyword">case</span> 3; errorMsg = <span class="string">'Solution is infeasible'</span>;
0191         <span class="keyword">case</span> 4; errorMsg = <span class="string">'No feasible solution exists'</span>;
0192         <span class="keyword">case</span> 6; errorMsg = <span class="string">'Solution is unbounded'</span>;
0193             
0194         <span class="comment">%Simplex method Errors:</span>
0195         <span class="keyword">case</span> 101; errorMsg = <span class="string">'Invalid basis'</span>;
0196         <span class="keyword">case</span> 102; errorMsg = <span class="string">'Singular matrix'</span>;
0197         <span class="keyword">case</span> 103; errorMsg = <span class="string">'Ill-conditioned matrix'</span>;
0198         <span class="keyword">case</span> 104; errorMsg = <span class="string">'Invalid bounds'</span>;
0199         <span class="keyword">case</span> 105; errorMsg = <span class="string">'Solver failed'</span>;
0200         <span class="keyword">case</span> 106; errorMsg = <span class="string">'Objective lower limit reached'</span>;
0201         <span class="keyword">case</span> 107; errorMsg = <span class="string">'Objective upper limit reached'</span>;
0202         <span class="keyword">case</span> 108; errorMsg = <span class="string">'Iteration limit exceeded'</span>;
0203         <span class="keyword">case</span> 109; errorMsg = <span class="string">'Time limit exceeded'</span>;
0204         <span class="keyword">case</span> 110; errorMsg = <span class="string">'No primal feasible solution'</span>;
0205 
0206         <span class="comment">%Interior point method, mixed integer problem Errors:</span>
0207         <span class="keyword">case</span> 204; errorMsg = <span class="string">'Unable to start the search.'</span>;
0208         <span class="keyword">case</span> 205; errorMsg = <span class="string">'Objective function lower limit reached.'</span>;
0209         <span class="keyword">case</span> 206; errorMsg = <span class="string">'Objective function upper limit reached.'</span>;
0210         <span class="keyword">case</span> 207; errorMsg = <span class="string">'Iterations limit exhausted.'</span>;
0211         <span class="keyword">case</span> 208; errorMsg = <span class="string">'Time limit exhausted.'</span>;
0212         <span class="keyword">case</span> 209; errorMsg = <span class="string">'No feasible solution.'</span>;
0213         <span class="keyword">case</span> 210; errorMsg = <span class="string">'Numerical instability.'</span>;
0214         <span class="keyword">case</span> 211; errorMsg = <span class="string">'Problems with basis matrix.'</span>;
0215         <span class="keyword">case</span> 212; errorMsg = <span class="string">'No convergence (interior).'</span>;
0216         <span class="keyword">case</span> 213; errorMsg = <span class="string">'No primal feasible solution (LP presolver).'</span>;
0217         <span class="keyword">case</span> 214; errorMsg = <span class="string">'No dual feasible solution (LP presolver).'</span>;
0218             
0219         <span class="keyword">otherwise</span>, errorMsg = sprintf(<span class="string">'Invalid error code %d'</span>, status);
0220     <span class="keyword">end</span>
0221 <span class="keyword">catch</span> exception
0222     errorFlag = 1;
0223     errorMsg = exception.message;
0224     x = NaN(size(lb));
0225     lambda = struct(<span class="string">'reducedCosts'</span>, NaN(size(A, 2), 1), <span class="string">'shadowPrices'</span>, NaN(size(A, 1), 1));
0226     fopt = NaN;
0227 <span class="keyword">end</span>
0228 
0229 extra = struct;
0230 
0231 <a name="_sub3" href="#_subfunctions" class="code">function [x, lambda, fopt, errorFlag, errorMsg, extra] = runlpsolve(f, A, b, lb, ub, sense, constraintTypes, variableTypes, options)</a>
0232 <span class="comment">%options</span>
0233 verbose = 3;
0234 presolve = 0; <span class="comment">%none</span>
0235 scaling = 4 + 64 + 128; <span class="comment">%geometric + equilibrate + integers</span>
0236 <span class="keyword">if</span> isfield(options.solverOptions, <span class="string">'lp_solve'</span>)
0237     <span class="keyword">if</span> isfield(options.solverOptions.lp_solve, <span class="string">'verbose'</span>), verbose = options.solverOptions.lp_solve.verbose; <span class="keyword">end</span>
0238     <span class="keyword">if</span> isfield(options.solverOptions.lp_solve, <span class="string">'presolve'</span>), presolve = options.solverOptions.lp_solve.presolve; <span class="keyword">end</span>
0239     <span class="keyword">if</span> isfield(options.solverOptions.lp_solve, <span class="string">'scaling'</span>), scaling = options.solverOptions.lp_solve.scaling; <span class="keyword">end</span>    
0240 <span class="keyword">end</span>
0241 
0242 <span class="comment">%convert variable types to lp_solve format'</span>
0243 <span class="keyword">if</span> any(variableTypes == <span class="string">'B'</span>); throw(MException(<span class="string">'ComputationUtil:LinearProgramming'</span>, <span class="string">'lp_solve: boolean variables are not allowed'</span>)); <span class="keyword">end</span>;
0244 xint = NaN(size(variableTypes));
0245 xint(variableTypes == <span class="string">'I'</span>) = 1;
0246 xint(variableTypes == <span class="string">'C'</span>) = 0;
0247 
0248 <span class="comment">%convert constraints types to lp_solve format</span>
0249 <span class="keyword">if</span> any(constraintTypes == <span class="string">'F'</span>); throw(MException(<span class="string">'ComputationUtil:LinearProgramming'</span>, <span class="string">'lp_solve: free constraints are not allowed'</span>)); <span class="keyword">end</span>;
0250 <span class="keyword">if</span> any(constraintTypes == <span class="string">'D'</span>); throw(MException(<span class="string">'ComputationUtil:LinearProgramming'</span>, <span class="string">'lp_solve: double-sided constraints are not allowed'</span>)); <span class="keyword">end</span>;
0251 con_types = NaN(size(constraintTypes));
0252 con_types(constraintTypes == <span class="string">'L'</span>) = 2;
0253 con_types(constraintTypes == <span class="string">'S'</span>) = 3;
0254 con_types(constraintTypes == <span class="string">'U'</span>) = 1;
0255 
0256 <span class="keyword">try</span>
0257     lp = mxlpsolve(<span class="string">'make_lp'</span>, size(A, 1), size(A, 2));
0258     mxlpsolve(<span class="string">'set_verbose'</span>, lp, verbose);
0259     mxlpsolve(<span class="string">'set_mat'</span>, lp, A);
0260     mxlpsolve(<span class="string">'set_rh_vec'</span>, lp, b);
0261     mxlpsolve(<span class="string">'set_obj_fn'</span>, lp, f);
0262     mxlpsolve(<span class="string">'set_sense'</span>, lp, (sense == -1) + 0);
0263     mxlpsolve(<span class="string">'set_constr_type'</span>, lp, con_types);
0264     mxlpsolve(<span class="string">'set_bounds'</span>, lp, lb, ub);
0265     mxlpsolve(<span class="string">'set_int'</span>, lp, xint);    
0266     mxlpsolve(<span class="string">'set_presolve'</span>, lp, presolve, mxlpsolve(<span class="string">'get_presolveloops'</span>, lp));
0267     mxlpsolve(<span class="string">'set_scaling'</span>, lp, scaling);
0268         
0269     status = mxlpsolve(<span class="string">'solve'</span>, lp);
0270     errorFlag =~ status == 0 || status == 1 || status == 11 || status == 12;
0271     <span class="keyword">if</span> ~errorFlag
0272         [fopt, x, duals] = mxlpsolve(<span class="string">'get_solution'</span>, lp);
0273         reducedCosts = mxlpsolve(<span class="string">'get_reduced_costs'</span>, lp);
0274     <span class="keyword">else</span>
0275         fopt = NaN;
0276         x = NaN(size(lb));
0277         duals = NaN(size(A, 1), 1);
0278         reducedCosts = NaN(size(A, 2), 1);        
0279     <span class="keyword">end</span>
0280     
0281     extra = struct;
0282     <span class="keyword">if</span> nargin &gt;= 6
0283         tmpFileName = [<span class="string">'lpsolve.'</span> datestr(now, 30) <span class="string">'.txt'</span>];
0284         
0285         mxlpsolve(<span class="string">'set_outputfile'</span>, lp, tmpFileName);
0286         mxlpsolve(<span class="string">'print_scales'</span>, lp);
0287         
0288         fid = fopen(tmpFileName, <span class="string">'r'</span>);
0289         fgetl(fid);
0290         fgetl(fid);
0291         line = fgetl(fid);
0292         extra.objScaling = str2double(line(32:end));
0293         extra.rowScaling = zeros(size(A, 1), 1);
0294         extra.colScaling = zeros(size(A, 2), 1);
0295         <span class="keyword">for</span> i = 1:size(A, 1)
0296             line = fgetl(fid);
0297             extra.rowScaling(i) = str2double(line(32:end));
0298         <span class="keyword">end</span>
0299         <span class="keyword">for</span> i = 1:size(A, 2)
0300             line = fgetl(fid);
0301             extra.colScaling(i) = str2double(line(32:end));
0302         <span class="keyword">end</span>
0303         fclose(fid);                
0304     <span class="keyword">end</span>
0305     
0306     mxlpsolve(<span class="string">'delete_lp'</span>, lp);
0307     
0308     <span class="keyword">if</span> nargin &gt;= 6
0309         delete(tmpFileName);
0310     <span class="keyword">end</span>
0311            
0312     lambda = struct(<span class="string">'reducedCosts'</span>, reducedCosts, <span class="string">'shadowPrices'</span>, duals);
0313     <span class="keyword">switch</span> status
0314         <span class="keyword">case</span> -2; errorMsg = <span class="string">'Out of memory'</span>;
0315         <span class="keyword">case</span> 0; errorMsg = <span class="string">'An optimal solution was obtained'</span>;
0316         <span class="keyword">case</span> 1; errorMsg = [<span class="string">'The model is sub-optimal. Only happens if there are integer variables and there is already an integer solution found. The solution is not guaranteed the most optimal one.\n'</span><span class="keyword">...</span>
0317                 <span class="string">'* A timeout occured (set via set_timeout or with the -timeout option in lp_solve)\n'</span><span class="keyword">...</span>
0318                 <span class="string">'* set_break_at_first was called so that the first found integer solution is found (-f option in lp_solve)\n'</span><span class="keyword">...</span>
0319                 <span class="string">'* set_break_at_value was called so that when integer solution is found that is better than the specified value that it stops (-o option in lp_solve)\n'</span><span class="keyword">...</span>
0320                 <span class="string">'* set_mip_gap was called (-g/-ga/-gr options in lp_solve) to specify a MIP gap\n'</span><span class="keyword">...</span>
0321                 <span class="string">'* An abort function is installed (put_abortfunc) and this function returned TRUE\n'</span><span class="keyword">...</span>
0322                 <span class="string">'* At some point not enough memory could not be allocated'</span>];
0323         <span class="keyword">case</span> 2; errorMsg = <span class="string">'The model is infeasible'</span>;
0324         <span class="keyword">case</span> 3; errorMsg = <span class="string">'The model is unbounded'</span>;
0325         <span class="keyword">case</span> 4; errorMsg = <span class="string">'The model is degenerative'</span>;
0326         <span class="keyword">case</span> 5; errorMsg = <span class="string">'Numerical failure encountered'</span>;
0327         <span class="keyword">case</span> 6; errorMsg = <span class="string">'The abort routine returned TRUE. See put_abortfunc'</span>;
0328         <span class="keyword">case</span> 7; errorMsg = <span class="string">'A timeout occurred. A timeout was set via set_timeout'</span>;
0329         <span class="keyword">case</span> 9; errorMsg = <span class="string">'The model could be solved by presolve. This can only happen if presolve is active via set_presolve'</span>;
0330         <span class="keyword">case</span> 10; errorMsg = <span class="string">'The B&amp;B routine failed'</span>;
0331         <span class="keyword">case</span> 11; errorMsg = <span class="string">'The B&amp;B was stopped because of a break-at-first (see set_break_at_first) or a break-at-value (see set_break_at_value)'</span>;
0332         <span class="keyword">case</span> 12; errorMsg = <span class="string">'A feasible B&amp;B solution was found'</span>;
0333         <span class="keyword">case</span> 13; errorMsg = <span class="string">'No feasible B&amp;B solution found'</span>;
0334     <span class="keyword">end</span>
0335 <span class="keyword">catch</span> exception
0336     errorFlag = 1;
0337     errorMsg = exception.message;
0338     x = NaN(size(lb));
0339     lambda = struct(<span class="string">'reducedCosts'</span>, NaN(size(A, 2), 1), <span class="string">'shadowPrices'</span>, NaN(size(A, 1), 1));
0340     fopt = NaN;
0341     extra = struct;
0342 <span class="keyword">end</span>
0343 
0344 <a name="_sub4" href="#_subfunctions" class="code">function [x, lambda, fopt, errorFlag, errorMsg, extra] = runqsopt(f, A, b, lb, ub, sense, constraintTypes, variableTypes, options)</a>
0345 
0346 <span class="comment">%setup equality, inequality constraints based on constraint types</span>
0347 Aeq = [];
0348 beq = [];
0349 <span class="keyword">if</span> sum(constraintTypes == <span class="string">'S'</span>) == length(constraintTypes)
0350     Aeq = A;
0351     A = [];
0352     beq = b;
0353     b = [];
0354 <span class="keyword">elseif</span> sum(constraintTypes == <span class="string">'U'</span>) == length(constraintTypes)
0355 <span class="keyword">elseif</span> sum(constraintTypes == <span class="string">'L'</span>) == length(constraintTypes)
0356     A = -A;
0357     b = -b;
0358 <span class="keyword">else</span>
0359     throw(MException(<span class="string">'ComputationUtil:LinearProgramming'</span>, <span class="string">'qsopt: constraint types invalid'</span>));
0360 <span class="keyword">end</span>
0361 
0362 <span class="comment">%throw error if integer or boolean variable types requested, qsopt</span>
0363 <span class="comment">%doesn't have this capability</span>
0364 <span class="keyword">if</span> sum(variableTypes == <span class="string">'C'</span>) ~= length(variableTypes)
0365     throw(MException(<span class="string">'ComputationUtil:LinearProgramming'</span>, <span class="string">'qsopt: variable types invalid'</span>));
0366 <span class="keyword">end</span>
0367 
0368 <span class="comment">%make structure of qsopt options</span>
0369 qsoptoptions = struct;
0370 <span class="keyword">if</span> isfield(options.solverOptions, <span class="string">'qsopt'</span>)
0371     qsoptoptions = options.solverOptions.qsopt;
0372 <span class="keyword">end</span>
0373 
0374 <span class="keyword">try</span>
0375     [x, dual, status] = qsopt(sense * f, A, b, Aeq, beq, lb, ub, qsoptoptions);
0376     lambda = struct(<span class="string">'reducedCosts'</span>, NaN(size(A, 2), 1), <span class="string">'shadowPrices'</span>, dual);
0377     fopt = f' * x;
0378     errorFlag = status ~= 1;
0379     <span class="keyword">switch</span> status
0380         <span class="keyword">case</span> 1; errorMsg = <span class="string">'optimal'</span>;
0381         <span class="keyword">case</span> 2; errorMsg = <span class="string">'infeasible'</span>;
0382         <span class="keyword">case</span> 3; errorMsg = <span class="string">'unbounded'</span>;
0383         <span class="keyword">case</span> 4; errorMsg = <span class="string">'iteration limit'</span>;
0384         <span class="keyword">case</span> 5; errorMsg = <span class="string">'time limit'</span>;
0385         <span class="keyword">case</span> 6; errorMsg = <span class="string">'other problem'</span>;
0386     <span class="keyword">end</span>
0387 <span class="keyword">catch</span> exception
0388     errorFlag = 1;
0389     errorMsg = exception.message;
0390     x = NaN(size(lb));
0391     lambda = struct(<span class="string">'reducedCosts'</span>, NaN(size(A, 2), 1), <span class="string">'shadowPrices'</span>, NaN(size(A, 1), 1));
0392     fopt = NaN;
0393 <span class="keyword">end</span>
0394 
0395 extra = struct;
0396 
0397 <a name="_sub5" href="#_subfunctions" class="code">function [x, lambda, fopt, errorFlag, errorMsg, extra] = runclp(f, A, b, lb, ub, sense, constraintTypes, variableTypes, options)</a>
0398 
0399 <span class="comment">%setup equality, inequality constraints based on constraint types</span>
0400 Aeq = [];
0401 beq = [];
0402 <span class="keyword">if</span> sum(constraintTypes == <span class="string">'S'</span>) == length(constraintTypes)
0403     Aeq = A;
0404     A = [];
0405     beq = b;
0406     b = [];
0407 <span class="keyword">elseif</span> sum(constraintTypes == <span class="string">'U'</span>) == length(constraintTypes)
0408 <span class="keyword">elseif</span> sum(constraintTypes == <span class="string">'L'</span>) == length(constraintTypes)
0409     A = -A;
0410     b = -b;
0411 <span class="keyword">else</span>
0412     throw(MException(<span class="string">'ComputationUtil:LinearProgramming'</span>, <span class="string">'clp: constraint types invalid'</span>));
0413 <span class="keyword">end</span>
0414 
0415 <span class="comment">%throw error if integer or boolean variable types requested, clp</span>
0416 <span class="comment">%doesn't have this capability</span>
0417 <span class="keyword">if</span> sum(variableTypes == <span class="string">'C'</span>) ~= length(variableTypes)
0418     throw(MException(<span class="string">'ComputationUtil:LinearProgramming'</span>, <span class="string">'clp: variable types invalid'</span>));
0419 <span class="keyword">end</span>
0420 
0421 <span class="comment">%make structure of clp options</span>
0422 clpoptions = struct;
0423 <span class="keyword">if</span> isfield(options.solverOptions, <span class="string">'clp'</span>)
0424     clpoptions = options.solverOptions.clp;
0425 <span class="keyword">end</span>
0426 
0427 <span class="keyword">try</span>
0428     [x, dual, status] = clp(zeros(length(f)), sense * f, A, b, Aeq, beq, lb, ub, clpoptions);
0429     lambda = struct(<span class="string">'reducedCosts'</span>, NaN(size(A, 2), 1), <span class="string">'shadowPrices'</span>, dual);
0430     fopt = f' * x;
0431     errorFlag = status ~= 0;
0432     <span class="keyword">switch</span> status
0433         <span class="keyword">case</span> 0; errorMsg = <span class="string">'optimal'</span>;
0434         <span class="keyword">case</span> 1; errorMsg = <span class="string">'infeasible'</span>;
0435         <span class="keyword">case</span> 2; errorMsg = <span class="string">'unbounded'</span>;
0436     <span class="keyword">end</span>
0437 <span class="keyword">catch</span> exception
0438     errorFlag = 1;
0439     errorMsg = exception.message;
0440     x = NaN(size(lb));
0441     lambda = struct(<span class="string">'reducedCosts'</span>, NaN(size(A, 2), 1), <span class="string">'shadowPrices'</span>, NaN(size(A, 1), 1));
0442     fopt = NaN;
0443 <span class="keyword">end</span>
0444 
0445 extra = struct;
0446 
0447 <a name="_sub6" href="#_subfunctions" class="code">function [x, lambda, fopt, errorFlag, errorMsg, extra] = runbpmpd(f, A, b, lb, ub, sense, constraintTypes, variableTypes, ~)</a>
0448 
0449 <span class="comment">%throw error if integer or boolean variable types requested, bpmpd</span>
0450 <span class="comment">%doesn't have this capability</span>
0451 <span class="keyword">if</span> sum(variableTypes == <span class="string">'C'</span>) ~= length(variableTypes)
0452     throw(MException(<span class="string">'ComputationUtil:LinearProgramming'</span>, <span class="string">'bpmpd: variable types invalid'</span>));
0453 <span class="keyword">end</span>
0454 
0455 <span class="comment">%convert constraints types to bpmpd format</span>
0456 <span class="keyword">if</span> any(constraintTypes == <span class="string">'F'</span>); throw(MException(<span class="string">'ComputationUtil:LinearProgramming'</span>, <span class="string">'bpmpd: free constraints are not allowed'</span>)); <span class="keyword">end</span>;
0457 <span class="keyword">if</span> any(constraintTypes == <span class="string">'D'</span>); throw(MException(<span class="string">'ComputationUtil:LinearProgramming'</span>, <span class="string">'bpmpd: double-sided constraints are not allowed'</span>)); <span class="keyword">end</span>;
0458 e = NaN(size(constraintTypes));
0459 e(constraintTypes == <span class="string">'L'</span>) = 1;
0460 e(constraintTypes == <span class="string">'S'</span>) = 0;
0461 e(constraintTypes == <span class="string">'U'</span>) = -1;
0462 
0463 <span class="comment">%throw error if integer or boolean variable types requested, bpmpd</span>
0464 <span class="comment">%doesn't have this capability</span>
0465 <span class="keyword">if</span> sum(variableTypes == <span class="string">'C'</span>) ~= length(variableTypes)
0466     throw(MException(<span class="string">'ComputationUtil:LinearProgramming'</span>, <span class="string">'bpmpd: variable types invalid'</span>));
0467 <span class="keyword">end</span>
0468 
0469 <span class="keyword">try</span>
0470     llist = (1:length(lb))';
0471     ulist = (1:length(ub))';
0472     [x, dual, ~, w, errorMsg] = bp(zeros(length(f)), A, b, sense * f, e, llist, lb, ulist, ub, bpopt,0);
0473     lambda = struct(<span class="string">'reducedCosts'</span>, w, <span class="string">'shadowPrices'</span>, dual);
0474     fopt = f' * x;
0475     errorFlag =~ strcmp(errorMsg, <span class="string">'optimal solution'</span>);
0476 <span class="keyword">catch</span> exception
0477     errorFlag = 1;
0478     errorMsg = exception.message;
0479     x = NaN(size(lb));
0480     lambda = struct(<span class="string">'reducedCosts'</span>, NaN(size(A, 2), 1), <span class="string">'shadowPrices'</span>, NaN(size(A, 1), 1));
0481     fopt = NaN;
0482 <span class="keyword">end</span>
0483 
0484 extra = struct;
0485 
0486 <a name="_sub7" href="#_subfunctions" class="code">function [x, lambda, fopt, errorFlag, errorMsg, extra] = runtomlab( f, A, b, lb, ub, sense, constraintTypes, ~, options)</a>
0487 
0488 b_L = -Inf(size(b));
0489 b_U =  Inf(size(b));
0490 b_L(constraintTypes == <span class="string">'L'</span>) = b(constraintTypes == <span class="string">'L'</span>);
0491 b_U(constraintTypes == <span class="string">'U'</span>) = b(constraintTypes == <span class="string">'U'</span>);
0492 b_L(constraintTypes == <span class="string">'S'</span>) = b(constraintTypes == <span class="string">'S'</span>);
0493 b_U(constraintTypes == <span class="string">'S'</span>) = b(constraintTypes == <span class="string">'S'</span>);
0494 b_L(constraintTypes == <span class="string">'D'</span>) = -b(constraintTypes == <span class="string">'D'</span>);
0495 b_U(constraintTypes == <span class="string">'D'</span>) =  b(constraintTypes == <span class="string">'D'</span>);
0496 
0497 prob = lpAssign(sense * f, A, b_L, b_U, lb, ub, [], [], [], [], [], [], [], [], []);
0498 
0499 solver = <span class="string">'minos'</span>;
0500 prob.optParam = struct();
0501 PriLev = 0;
0502 <span class="keyword">if</span> isfield(options.solverOptions, <span class="string">'tomlab'</span>)
0503     <span class="keyword">if</span> isfield(options.solverOptions.tomlab, <span class="string">'solver'</span>), solver = options.solverOptions.tomlab.solver; <span class="keyword">end</span>    
0504     <span class="keyword">if</span> isfield(options.solverOptions.tomlab, <span class="string">'optParam'</span>), prob.optParam = options.solverOptions.tomlab.optParam; <span class="keyword">end</span>
0505     <span class="keyword">if</span> isfield(options.solverOptions.tomlab, <span class="string">'PriLev'</span>), PriLev = options.solverOptions.tomlab.PriLev; <span class="keyword">end</span>
0506 <span class="keyword">end</span>
0507 
0508 <span class="keyword">try</span>    
0509     result = tomRun(solver, prob, PriLev);
0510     errorFlag = result.ExitFlag ~= 0;
0511     errorMsg = result.ExitText;
0512     fopt = sense * result.f_k;
0513     x = result.x_k;
0514     lambda = struct(<span class="string">'reducedCosts'</span>, NaN(size(A, 2), 1), <span class="string">'shadowPrices'</span>, NaN(size(A, 1), 1));
0515 <span class="keyword">catch</span> exception
0516     errorFlag = 1;
0517     errorMsg = exception.message;
0518     x = NaN(size(lb));
0519     lambda = struct(<span class="string">'reducedCosts'</span>, NaN(size(A, 2), 1), <span class="string">'shadowPrices'</span>, NaN(size(A, 1), 1));
0520     fopt = NaN;
0521 <span class="keyword">end</span>
0522 
0523 extra = struct;
0524 
0525 <a name="_sub8" href="#_subfunctions" class="code">function [x, lambda, fopt, errorFlag, errorMsg, extra] = runcplex( f, A, b, lb, ub, sense, constraintTypes, variableTypes, options)</a>
0526 b_L = -Inf(size(b));
0527 b_U =  Inf(size(b));
0528 b_L(constraintTypes == <span class="string">'L'</span>) = b(constraintTypes == <span class="string">'L'</span>);
0529 b_U(constraintTypes == <span class="string">'U'</span>) = b(constraintTypes == <span class="string">'U'</span>);
0530 b_L(constraintTypes == <span class="string">'S'</span>) = b(constraintTypes == <span class="string">'S'</span>);
0531 b_U(constraintTypes == <span class="string">'S'</span>) = b(constraintTypes == <span class="string">'S'</span>);
0532 b_L(constraintTypes == <span class="string">'D'</span>) = -b(constraintTypes == <span class="string">'D'</span>);
0533 b_U(constraintTypes == <span class="string">'D'</span>) =  b(constraintTypes == <span class="string">'D'</span>);
0534 
0535 xint = NaN(size(variableTypes));
0536 xint(variableTypes == <span class="string">'I'</span>) = 1;
0537 xint(variableTypes == <span class="string">'C'</span>) = 0;
0538 
0539 PriLev = 0;
0540 cpxControl = struct();
0541 <span class="keyword">if</span> isfield(options.solverOptions, <span class="string">'cplex'</span>)
0542     <span class="keyword">if</span> isfield(options.solverOptions.cplex, <span class="string">'PriLev'</span>), PriLev = options.solverOptions.cplex.PriLev; <span class="keyword">end</span>
0543     <span class="keyword">if</span> isfield(options.solverOptions.cplex, <span class="string">'cpxControl'</span>), cpxControl = options.solverOptions.cplex.cpxControl; <span class="keyword">end</span>
0544 <span class="keyword">end</span>
0545 
0546 <span class="keyword">try</span>    
0547     [x, ~, v, rc, fopt, ~, ~, status] = <span class="keyword">...</span>
0548         cplex(sense * f, A, lb, ub, b_L, b_U, [], <span class="keyword">...</span>
0549         cpxControl, [], PriLev, [], xint);
0550     fopt = fopt * sense;
0551     [errorMsg, exitFlag] = cplexStatus(status);
0552     errorFlag = exitFlag ~= 0;
0553     lambda = struct(<span class="string">'reducedCosts'</span>, rc, <span class="string">'shadowPrices'</span>, v);
0554 <span class="keyword">catch</span> exception
0555     errorFlag = 1;
0556     errorMsg = exception.message;
0557     x = NaN(size(lb));
0558     lambda = struct(<span class="string">'reducedCosts'</span>, NaN(size(A, 2), 1), <span class="string">'shadowPrices'</span>, NaN(size(A, 1), 1));
0559     fopt = NaN;
0560 <span class="keyword">end</span>
0561 
0562 extra = struct;
0563 
0564 <a name="_sub9" href="#_subfunctions" class="code">function [x, lambda, fopt, errorFlag, errorMsg, extra] = rungurobi( f, A, b, lb, ub, sense, constraintTypes, variableTypes, options)</a>
0565 b_L = -Inf(size(b));
0566 b_U =  Inf(size(b));
0567 b_L(constraintTypes == <span class="string">'L'</span>) = b(constraintTypes == <span class="string">'L'</span>);
0568 b_U(constraintTypes == <span class="string">'U'</span>) = b(constraintTypes == <span class="string">'U'</span>);
0569 b_L(constraintTypes == <span class="string">'S'</span>) = b(constraintTypes == <span class="string">'S'</span>);
0570 b_U(constraintTypes == <span class="string">'S'</span>) = b(constraintTypes == <span class="string">'S'</span>);
0571 b_L(constraintTypes == <span class="string">'D'</span>) = -b(constraintTypes == <span class="string">'D'</span>);
0572 b_U(constraintTypes == <span class="string">'D'</span>) =  b(constraintTypes == <span class="string">'D'</span>);
0573 
0574 xint = NaN(size(variableTypes));
0575 xint(variableTypes == <span class="string">'I'</span>) = 1;
0576 xint(variableTypes == <span class="string">'C'</span>) = 0;
0577 
0578 PriLev = 0;
0579 grbControl = struct();
0580 <span class="keyword">if</span> isfield(options.solverOptions, <span class="string">'gurobi'</span>)
0581     <span class="keyword">if</span> isfield(options.solverOptions.gurobi, <span class="string">'PriLev'</span>), PriLev = options.solverOptions.gurobi.PriLev; <span class="keyword">end</span>
0582     <span class="keyword">if</span> isfield(options.solverOptions.gurobi, <span class="string">'grbControl'</span>), grbControl = options.solverOptions.gurobi.grbControl; <span class="keyword">end</span>
0583 <span class="keyword">end</span>
0584 
0585 <span class="keyword">try</span>    
0586     [x, ~, v, rc, fopt, ~, ~, status] = <span class="keyword">...</span>
0587         gurobi(sense * f, A, lb, ub, b_L, b_U, [], <span class="keyword">...</span>
0588         grbControl, PriLev, xint);
0589     fopt = fopt * sense;
0590     [errorMsg, exitFlag] = grbStatus(status);
0591     errorFlag = exitFlag ~= 0;
0592     lambda = struct(<span class="string">'reducedCosts'</span>, rc, <span class="string">'shadowPrices'</span>, v);
0593 <span class="keyword">catch</span> exception
0594     errorFlag = 1;
0595     errorMsg = exception.message;
0596     x = NaN(size(lb));
0597     lambda = struct(<span class="string">'reducedCosts'</span>, NaN(size(A, 2), 1), <span class="string">'shadowPrices'</span>, NaN(size(A, 1), 1));
0598     fopt = NaN;
0599 <span class="keyword">end</span>
0600 
0601 extra = struct;
0602 
0603 <a name="_sub10" href="#_subfunctions" class="code">function [x, lambda, fopt, errorFlag, errorMsg, extra] = runmosek( f, A, b, lb, ub, sense, constraintTypes, ~, options)</a>
0604 <span class="keyword">if</span> sense == 1
0605     cmd = <span class="string">'minimize'</span>;
0606 <span class="keyword">else</span>
0607     cmd = <span class="string">'maximize'</span>;
0608 <span class="keyword">end</span>
0609 
0610 b_L = -Inf(size(b));
0611 b_U =  Inf(size(b));
0612 b_L(constraintTypes == <span class="string">'L'</span>) = b(constraintTypes == <span class="string">'L'</span>);
0613 b_U(constraintTypes == <span class="string">'U'</span>) = b(constraintTypes == <span class="string">'U'</span>);
0614 b_L(constraintTypes == <span class="string">'S'</span>) = b(constraintTypes == <span class="string">'S'</span>);
0615 b_U(constraintTypes == <span class="string">'S'</span>) = b(constraintTypes == <span class="string">'S'</span>);
0616 b_L(constraintTypes == <span class="string">'D'</span>) = -b(constraintTypes == <span class="string">'D'</span>);
0617 b_U(constraintTypes == <span class="string">'D'</span>) =  b(constraintTypes == <span class="string">'D'</span>);
0618 
0619 lb = max(lb, -1e7);
0620 ub = min(ub,  1e7);
0621 
0622 opts = struct(<span class="keyword">...</span>
0623     <span class="string">'MSK_IPAR_LOG'</span>, 0, <span class="string">'MSK_IPAR_MAX_NUM_WARNINGS'</span>, 1e5, <span class="keyword">...</span>
0624     <span class="string">'MSK_IPAR_INTPNT_SCALING'</span>, 0, <span class="string">'MSK_IPAR_SIM_SCALING'</span>, 0, <span class="string">'MSK_IPAR_SIM_SCALING_METHOD'</span>, 1);
0625 <span class="keyword">if</span> isfield(options.solverOptions, <span class="string">'mosek'</span>)
0626     opts = options.solverOptions.mosek;
0627 <span class="keyword">end</span>
0628 
0629 <span class="keyword">try</span>   
0630     result = msklpopt(f, A, b_L, b_U, lb, ub, opts, cmd);
0631     fopt = result.sol.itr.pobjval;
0632     x = result.sol.itr.xx;
0633     errorFlag = result.rcode ~= 0;
0634     errorMsg = result.rmsg;
0635     lambda = struct(<span class="keyword">...</span>
0636         <span class="string">'reducedCosts'</span>, result.sol.itr.slx + result.sol.itr.sux, <span class="keyword">...</span>
0637         <span class="string">'shadowPrices'</span>, result.sol.itr.slc + result.sol.itr.suc);
0638 <span class="keyword">catch</span> exception
0639     errorFlag = 1;
0640     errorMsg = exception.message;
0641     x = NaN(size(lb));
0642     lambda = struct(<span class="string">'reducedCosts'</span>, NaN(size(A, 2), 1), <span class="string">'shadowPrices'</span>, NaN(size(A, 1), 1));
0643     fopt = NaN;
0644 <span class="keyword">end</span>
0645 
0646 extra = struct;</pre></div>
<hr><address>Generated on Thu 19-Jul-2012 18:32:13 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>